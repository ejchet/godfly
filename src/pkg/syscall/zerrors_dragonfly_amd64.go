// mkerrors.sh -m64
// NOT MACHINE GENERATED BY THE COMMAND ABOVE; DO EDIT

// Not Created by cgo -godefs - DO EDIT
// cgo -godefs -- -m64 _const.go

package syscall

const (
	// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/socket.h
	AF_UNSPEC	= 0		/* unspecified */
	AF_LOCAL	= 1		/* local to host (pipes, portals) */
	AF_UNIX		= AF_LOCAL	/* backward compatibility */
	AF_INET		= 2		/* internetwork: UDP, TCP, etc. */
	AF_IMPLINK	= 3		/* arpanet imp addresses */
	AF_PUP		= 4		/* pup protocols: e.g. BSP */
	AF_CHAOS	= 5		/* mit CHAOS protocols */
	AF_NS		= 6		/* XEROX NS protocols */
	AF_ISO		= 7		/* ISO protocols */
	AF_OSI		= AF_ISO
	AF_ECMA		= 8		/* European computer manufacturers */
	AF_DATAKIT	= 9		/* datakit protocols */
	AF_CCITT	= 10		/* CCITT protocols, X.25 etc */
	AF_SNA		= 11		/* IBM SNA */
	AF_DECnet	= 12		/* DECnet */
	AF_DLI		= 13		/* DEC Direct data link interface */
	AF_LAT		= 14		/* LAT */
	AF_HYLINK	= 15		/* NSC Hyperchannel */
	AF_APPLETALK	= 16		/* Apple Talk */
	AF_ROUTE	= 17		/* Internal Routing Protocol */
	AF_LINK		= 18		/* Link layer interface */
	pseudo_AF_XTP	= 19		/* eXpress Transfer Protocol (no AF) */
	AF_COIP		= 20		/* connection-oriented IP, aka ST II */
	AF_CNT		= 21		/* Computer Network Technology */
	pseudo_AF_RTIP	= 22		/* Help Identify RTIP packets */
	AF_IPX		= 23		/* Novell Internet Protocol */
	AF_SIP		= 24		/* Simple Internet Protocol */
	pseudo_AF_PIP	= 25		/* Help Identify PIP packets */
	AF_ISDN		= 26		/* Integrated Services Digital Network*/
	AF_E164		= AF_ISDN		/* CCITT E.164 recommendation */
	pseudo_AF_KEY	= 27		/* Internal key-management function */
	AF_INET6	= 28		/* IPv6 */
	AF_NATM		= 29		/* native ATM access */
	AF_ATM		= 30		/* ATM */
	pseudo_AF_HDRCMPLT = 31		/* Used by BPF to not rewrite headers
					 * in interface output routine
					 */
	AF_NETGRAPH	= 32		/* Netgraph sockets */
	AF_BLUETOOTH	= 33		/* Bluetooth */
	AF_MPLS		= 34		/* Multi-Protocol Label Switching */
	AF_IEEE80211	= 35		/* IEEE 802.11 protocol */
	AF_MAX		= 36
	// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/sysctl.h
	CTL_MAXNAME	= 12		/* largest number of components supported */
	CTLTYPE		= 0xf	/* Mask for the type */
	CTLTYPE_NODE	= 1	/* name is a node */
	CTLTYPE_INT	= 2	/* name describes an integer */
	CTLTYPE_STRING	= 3	/* name describes a string */
	CTLTYPE_QUAD	= 4	/* name describes a 64-bit number */
	CTLTYPE_OPAQUE	= 5	/* name describes a structure */
	CTLTYPE_STRUCT	= CTLTYPE_OPAQUE	/* name describes a structure */
	CTLTYPE_UINT	= 6	/* name describes an unsigned integer */
	CTLTYPE_LONG	= 7	/* name describes a long */
	CTLTYPE_ULONG	= 8	/* name describes an unsigned long */
	CTLTYPE_UQUAD	= 9	/* name describes an unsigned 64-bit number */
	CTLFLAG_RD	= 0x80000000	/* Allow reads of variable */
	CTLFLAG_WR	= 0x40000000	/* Allow writes to the variable */
	CTLFLAG_RW	= CTLFLAG_RD | CTLFLAG_WR
	CTLFLAG_ANYBODY	= 0x10000000	/* All users can set this var */
	CTLFLAG_SECURE	= 0x08000000	/* Permit set only if securelevel<=0 */
	CTLFLAG_PRISON	= 0x04000000	/* Prisoned roots can fiddle */
	CTLFLAG_DYN	= 0x02000000	/* Dynamic oid - can be freed */




///*
// * Copyright (c) 1989, 1993
// *	The Regents of the University of California.  All rights reserved.
// *
// * This code is derived from software contributed to Berkeley by
// * Mike Karels at Berkeley Software Design, Inc.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)sysctl.h	8.1 (Berkeley) 6/2/93
// * $FreeBSD: src/sys/sys/sysctl.h,v 1.81.2.10 2003/05/01 22:48:09 trhodes Exp $
// * $DragonFly: src/sys/sys/sysctl.h,v 1.29 2008/09/30 12:20:29 hasso Exp $
// */
//
//#ifndef _SYS_SYSCTL_H_
//#define	_SYS_SYSCTL_H_
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#ifndef _SYS__POSIX_H_
//#include <sys/_posix.h>
//#endif
//#ifndef _SYS_QUEUE_H_
//#include <sys/queue.h>
//#endif
//
///*
// * Definitions for sysctl call.  The sysctl call uses a hierarchical name
// * for objects that can be examined or modified.  The name is expressed as
// * a sequence of integers.  Like a file path name, the meaning of each
// * component depends on its place in the hierarchy.  The top-level and kern
// * identifiers are defined here, and other identifiers are defined in the
// * respective subsystem header files.
// */
//
//#define CTL_MAXNAME	12	/* largest number of components supported */
//
///*
// * Each subsystem defined by sysctl defines a list of variables
// * for that subsystem. Each name is either a node with further
// * levels defined below it, or it is a leaf of some particular
// * type given below. Each sysctl level defines a set of name/type
// * pairs to be used by sysctl(1) in manipulating the subsystem.
// */
//struct ctlname {
//	char	*ctl_name;	/* subsystem name */
//	int	ctl_type;	/* type of name */
//};
//
//#define CTLTYPE		0xf	/* Mask for the type */
//#define	CTLTYPE_NODE	1	/* name is a node */
//#define	CTLTYPE_INT	2	/* name describes an integer */
//#define	CTLTYPE_STRING	3	/* name describes a string */
//#define	CTLTYPE_QUAD	4	/* name describes a 64-bit number */
//#define	CTLTYPE_OPAQUE	5	/* name describes a structure */
//#define	CTLTYPE_STRUCT	CTLTYPE_OPAQUE	/* name describes a structure */
//#define	CTLTYPE_UINT	6	/* name describes an unsigned integer */
//#define	CTLTYPE_LONG	7	/* name describes a long */
//#define	CTLTYPE_ULONG	8	/* name describes an unsigned long */
//#define	CTLTYPE_UQUAD	9	/* name describes an unsigned 64-bit number */
//
//#define CTLFLAG_RD	0x80000000	/* Allow reads of variable */
//#define CTLFLAG_WR	0x40000000	/* Allow writes to the variable */
//#define CTLFLAG_RW	(CTLFLAG_RD|CTLFLAG_WR)
//#define CTLFLAG_ANYBODY	0x10000000	/* All users can set this var */
//#define CTLFLAG_SECURE	0x08000000	/* Permit set only if securelevel<=0 */
//#define CTLFLAG_PRISON	0x04000000	/* Prisoned roots can fiddle */
//#define CTLFLAG_DYN	0x02000000	/* Dynamic oid - can be freed */
//
///*
// * USE THIS instead of a hardwired number from the categories below
// * to get dynamically assigned sysctl entries using the linker-set
// * technology. This is the way nearly all new sysctl variables should
// * be implemented.
// * e.g. SYSCTL_INT(_parent, OID_AUTO, name, CTLFLAG_RW, &variable, 0, "");
// */ 
//#define OID_AUTO	(-1)
//
//#ifdef _KERNEL
//
//#include <sys/kernel.h>			/* for DATA_SET */
//
//#define SYSCTL_HANDLER_ARGS struct sysctl_oid *oidp, void *arg1, int arg2, \
//	struct sysctl_req *req
//
///*
// * This describes the access space for a sysctl request.  This is needed
// * so that we can use the interface from the kernel or from user-space.
// */
//struct sysctl_req {
//	struct thread	*td;
//	int		unused01;	/* was lock */
//	void		*oldptr;
//	size_t		oldlen;
//	size_t		oldidx;
//	int		(*oldfunc)(struct sysctl_req *, const void *, size_t);
//	void		*newptr;
//	size_t		newlen;
//	size_t		newidx;
//	int		(*newfunc)(struct sysctl_req *, void *, size_t);
//};
//
//SLIST_HEAD(sysctl_oid_list, sysctl_oid);
//
///*
// * This describes one "oid" in the MIB tree.  Potentially more nodes can
// * be hidden behind it, expanded by the handler.
// */
//struct sysctl_oid {
//	struct sysctl_oid_list *oid_parent;
//	SLIST_ENTRY(sysctl_oid) oid_link;
//	int		oid_number;
//	int		oid_kind;
//	void		*oid_arg1;
//	int		oid_arg2;
//	const char	*oid_name;
//	int 		(*oid_handler)(SYSCTL_HANDLER_ARGS);
//	const char	*oid_fmt;
//	int		oid_refcnt;
//	const char	*oid_descr;
//};
//
//#define SYSCTL_IN(r, p, l) (r->newfunc)(r, p, l)
//#define SYSCTL_OUT(r, p, l) (r->oldfunc)(r, p, l)
//
//int sysctl_handle_int(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_long(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_quad(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_intptr(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_string(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_opaque(SYSCTL_HANDLER_ARGS);
//
///*
// * These functions are used to add/remove an oid from the mib.
// */
//void sysctl_register_oid(struct sysctl_oid *oidp);
//void sysctl_unregister_oid(struct sysctl_oid *oidp);
//
///* Declare a static oid to allow child oids to be added to it. */
//#define SYSCTL_DECL(name)					\
//	extern struct sysctl_oid_list sysctl_##name##_children
//
///* Hide these in macros */
//#define	SYSCTL_SET_CHILDREN(oid_ptr, children) do {			\
//	(oid_ptr)->oid_arg1 = (children);				\
//} while(0)
//#define	SYSCTL_CHILDREN(oid_ptr) (struct sysctl_oid_list *) \
//	(oid_ptr)->oid_arg1
//#define	SYSCTL_STATIC_CHILDREN(oid_name) \
//	(&sysctl_##oid_name##_children)
//
///* === Structs and macros related to context handling === */
//
///* All dynamically created sysctls can be tracked in a context list. */
//struct sysctl_ctx_entry {
//	struct sysctl_oid *entry;
//	TAILQ_ENTRY(sysctl_ctx_entry) link;
//};
//
//TAILQ_HEAD(sysctl_ctx_list, sysctl_ctx_entry);
//
//#define	SYSCTL_NODE_CHILDREN(parent, name) \
//	sysctl_##parent##_##name##_children
//
///* This constructs a "raw" MIB oid. */
//#define SYSCTL_OID(parent, nbr, name, kind, a1, a2, handler, fmt, descr) \
//	static struct sysctl_oid sysctl__##parent##_##name = {		 \
//		&sysctl_##parent##_children, { 0 },			 \
//		nbr, kind, a1, a2, #name, handler, fmt, 0, descr };		 \
//	DATA_SET(sysctl_set, sysctl__##parent##_##name);
//
//#define SYSCTL_ADD_OID(ctx, parent, nbr, name, kind, a1, a2, handler, fmt, descr) \
//	sysctl_add_oid(ctx, parent, nbr, name, kind, a1, a2, handler, fmt, descr);
//
///* This constructs a node from which other oids can hang. */
//#define SYSCTL_NODE(parent, nbr, name, access, handler, descr)		    \
//	struct sysctl_oid_list sysctl_##parent##_##name##_children;	    \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_NODE|access,		    \
//		   (void*)&sysctl_##parent##_##name##_children, 0, handler, \
//		   "N", descr);
//
//#define SYSCTL_ADD_NODE(ctx, parent, nbr, name, access, handler, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_NODE|access,	    \
//	0, 0, handler, "N", descr)
//
///* Oid for a string.  len can be 0 to indicate '\0' termination. */
//#define SYSCTL_STRING(parent, nbr, name, access, arg, len, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_STRING|access, \
//		arg, len, sysctl_handle_string, "A", descr)
//
//#define SYSCTL_ADD_STRING(ctx, parent, nbr, name, access, arg, len, descr)  \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_STRING|access,	    \
//	arg, len, sysctl_handle_string, "A", descr)
//
///* Oid for an int.  If ptr is NULL, val is returned. */
//#define SYSCTL_INT(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_INT|access, \
//		ptr, val, sysctl_handle_int, "I", descr)
//
//#define SYSCTL_ADD_INT(ctx, parent, nbr, name, access, ptr, val, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_INT|access,	    \
//	ptr, val, sysctl_handle_int, "I", descr)
//
///* Oid for a quad.  If ptr is NULL, val is returned. */
//#define SYSCTL_QUAD(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_QUAD|access, \
//		ptr, val, sysctl_handle_quad, "Q", descr)
//
//#define SYSCTL_ADD_QUAD(ctx, parent, nbr, name, access, ptr, val, descr)    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_QUAD|access,	    \
//	ptr, val, sysctl_handle_quad, "Q", descr)
//
///* Oid for an unsigned quad.  If ptr is NULL, val is returned. */
//#define SYSCTL_UQUAD(parent, nbr, name, access, ptr, val, descr)	    \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_UQUAD|access,		    \
//		ptr, val, sysctl_handle_quad, "QU", descr)
//
//#define SYSCTL_ADD_UQUAD(ctx, parent, nbr, name, access, ptr, val, descr)   \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_UQUAD|access,	    \
//	ptr, val, sysctl_handle_quad, "QU", descr)
//
///* Oid for an unsigned int.  If ptr is NULL, val is returned. */
//#define SYSCTL_UINT(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_UINT|access, \
//		ptr, val, sysctl_handle_int, "IU", descr)
//
//#define SYSCTL_ADD_UINT(ctx, parent, nbr, name, access, ptr, val, descr)    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_UINT|access,	    \
//	ptr, val, sysctl_handle_int, "IU", descr)
//
///* Oid for a long.  The pointer must be non NULL. */
//#define SYSCTL_LONG(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_LONG|access, \
//		ptr, val, sysctl_handle_long, "L", descr)
//
//#define SYSCTL_ADD_LONG(ctx, parent, nbr, name, access, ptr, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_LONG|access,	    \
//	ptr, 0, sysctl_handle_long, "L", descr)
//
///* Oid for a long.  The pointer must be non NULL. */
//#define SYSCTL_ULONG(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_ULONG|access, \
//		ptr, val, sysctl_handle_long, "LU", descr)
//
//#define SYSCTL_ADD_ULONG(ctx, parent, nbr, name, access, ptr, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_ULONG|access,	    \
//	ptr, 0, sysctl_handle_long, "LU", descr)
//
///* Oid for an opaque object.  Specified by a pointer and a length. */
//#define SYSCTL_OPAQUE(parent, nbr, name, access, ptr, len, fmt, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_OPAQUE|access, \
//		ptr, len, sysctl_handle_opaque, fmt, descr)
//
//#define SYSCTL_ADD_OPAQUE(ctx, parent, nbr, name, access, ptr, len, fmt, descr)\
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_OPAQUE|access,	    \
//	ptr, len, sysctl_handle_opaque, fmt, descr)
//
///* Oid for a struct.  Specified by a pointer and a type. */
//#define SYSCTL_STRUCT(parent, nbr, name, access, ptr, type, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_OPAQUE|access, \
//		ptr, sizeof(struct type), sysctl_handle_opaque, \
//		"S," #type, descr)
//
//#define SYSCTL_ADD_STRUCT(ctx, parent, nbr, name, access, ptr, type, descr) \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_OPAQUE|access,	    \
//	ptr, sizeof(struct type), sysctl_handle_opaque, "S," #type, descr)
//
///* Oid for a procedure.  Specified by a pointer and an arg. */
//#define SYSCTL_PROC(parent, nbr, name, access, ptr, arg, handler, fmt, descr) \
//	SYSCTL_OID(parent, nbr, name, access, \
//		ptr, arg, handler, fmt, descr)
//
//#define SYSCTL_ADD_PROC(ctx, parent, nbr, name, access, ptr, arg, handler, fmt, descr) \
//	sysctl_add_oid(ctx, parent, nbr, name, access,			    \
//	ptr, arg, handler, fmt, descr)
//
//#endif /* _KERNEL */
//
///*
// * Top-level identifiers
// */
//#define	CTL_UNSPEC	0		/* unused */
//#define	CTL_KERN	1		/* "high kernel": proc, limits */
//#define	CTL_VM		2		/* virtual memory */
//#define	CTL_VFS		3		/* file system, mount type is next */
//#define	CTL_NET		4		/* network, see socket.h */
//#define	CTL_DEBUG	5		/* debugging parameters */
//#define	CTL_HW		6		/* generic cpu/io */
//#define	CTL_MACHDEP	7		/* machine dependent */
//#define	CTL_USER	8		/* user-level */
//#define	CTL_P1003_1B	9		/* POSIX 1003.1B */
//#define CTL_LWKT	10		/* light weight kernel threads */
//#define	CTL_MAXID	11		/* number of valid top-level ids */
//
//#define CTL_NAMES { \
//	{ 0, 0 }, \
//	{ "kern", CTLTYPE_NODE }, \
//	{ "vm", CTLTYPE_NODE }, \
//	{ "vfs", CTLTYPE_NODE }, \
//	{ "net", CTLTYPE_NODE }, \
//	{ "debug", CTLTYPE_NODE }, \
//	{ "hw", CTLTYPE_NODE }, \
//	{ "machdep", CTLTYPE_NODE }, \
//	{ "user", CTLTYPE_NODE }, \
//	{ "p1003_1b", CTLTYPE_NODE }, \
//	{ "lwkt", CTLTYPE_NODE }, \
//}
//
///*
// * CTL_KERN identifiers
// */
//#define	KERN_OSTYPE	 	 1	/* string: system version */
//#define	KERN_OSRELEASE	 	 2	/* string: system release */
//#define	KERN_OSREV	 	 3	/* int: system revision */
//#define	KERN_VERSION	 	 4	/* string: compile time info */
//#define	KERN_MAXVNODES	 	 5	/* int: max vnodes */
//#define	KERN_MAXPROC	 	 6	/* int: max processes */
//#define	KERN_MAXFILES	 	 7	/* int: max open files */
//#define	KERN_ARGMAX	 	 8	/* int: max arguments to exec */
//#define	KERN_SECURELVL	 	 9	/* int: system security level */
//#define	KERN_HOSTNAME		10	/* string: hostname */
//#define	KERN_HOSTID		11	/* int: host identifier */
//#define	KERN_CLOCKRATE		12	/* struct: struct clockrate */
//#define	KERN_VNODE		13	/* struct: vnode structures */
//#define	KERN_PROC		14	/* struct: process entries */
//#define	KERN_FILE		15	/* struct: file entries */
//#define	KERN_PROF		16	/* node: kernel profiling info */
//#define	KERN_POSIX1		17	/* int: POSIX.1 version */
//#define	KERN_NGROUPS		18	/* int: # of supplemental group ids */
//#define	KERN_JOB_CONTROL	19	/* int: is job control available */
//#define	KERN_SAVED_IDS		20	/* int: saved set-user/group-ID */
//#define	KERN_BOOTTIME		21	/* struct: time kernel was booted */
//#define KERN_NISDOMAINNAME	22	/* string: YP domain name */
//#define KERN_UPDATEINTERVAL	23	/* int: update process sleep time */
//#define KERN_OSRELDATE		24	/* int: OS release date */
//#define KERN_NTP_PLL		25	/* node: NTP PLL control */
//#define	KERN_BOOTFILE		26	/* string: name of booted kernel */
//#define	KERN_MAXFILESPERPROC	27	/* int: max open files per proc */
//#define	KERN_MAXPROCPERUID 	28	/* int: max processes per uid */
//#define KERN_DUMPDEV		29	/* udev_t: device to dump on */
//#define	KERN_IPC		30	/* node: anything related to IPC */
//#define	KERN_DUMMY		31	/* unused */
//#define	KERN_PS_STRINGS		32	/* int: address of PS_STRINGS */
//#define	KERN_USRSTACK		33	/* int: address of USRSTACK */
//#define	KERN_LOGSIGEXIT		34	/* int: do we log sigexit procs? */
//#define	KERN_IOV_MAX		35	/* int: value of UIO_MAXIOV */
//#define KERN_MAXPOSIXLOCKSPERUID 36	/* int: max POSIX locks per uid */
//#define KERN_MAXID		37      /* number of valid kern ids */
//
//#define CTL_KERN_NAMES { \
//	{ 0, 0 }, \
//	{ "ostype", CTLTYPE_STRING }, \
//	{ "osrelease", CTLTYPE_STRING }, \
//	{ "osrevision", CTLTYPE_INT }, \
//	{ "version", CTLTYPE_STRING }, \
//	{ "maxvnodes", CTLTYPE_INT }, \
//	{ "maxproc", CTLTYPE_INT }, \
//	{ "maxfiles", CTLTYPE_INT }, \
//	{ "argmax", CTLTYPE_INT }, \
//	{ "securelevel", CTLTYPE_INT }, \
//	{ "hostname", CTLTYPE_STRING }, \
//	{ "hostid", CTLTYPE_UINT }, \
//	{ "clockrate", CTLTYPE_STRUCT }, \
//	{ "vnode", CTLTYPE_STRUCT }, \
//	{ "proc", CTLTYPE_STRUCT }, \
//	{ "file", CTLTYPE_STRUCT }, \
//	{ "profiling", CTLTYPE_NODE }, \
//	{ "posix1version", CTLTYPE_INT }, \
//	{ "ngroups", CTLTYPE_INT }, \
//	{ "job_control", CTLTYPE_INT }, \
//	{ "saved_ids", CTLTYPE_INT }, \
//	{ "boottime", CTLTYPE_STRUCT }, \
//	{ "nisdomainname", CTLTYPE_STRING }, \
//	{ "update", CTLTYPE_INT }, \
//	{ "osreldate", CTLTYPE_INT }, \
//	{ "ntp_pll", CTLTYPE_NODE }, \
//	{ "bootfile", CTLTYPE_STRING }, \
//	{ "maxfilesperproc", CTLTYPE_INT }, \
//	{ "maxprocperuid", CTLTYPE_INT }, \
//	{ "dumpdev", CTLTYPE_STRUCT }, /* we lie; don't print as int */ \
//	{ "ipc", CTLTYPE_NODE }, \
//	{ "dummy", CTLTYPE_INT }, \
//	{ "ps_strings", CTLTYPE_INT }, \
//	{ "usrstack", CTLTYPE_INT }, \
//	{ "logsigexit", CTLTYPE_INT }, \
//	{ "iov_max", CTLTYPE_INT }, \
//	{ "maxposixlocksperuid", CTLTYPE_INT }, \
//}
//
///*
// * CTL_VFS identifiers
// */
//#define CTL_VFS_NAMES { \
//	{ "vfsconf", CTLTYPE_STRUCT }, \
//}
//
///*
// * KERN_PROC subtypes
// */
//#define KERN_PROC_ALL		0	/* everything */
//#define	KERN_PROC_PID		1	/* by process id */
//#define	KERN_PROC_PGRP		2	/* by process group id */
//#define	KERN_PROC_SESSION	3	/* by session of pid */
//#define	KERN_PROC_TTY		4	/* by controlling tty */
//#define	KERN_PROC_UID		5	/* by effective uid */
//#define	KERN_PROC_RUID		6	/* by real uid */
//#define	KERN_PROC_ARGS		7	/* get/set arguments/proctitle */
//#define	KERN_PROC_CWD		8	/* get cwd */
//
//#define KERN_PROC_FLAGMASK	0x10
//#define KERN_PROC_FLAG_LWP	0x10
//
///*
// * KERN_IPC identifiers
// */
//#define KIPC_MAXSOCKBUF		1	/* int: max size of a socket buffer */
//#define	KIPC_SOCKBUF_WASTE	2	/* int: wastage factor in sockbuf */
//#define	KIPC_SOMAXCONN		3	/* int: max length of connection q */
//#define	KIPC_MAX_LINKHDR	4	/* int: max length of link header */
//#define	KIPC_MAX_PROTOHDR	5	/* int: max length of network header */
//#define	KIPC_MAX_HDR		6	/* int: max total length of headers */
//#define	KIPC_MAX_DATALEN	7	/* int: max length of data? */
//#define	KIPC_MBSTAT		8	/* struct: mbuf usage statistics */
//#define	KIPC_NMBCLUSTERS	9	/* int: maximum mbuf clusters */
//
///*
// * CTL_HW identifiers
// */
//#define	HW_MACHINE	 1		/* string: machine class */
//#define	HW_MODEL	 2		/* string: specific machine model */
//#define	HW_NCPU		 3		/* int: number of cpus */
//#define	HW_BYTEORDER	 4		/* int: machine byte order */
//#define	HW_PHYSMEM	 5		/* int: total memory */
//#define	HW_USERMEM	 6		/* int: non-kernel memory */
//#define	HW_PAGESIZE	 7		/* int: software page size */
//#define	HW_DISKNAMES	 8		/* strings: disk drive names */
//#define	HW_DISKSTATS	 9		/* struct: diskstats[] */
//#define HW_FLOATINGPT	10		/* int: has HW floating point? */
//#define HW_MACHINE_ARCH	11		/* string: machine architecture */
//#define HW_MACHINE_PLATFORM 12		/* string: platform architecture */
//#define HW_SENSORS	13		/* node: hardware sensors */
//#define HW_MAXID	14		/* number of valid hw ids */
//
//#define CTL_HW_NAMES { \
//	{ 0, 0 }, \
//	{ "machine", CTLTYPE_STRING }, \
//	{ "model", CTLTYPE_STRING }, \
//	{ "ncpu", CTLTYPE_INT }, \
//	{ "byteorder", CTLTYPE_INT }, \
//	{ "physmem", CTLTYPE_ULONG }, \
//	{ "usermem", CTLTYPE_UINT }, \
//	{ "pagesize", CTLTYPE_INT }, \
//	{ "disknames", CTLTYPE_STRUCT }, \
//	{ "diskstats", CTLTYPE_STRUCT }, \
//	{ "floatingpoint", CTLTYPE_INT }, \
//	{ "arch", CTLTYPE_STRING }, \
//	{ "platform", CTLTYPE_STRING }, \
//	{ "sensors", CTLTYPE_NODE }, \
//}
//
///*
// * CTL_USER definitions
// */
//#define	USER_CS_PATH		 1	/* string: _CS_PATH */
//#define	USER_BC_BASE_MAX	 2	/* int: BC_BASE_MAX */
//#define	USER_BC_DIM_MAX		 3	/* int: BC_DIM_MAX */
//#define	USER_BC_SCALE_MAX	 4	/* int: BC_SCALE_MAX */
//#define	USER_BC_STRING_MAX	 5	/* int: BC_STRING_MAX */
//#define	USER_COLL_WEIGHTS_MAX	 6	/* int: COLL_WEIGHTS_MAX */
//#define	USER_EXPR_NEST_MAX	 7	/* int: EXPR_NEST_MAX */
//#define	USER_LINE_MAX		 8	/* int: LINE_MAX */
//#define	USER_RE_DUP_MAX		 9	/* int: RE_DUP_MAX */
//#define	USER_POSIX2_VERSION	10	/* int: POSIX2_VERSION */
//#define	USER_POSIX2_C_BIND	11	/* int: POSIX2_C_BIND */
//#define	USER_POSIX2_C_DEV	12	/* int: POSIX2_C_DEV */
//#define	USER_POSIX2_CHAR_TERM	13	/* int: POSIX2_CHAR_TERM */
//#define	USER_POSIX2_FORT_DEV	14	/* int: POSIX2_FORT_DEV */
//#define	USER_POSIX2_FORT_RUN	15	/* int: POSIX2_FORT_RUN */
//#define	USER_POSIX2_LOCALEDEF	16	/* int: POSIX2_LOCALEDEF */
//#define	USER_POSIX2_SW_DEV	17	/* int: POSIX2_SW_DEV */
//#define	USER_POSIX2_UPE		18	/* int: POSIX2_UPE */
//#define	USER_STREAM_MAX		19	/* int: POSIX2_STREAM_MAX */
//#define	USER_TZNAME_MAX		20	/* int: POSIX2_TZNAME_MAX */
//#define	USER_MAXID		21	/* number of valid user ids */
//
//#define	CTL_USER_NAMES { \
//	{ 0, 0 }, \
//	{ "cs_path", CTLTYPE_STRING }, \
//	{ "bc_base_max", CTLTYPE_INT }, \
//	{ "bc_dim_max", CTLTYPE_INT }, \
//	{ "bc_scale_max", CTLTYPE_INT }, \
//	{ "bc_string_max", CTLTYPE_INT }, \
//	{ "coll_weights_max", CTLTYPE_INT }, \
//	{ "expr_nest_max", CTLTYPE_INT }, \
//	{ "line_max", CTLTYPE_INT }, \
//	{ "re_dup_max", CTLTYPE_INT }, \
//	{ "posix2_version", CTLTYPE_INT }, \
//	{ "posix2_c_bind", CTLTYPE_INT }, \
//	{ "posix2_c_dev", CTLTYPE_INT }, \
//	{ "posix2_char_term", CTLTYPE_INT }, \
//	{ "posix2_fort_dev", CTLTYPE_INT }, \
//	{ "posix2_fort_run", CTLTYPE_INT }, \
//	{ "posix2_localedef", CTLTYPE_INT }, \
//	{ "posix2_sw_dev", CTLTYPE_INT }, \
//	{ "posix2_upe", CTLTYPE_INT }, \
//	{ "stream_max", CTLTYPE_INT }, \
//	{ "tzname_max", CTLTYPE_INT }, \
//}
//
//#define CTL_P1003_1B_ASYNCHRONOUS_IO		1	/* boolean */
//#define CTL_P1003_1B_MAPPED_FILES		2	/* boolean */
//#define CTL_P1003_1B_MEMLOCK			3	/* boolean */
//#define CTL_P1003_1B_MEMLOCK_RANGE		4	/* boolean */
//#define CTL_P1003_1B_MEMORY_PROTECTION		5	/* boolean */
//#define CTL_P1003_1B_MESSAGE_PASSING		6	/* boolean */
//#define CTL_P1003_1B_PRIORITIZED_IO		7	/* boolean */
//#define CTL_P1003_1B_PRIORITY_SCHEDULING	8	/* boolean */
//#define CTL_P1003_1B_REALTIME_SIGNALS		9	/* boolean */
//#define CTL_P1003_1B_SEMAPHORES			10	/* boolean */
//#define CTL_P1003_1B_FSYNC			11	/* boolean */
//#define CTL_P1003_1B_SHARED_MEMORY_OBJECTS	12	/* boolean */
//#define CTL_P1003_1B_SYNCHRONIZED_IO		13	/* boolean */
//#define CTL_P1003_1B_TIMERS			14	/* boolean */
//#define CTL_P1003_1B_AIO_LISTIO_MAX		15	/* int */
//#define CTL_P1003_1B_AIO_MAX			16	/* int */
//#define CTL_P1003_1B_AIO_PRIO_DELTA_MAX		17	/* int */
//#define CTL_P1003_1B_DELAYTIMER_MAX		18	/* int */
//#define CTL_P1003_1B_UNUSED1			19	/* int */
//#define CTL_P1003_1B_PAGESIZE			20	/* int */
//#define CTL_P1003_1B_RTSIG_MAX			21	/* int */
//#define CTL_P1003_1B_SEM_NSEMS_MAX		22	/* int */
//#define CTL_P1003_1B_SEM_VALUE_MAX		23	/* int */
//#define CTL_P1003_1B_SIGQUEUE_MAX		24	/* int */
//#define CTL_P1003_1B_TIMER_MAX			25	/* int */
//
//#define CTL_P1003_1B_MAXID		26
//
//#define	CTL_P1003_1B_NAMES { \
//	{ 0, 0 }, \
//	{ "asynchronous_io", CTLTYPE_INT }, \
//	{ "mapped_files", CTLTYPE_INT }, \
//	{ "memlock", CTLTYPE_INT }, \
//	{ "memlock_range", CTLTYPE_INT }, \
//	{ "memory_protection", CTLTYPE_INT }, \
//	{ "message_passing", CTLTYPE_INT }, \
//	{ "prioritized_io", CTLTYPE_INT }, \
//	{ "priority_scheduling", CTLTYPE_INT }, \
//	{ "realtime_signals", CTLTYPE_INT }, \
//	{ "semaphores", CTLTYPE_INT }, \
//	{ "fsync", CTLTYPE_INT }, \
//	{ "shared_memory_objects", CTLTYPE_INT }, \
//	{ "synchronized_io", CTLTYPE_INT }, \
//	{ "timers", CTLTYPE_INT }, \
//	{ "aio_listio_max", CTLTYPE_INT }, \
//	{ "aio_max", CTLTYPE_INT }, \
//	{ "aio_prio_delta_max", CTLTYPE_INT }, \
//	{ "delaytimer_max", CTLTYPE_INT }, \
//	{ "unused1", CTLTYPE_INT }, \
//	{ "pagesize", CTLTYPE_INT }, \
//	{ "rtsig_max", CTLTYPE_INT }, \
//	{ "nsems_max", CTLTYPE_INT }, \
//	{ "sem_value_max", CTLTYPE_INT }, \
//	{ "sigqueue_max", CTLTYPE_INT }, \
//	{ "timer_max", CTLTYPE_INT }, \
//}
//
//#ifdef _KERNEL
//
///*
// * Declare some common oids.
// */
//extern struct sysctl_oid_list sysctl__children;
//SYSCTL_DECL(_kern);
//SYSCTL_DECL(_sysctl);
//SYSCTL_DECL(_vm);
//SYSCTL_DECL(_vfs);
//SYSCTL_DECL(_net);
//SYSCTL_DECL(_debug);
//SYSCTL_DECL(_debug_sizeof);
//SYSCTL_DECL(_hw);
//SYSCTL_DECL(_hw_bus);
//SYSCTL_DECL(_machdep);
//SYSCTL_DECL(_user);
//SYSCTL_DECL(_compat);
//SYSCTL_DECL(_lwkt);
//SYSCTL_DECL(_security);
//SYSCTL_DECL(_dsched);
//
///*
// * Common second-level oids.
// */
//SYSCTL_DECL(_kern_ipc);
//
//extern char	machine[];
//extern char	osrelease[];
//extern char	ostype[];
//extern char	kern_ident[];
//
///* Dynamic oid handling */
//struct sysctl_oid *sysctl_add_oid(struct sysctl_ctx_list *clist,
//		struct sysctl_oid_list *parent, int nbr, const char *name,
//		int kind, void *arg1, int arg2,
//		int (*handler) (SYSCTL_HANDLER_ARGS),
//		const char *fmt, const char *descr);
//int	sysctl_remove_oid(struct sysctl_oid *oidp, int del, int recurse);
//int	sysctl_ctx_init(struct sysctl_ctx_list *clist);
//int	sysctl_ctx_free(struct sysctl_ctx_list *clist);
//struct	sysctl_ctx_entry *sysctl_ctx_entry_add(struct sysctl_ctx_list *clist,
//		struct sysctl_oid *oidp);
//struct	sysctl_ctx_entry *sysctl_ctx_entry_find(struct sysctl_ctx_list *clist,
//		struct sysctl_oid *oidp);
//int	sysctl_ctx_entry_del(struct sysctl_ctx_list *clist,
//		struct sysctl_oid *oidp);
//
//int	kernel_sysctl(int *name, u_int namelen, void *old,
//		      size_t *oldlenp, void *new, size_t newlen,
//		      size_t *retval);
//int	kernel_sysctlbyname(char *name,
//		void *old, size_t *oldlenp, void *new, size_t newlen,
//		size_t *retval);
//int	userland_sysctl(int *name, u_int namelen, void *old,
//			size_t *oldlenp, int inkernel, void *new, size_t newlen,
//			size_t *retval);
//int	sysctl_find_oid(int *name, u_int namelen, struct sysctl_oid **noid,
//			int *nindx, struct sysctl_req *req);
//
//int	sysctl_int_range(SYSCTL_HANDLER_ARGS, int low, int high);
//
//#endif	/* _KERNEL */
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//
//#include <sys/cdefs.h>
//
//__BEGIN_DECLS
//int	sysctl (int *, u_int, void *, size_t *, void *, size_t);
//int	sysctlbyname (const char *, void *, size_t *, void *, size_t);
//int	sysctlnametomib (const char *, int *, size_t *);
//__END_DECLS
//
//#endif	/* _KERNEL && _KERNEL_VIRTUAL */
//
//#endif	/* !_SYS_SYSCTL_H_ */




	// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/fcntl.h
/*
 * File status flags: these are used by open(2), fcntl(2).
 * They are also used (indirectly) in the kernel file structure f_flags,
 * which is a superset of the open/fcntl flags.  Open flags and f_flags
 * are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
 * Open/fcntl flags begin with O_; kernel-internal flags begin with F.
 */
/* open-only flags */
O_RDONLY	= 0x0000		/* open for reading only */
O_WRONLY	= 0x0001		/* open for writing only */
O_RDWR		= 0x0002		/* open for reading and writing */
O_ACCMODE	= 0x0003		/* mask for above modes */

///*
// * Kernel encoding of open mode; separate read and write bits that are
// * independently testable: 1 greater than the above.
// *
// * XXX
// * FREAD and FWRITE are excluded from the #ifdef _KERNEL so that TIOCFLUSH,
// * which was documented to use FREAD/FWRITE, continues to work.
// */
//#ifndef _POSIX_SOURCE
	FREAD		= 0x0001
	FWRITE		= 0x0002
//#endif
	O_NONBLOCK	= 0x0004		/* no delay */
	O_APPEND	= 0x0008		/* set append mode */
//#ifndef _POSIX_SOURCE
	O_SHLOCK	= 0x0010		/* open with shared file lock */
	O_EXLOCK	= 0x0020		/* open with exclusive file lock */
	O_ASYNC		= 0x0040		/* signal pgrp when data ready */
	O_FSYNC		= 0x0080		/* synchronous writes */
	O_NOFOLLOW	= 0x0100		/* don't follow symlinks */
//#endif
	O_SYNC		= 0x0080		/* Same as O_FSYNC, but POSIX */
	O_CREAT		= 0x0200		/* create if nonexistent */
	O_TRUNC		= 0x0400		/* truncate to zero length */
	O_EXCL		= 0x0800		/* error if already exists */
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
	FMARK		= 0x1000		/* mark during gc() */
	FDEFER		= 0x2000		/* defer for next gc pass */
	FHASLOCK	= 0x4000		/* descriptor holds advisory lock */
//#endif
//
///* Defined by POSIX 1003.1; BSD default, but must be distinct from O_RDONLY. */
	O_NOCTTY	= 0x8000		/* don't assign controlling terminal */
//
///* Attempt to bypass the buffer cache */
	O_DIRECT	= 0x00010000
//
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
	O_CLOEXEC	= 0x00020000	/* atomically set FD_CLOEXEC */
//#endif
	O_FBLOCKING	= 0x00040000	/* force blocking I/O */
	O_FNONBLOCKING	= 0x00080000	/* force non-blocking I/O */
	O_FAPPEND	= 0x00100000	/* force append mode for write */
	O_FOFFSET	= 0x00200000	/* force specific offset */
	O_FSYNCWRITE	= 0x00400000	/* force synchronous write */
	O_FASYNCWRITE	= 0x00800000	/* force asynchronous write */
	O_FUNBUFFERED	= 0x01000000	/* force unbuffered (direct) I/O */
	O_FBUFFERED	= 0x02000000	/* force buffered I/O */
	O_MAPONREAD	= 0x04000000	/* memory map read buffer */
//
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
//#define O_DIRECTORY	= 0x08000000	/* error if not a directory */
//#endif
//
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
	FREVOKED	= 0x10000000	/* revoked by fdrevoke() */
	FAPPENDONLY	= 0x20000000	/* O_APPEND cannot be changed */
	FOFFSETLOCK	= 0x40000000	/* f_offset locked */
	FOFFSETWAKE	= 0x80000000	/* f_offset wakeup */
//#endif
//
//#define O_FMASK		(O_FBLOCKING|O_FNONBLOCKING|O_FAPPEND|O_FOFFSET|\
//			 O_FSYNCWRITE|O_FASYNCWRITE|O_FUNBUFFERED|O_FBUFFERED|\
//			 O_MAPONREAD)
//
//#ifdef _KERNEL
///* convert from open() flags to/from fflags; convert O_RD/WR to FREAD/FWRITE */
//#define	= FFLAGS(oflags)	((oflags) + 1)
//#define	= OFLAGS(fflags)	((fflags) - 1)
//
///* bits to save after open */
//#define	FMASK		= (FREAD|FWRITE|FAPPEND|FASYNC|FFSYNC|FNONBLOCK|\
//			 FAPPENDONLY|FREVOKED|O_DIRECT|O_MAPONREAD)
///* bits settable by fcntl(F_SETFL, ...) */
//#define	FCNTLFLAGS	= (FAPPEND|FASYNC|FFSYNC|FNONBLOCK|FPOSIXSHM|\
//			 O_DIRECT|O_MAPONREAD)
//#endif
//
///*
// * The O_* flags used to have only F* names, which were used in the kernel
// * and by fcntl.  We retain the F* names for the kernel f_flag field
// * and for backward compatibility for fcntl.
// */
//#ifndef _POSIX_SOURCE
	FAPPEND		= O_APPEND	/* kernel/compat */
	FASYNC		= O_ASYNC		/* kernel/compat */
	FFSYNC		= O_FSYNC		/* kernel */
	FNONBLOCK	= O_NONBLOCK	/* kernel */
	FNDELAY		= O_NONBLOCK	/* compat */
	O_NDELAY	= O_NONBLOCK	/* compat */
//#endif
//
///*
// * We are out of bits in f_flag (which is a short).  However,
// * the flag bits not set in FMASK are only meaningful in the
// * initial open syscall.  Those bits can thus be given a
// * different meaning for fcntl(2).
// */
//#ifndef _POSIX_SOURCE
//
///*
// * Set by shm_open(3) to get automatic MAP_ASYNC behavior
// * for POSIX shared memory objects (which are otherwise
// * implemented as plain files).
// */
	FPOSIXSHM	= O_NOFOLLOW
//#endif
//
///*
// * Constants used by "at" family of system calls.
// */
	AT_FDCWD		= 0xFFFAFDCD	/* invalid file descriptor */
	AT_SYMLINK_NOFOLLOW	= 1
	AT_REMOVEDIR		= 2
	AT_EACCESS		= 4
	AT_SYMLINK_FOLLOW	= 8
//
///*
// * Constants used for fcntl(2)
// */
//
///* command values */
	F_DUPFD		= 0		/* duplicate file descriptor */
	F_GETFD		= 1		/* get file descriptor flags */
	F_SETFD		= 2		/* set file descriptor flags */
	F_GETFL		= 3		/* get file status flags */
	F_SETFL		= 4		/* set file status flags */
//#ifndef _POSIX_SOURCE
	F_GETOWN	= 5		/* get SIGIO/SIGURG proc/pgrp */
	F_SETOWN	= 6		/* set SIGIO/SIGURG proc/pgrp */
//#endif
	F_GETLK		= 7		/* get record locking information */
	F_SETLK		= 8		/* set record locking information */
	F_SETLKW	= 9		/* F_SETLK; wait if blocked */
	F_DUP2FD	= 10		/* duplicate file descriptor to arg */
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
	F_DUPFD_CLOEXEC	= 17		/* Like F_DUPFD with FD_CLOEXEC set */
//#endif
//#if __BSD_VISIBLE
	F_DUP2FD_CLOEXEC = 18		/* Like F_DUP2FD with FD_CLOEXEC set */
//#endif
//
///* file descriptor flags (F_GETFD, F_SETFD) */
	FD_CLOEXEC	= 1		/* close-on-exec flag */
//
///* record locking flags (F_GETLK, F_SETLK, F_SETLKW) */
	F_RDLCK		= 1		/* shared or read lock */
	F_UNLCK		= 2		/* unlock */
	F_WRLCK		= 3		/* exclusive or write lock */
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
	F_WAIT		= 0x010		/* Wait until lock is granted */
	F_UNUSED020	= 0x020
	F_POSIX		= 0x040	 	/* Use POSIX semantics for lock */
	F_NOEND		= 0x080		/* l_len = 0, internally used */
//#endif
//
//
///*
// * Advisory file segment locking data type -
// * information passed to system by user
// */
//struct flock {
//	off_t	l_start;	/* starting offset */
//	off_t	l_len;		/* len = 0 means until end of file */
//	pid_t	l_pid;		/* lock owner */
//	short	l_type;		/* lock type: read/write, etc. */
//	short	l_whence;	/* type of l_start */
//};
//
//#ifdef _KERNEL
//union fcntl_dat {
//	int		fc_fd;		/* F_DUPFD */
//	int		fc_cloexec;	/* F_GETFD/F_SETFD */
//	int		fc_flags;	/* F_GETFL/F_SETFL */
//	int		fc_owner;	/* F_GETOWN/F_SETOWN */
//	struct flock	fc_flock;	/* F_GETLK/F_SETLK */
//};
//#endif /* _KERNEL */
//
//
//#ifndef _POSIX_SOURCE
///* lock operations for flock(2) */
	LOCK_SH		= 0x01		/* shared file lock */
	LOCK_EX		= 0x02		/* exclusive file lock */
	LOCK_NB		= 0x04		/* don't block when locking */
	LOCK_UN		= 0x08		/* unlock file */
//#endif
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//#include <sys/cdefs.h>
//
//__BEGIN_DECLS
//int	open (const char *, int, ...);
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
//int	openat (int, const char *, int, ...);
//#endif
//int	creat (const char *, mode_t);
//int	fcntl (int, int, ...);
//#ifndef _POSIX_SOURCE
//int	flock (int, int);
//#endif /* !_POSIX_SOURCE */
//__END_DECLS
//#endif
//
//#endif /* !_SYS_FCNTL_H_ */


)


// Errors
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/errno.h
const (
	EPERM		= Errno(1)		/* Operation not permitted */
	ENOENT		= Errno(2)		/* No such file or directory */
	ESRCH		= Errno(3)		/* No such process */
	EINTR		= Errno(4)		/* Interrupted system call */
	EIO		= Errno(5)		/* Input/output error */
	ENXIO		= Errno(6)		/* Device not configured */
	E2BIG		= Errno(7)		/* Argument list too long */
	ENOEXEC		= Errno(8)		/* Exec format error */
	EBADF		= Errno(9)		/* Bad file descriptor */
	ECHILD		= Errno(10)		/* No child processes */
	EDEADLK		= Errno(11)		/* Resource deadlock avoided */
						/* 11 was EAGAIN */
	ENOMEM		= Errno(12)		/* Cannot allocate memory */
	EACCES		= Errno(13)		/* Permission denied */
	EFAULT		= Errno(14)		/* Bad address */
	EBUSY		= Errno(16)		/* Device busy */
	EEXIST		= Errno(17)		/* File exists */
	EXDEV		= Errno(18)		/* Cross-device link */
	ENODEV		= Errno(19)		/* Operation not supported by device */
	ENOTDIR		= Errno(20)		/* Not a directory */
	EISDIR		= Errno(21)		/* Is a directory */
	EINVAL		= Errno(22)		/* Invalid argument */
	ENFILE		= Errno(23)		/* Too many open files in system */
	EMFILE		= Errno(24)		/* Too many open files */
	ENOTTY		= Errno(25)		/* Inappropriate ioctl for device */
	EFBIG		= Errno(27)		/* File too large */
	ENOSPC		= Errno(28)		/* No space left on device */
	ESPIPE		= Errno(29)		/* Illegal seek */
	EROFS		= Errno(30)		/* Read-only filesystem */
	EMLINK		= Errno(31)		/* Too many links */
	EPIPE		= Errno(32)		/* Broken pipe */

	/* math software */
	EDOM		= Errno(33)		/* Numerical argument out of domain */
	ERANGE		= Errno(34)		/* Result too large */

	/* non-blocking and interrupt i/o */
	EAGAIN		= Errno(35)		/* Resource temporarily unavailable */
	EWOULDBLOCK	= Errno(EAGAIN)		/* Operation would block */
	EINPROGRESS	= Errno(36)		/* Operation now in progress */
	EALREADY	= Errno(37)		/* Operation already in progress */

	/* ipc/network software -- argument errors */
	ENOTSOCK	= Errno(38)		/* Socket operation on non-socket */
	EDESTADDRREQ	= Errno(39)		/* Destination address required */
	EMSGSIZE	= Errno(40)		/* Message too long */
	EPROTOTYPE	= Errno(41)		/* Protocol wrong type for socket */
	ENOPROTOOPT	= Errno(42)		/* Protocol not available */
	EPROTONOSUPPORT	= Errno(43)		/* Protocol not supported */
	ESOCKTNOSUPPORT	= Errno(44)		/* Socket type not supported */
	EOPNOTSUPP	= Errno(45)		/* Operation not supported */
	ENOTSUP		= Errno(EOPNOTSUPP)	/* Operation not supported */
	EPFNOSUPPORT	= Errno(46)		/* Protocol family not supported */
	EAFNOSUPPORT	= Errno(47)		/* Address family not supported by protocol family */
	EADDRINUSE	= Errno(48)		/* Address already in use */
	EADDRNOTAVAIL	= Errno(49)		/* Can't assign requested address */

	/* ipc/network software -- operational errors */
	ENETDOWN	= Errno(50)		/* Network is down */
	ENETUNREACH	= Errno(51)		/* Network is unreachable */
	ENETRESET	= Errno(52)		/* Network dropped connection on reset */
	ECONNABORTED	= Errno(53)		/* Software caused connection abort */
	ECONNRESET	= Errno(54)		/* Connection reset by peer */
	ENOBUFS		= Errno(55)		/* No buffer space available */
	EISCONN		= Errno(56)		/* Socket is already connected */
	ENOTCONN	= Errno(57)		/* Socket is not connected */
	ESHUTDOWN	= Errno(58)		/* Can't send after socket shutdown */
	ETOOMANYREFS	= Errno(59)		/* Too many references: can't splice */
	ETIMEDOUT	= Errno(60)		/* Operation timed out */
	ECONNREFUSED	= Errno(61)		/* Connection refused */

	ELOOP		= Errno(62)		/* Too many levels of symbolic links */
	ENAMETOOLONG	= Errno(63)		/* File name too long */

	/* should be rearranged */
	ENOTEMPTY	= Errno(66)		/* Directory not empty */

	/* quotas & mush */

	ENOLCK		= Errno(77)		/* No locks available */
	ENOSYS		= Errno(78)		/* Function not implemented */

	EBADMSG		= Errno(89)		/* Bad message */
	EMULTIHOP	= Errno(90)		/* Multihop attempted */
	ENOLINK		= Errno(91)		/* Link has been severed */
	EPROTO		= Errno(92)		/* Protocol error */
)

// Signals
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/signal.h
const (
	SIGHUP		= Signal(1)	/* hangup */
	SIGINT		= Signal(2)	/* interrupt */
	SIGQUIT		= Signal(3)	/* quit */
	SIGILL		= Signal(4)	/* illegal instr. (not reset when caught) */
	SIGTRAP		= Signal(5)	/* trace trap (not reset when caught) */
	SIGABRT		= Signal(6)	/* abort() */
	SIGIOT		= Signal(SIGABRT)	/* compatibility */
	SIGEMT		= Signal(7)	/* EMT instruction */
	SIGFPE		= Signal(8)	/* floating point exception */
	SIGKILL		= Signal(9)	/* kill (cannot be caught or ignored) */
	SIGBUS		= Signal(10)	/* bus error */
	SIGSEGV		= Signal(11)	/* segmentation violation */
	SIGSYS		= Signal(12)	/* non-existent system call invoked */
	SIGPIPE		= Signal(13)	/* write on a pipe with no one to read it */
	SIGALRM		= Signal(14)	/* alarm clock */
	SIGTERM		= Signal(15)	/* software termination signal from kill */
	SIGURG		= Signal(16)	/* urgent condition on IO channel */
	SIGSTOP		= Signal(17)	/* sendable stop signal not from tty */
	SIGTSTP		= Signal(18)	/* stop signal from tty */
	SIGCONT		= Signal(19)	/* continue a stopped process */
	SIGCHLD		= Signal(20)	/* to parent on child stop or exit */
	SIGTTIN		= Signal(21)	/* to readers pgrp upon background tty read */
	SIGTTOU		= Signal(22)	/* like TTIN if (tp->t_local&LTOSTOP) */
	SIGIO		= Signal(23)	/* input/output possible signal */
	SIGXCPU		= Signal(24)	/* exceeded CPU time limit */
	SIGXFSZ		= Signal(25)	/* exceeded file size limit */
	SIGVTALRM	= Signal(26)	/* virtual time alarm */
	SIGPROF		= Signal(27)	/* profiling time alarm */
	SIGWINCH	= Signal(28)	/* window size changes */
	SIGINFO		= Signal(29)	/* information request */
	SIGUSR1		= Signal(30)	/* user defined signal 1 */
	SIGUSR2		= Signal(31)	/* user defined signal 2 */
	SIGTHR          = Signal(32)      /* Thread interrupt (FreeBSD-5 reserved) */
	SIGCKPT         = Signal(33)      /* checkpoint and continue */
	SIGCKPTEXIT     = Signal(34)      /* checkpoint and exit */
)

// Error table
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/errno.h
var errors = [...]string{
	1: "Operation not permitted",
	2: "No such file or directory",
	3: "No such process",
	4: "Interrupted system call",
	5: "Input/output error",
	6: "Device not configured",
	7: "Argument list too long",
	8: "Exec format error",
	9: "Bad file descriptor",
	10: "No child processes",
	11: "Resource deadlock avoided",
	12: "Cannot allocate memory",
	13: "Permission denied",
	14: "Bad address",
	16: "Device busy",
	17: "File exists",
	18: "Cross-device link",
	19: "Operation not supported by device",
	20: "Not a directory",
	21: "Is a directory",
	22: "Invalid argument",
	23: "Too many open files in system",
	24: "Too many open files",
	25: "Inappropriate ioctl for device",
	27: "File too large",
	28: "No space left on device",
	29: "Illegal seek",
	30: "Read-only filesystem",
	31: "Too many links",
	32: "Broken pipe",

	/* math software */
	33: "Numerical argument out of domain",
	34: "Result too large",

	/* non-blocking and interrupt i/o */
	35: "Resource temporarily unavailable",
	63: "File name too long",

	/* should be rearranged */
	66: "Directory not empty",

	/* quotas & mush */

	77: "No locks available",
	78: "Function not implemented",

	89: "Bad message",
	90: "Multihop attempted",
	91: "Link has been severed",
	92: "Protocol error",
}

// Signal table
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/lib/libc/gen/siglist.c
var signals = [...]string{
	SIGHUP:		"Hangup",
	SIGINT:		"Interrupt",
	SIGQUIT:	"Quit",
	SIGILL:		"Illegal instruction",
	SIGTRAP:	"Trace/BPT trap",
	SIGABRT:	"Abort trap",
	SIGEMT:		"EMT trap",
	SIGFPE:		"Floating point exception",
	SIGKILL:	"Killed",
	SIGBUS:		"Bus error",
	SIGSEGV:	"Segmentation fault",
	SIGSYS:		"Bad system call",
	SIGPIPE:	"Broken pipe",
	SIGALRM:	"Alarm clock",
	SIGTERM:	"Terminated",
	SIGURG:		"Urgent I/O condition",
	SIGSTOP:	"Suspended (signal)",
	SIGTSTP:	"Suspended",
	SIGCONT:	"Continued",
	SIGCHLD:	"Child exited",
	SIGTTIN:	"Stopped (tty input)",
	SIGTTOU:	"Stopped (tty output)",
	SIGIO:		"I/O possible",
	SIGXCPU:	"Cputime limit exceeded",
	SIGXFSZ:	"Filesize limit exceeded",
	SIGVTALRM:	"Virtual timer expired",
	SIGPROF:	"Profiling timer expired",
	SIGWINCH:	"Window size changes",
	SIGINFO:	"Information request",
	SIGUSR1:	"User defined signal 1",
	SIGUSR2:	"User defined signal 2",
}
