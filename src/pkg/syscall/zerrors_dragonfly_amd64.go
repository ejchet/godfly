// mkerrors.sh -m64
// NOT MACHINE GENERATED BY THE COMMAND ABOVE; DO EDIT

// Not Created by cgo -godefs - DO EDIT
// cgo -godefs -- -m64 _const.go

package syscall




const (
	// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/socket.h
	AF_UNSPEC	= 0		/* unspecified */
	AF_LOCAL	= 1		/* local to host (pipes, portals) */
	AF_UNIX		= AF_LOCAL	/* backward compatibility */
	AF_INET		= 2		/* internetwork: UDP, TCP, etc. */
	AF_IMPLINK	= 3		/* arpanet imp addresses */
	AF_PUP		= 4		/* pup protocols: e.g. BSP */
	AF_CHAOS	= 5		/* mit CHAOS protocols */
	AF_NS		= 6		/* XEROX NS protocols */
	AF_ISO		= 7		/* ISO protocols */
	AF_OSI		= AF_ISO
	AF_ECMA		= 8		/* European computer manufacturers */
	AF_DATAKIT	= 9		/* datakit protocols */
	AF_CCITT	= 10		/* CCITT protocols, X.25 etc */
	AF_SNA		= 11		/* IBM SNA */
	AF_DECnet	= 12		/* DECnet */
	AF_DLI		= 13		/* DEC Direct data link interface */
	AF_LAT		= 14		/* LAT */
	AF_HYLINK	= 15		/* NSC Hyperchannel */
	AF_APPLETALK	= 16		/* Apple Talk */
	AF_ROUTE	= 17		/* Internal Routing Protocol */
	AF_LINK		= 18		/* Link layer interface */
	pseudo_AF_XTP	= 19		/* eXpress Transfer Protocol (no AF) */
	AF_COIP		= 20		/* connection-oriented IP, aka ST II */
	AF_CNT		= 21		/* Computer Network Technology */
	pseudo_AF_RTIP	= 22		/* Help Identify RTIP packets */
	AF_IPX		= 23		/* Novell Internet Protocol */
	AF_SIP		= 24		/* Simple Internet Protocol */
	pseudo_AF_PIP	= 25		/* Help Identify PIP packets */
	AF_ISDN		= 26		/* Integrated Services Digital Network*/
	AF_E164		= AF_ISDN		/* CCITT E.164 recommendation */
	pseudo_AF_KEY	= 27		/* Internal key-management function */
	AF_INET6	= 28		/* IPv6 */
	AF_NATM		= 29		/* native ATM access */
	AF_ATM		= 30		/* ATM */
	pseudo_AF_HDRCMPLT = 31		/* Used by BPF to not rewrite headers
					 * in interface output routine
					 */
	AF_NETGRAPH	= 32		/* Netgraph sockets */
	AF_BLUETOOTH	= 33		/* Bluetooth */
	AF_MPLS		= 34		/* Multi-Protocol Label Switching */
	AF_IEEE80211	= 35		/* IEEE 802.11 protocol */
	AF_MAX		= 36
	// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/sysctl.h

//#ifndef _SYS_SYSCTL_H_
//#define	_SYS_SYSCTL_H_
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#ifndef _SYS__POSIX_H_
//#include <sys/_posix.h>
//#endif
//#ifndef _SYS_QUEUE_H_
//#include <sys/queue.h>
//#endif
//
///*
// * Definitions for sysctl call.  The sysctl call uses a hierarchical name
// * for objects that can be examined or modified.  The name is expressed as
// * a sequence of integers.  Like a file path name, the meaning of each
// * component depends on its place in the hierarchy.  The top-level and kern
// * identifiers are defined here, and other identifiers are defined in the
// * respective subsystem header files.
// */
//
	CTL_MAXNAME	= 12		/* largest number of components supported */
//
///*
// * Each subsystem defined by sysctl defines a list of variables
// * for that subsystem. Each name is either a node with further
// * levels defined below it, or it is a leaf of some particular
// * type given below. Each sysctl level defines a set of name/type
// * pairs to be used by sysctl(1) in manipulating the subsystem.
// */
//struct ctlname {
//	char	*ctl_name;	/* subsystem name */
//	int	ctl_type;	/* type of name */
//};
//

	CTLTYPE		= 0xf	/* Mask for the type */
	CTLTYPE_NODE	= 1	/* name is a node */
	CTLTYPE_INT	= 2	/* name describes an integer */
	CTLTYPE_STRING	= 3	/* name describes a string */
	CTLTYPE_QUAD	= 4	/* name describes a 64-bit number */
	CTLTYPE_OPAQUE	= 5	/* name describes a structure */
	CTLTYPE_STRUCT	= CTLTYPE_OPAQUE	/* name describes a structure */
	CTLTYPE_UINT	= 6	/* name describes an unsigned integer */
	CTLTYPE_LONG	= 7	/* name describes a long */
	CTLTYPE_ULONG	= 8	/* name describes an unsigned long */
	CTLTYPE_UQUAD	= 9	/* name describes an unsigned 64-bit number */
	CTLFLAG_RD	= 0x80000000	/* Allow reads of variable */
	CTLFLAG_WR	= 0x40000000	/* Allow writes to the variable */
	CTLFLAG_RW	= CTLFLAG_RD | CTLFLAG_WR
	CTLFLAG_ANYBODY	= 0x10000000	/* All users can set this var */
	CTLFLAG_SECURE	= 0x08000000	/* Permit set only if securelevel<=0 */
	CTLFLAG_PRISON	= 0x04000000	/* Prisoned roots can fiddle */
	CTLFLAG_DYN	= 0x02000000	/* Dynamic oid - can be freed */

//
//
///*
// * USE THIS instead of a hardwired number from the categories below
// * to get dynamically assigned sysctl entries using the linker-set
// * technology. This is the way nearly all new sysctl variables should
// * be implemented.
// * e.g. SYSCTL_INT(_parent, OID_AUTO, name, CTLFLAG_RW, &variable, 0, "");
// */ 
//#define OID_AUTO	(-1)
//
//#ifdef _KERNEL
//
//#include <sys/kernel.h>			/* for DATA_SET */
//
//#define SYSCTL_HANDLER_ARGS struct sysctl_oid *oidp, void *arg1, int arg2, \
//	struct sysctl_req *req
//
///*
// * This describes the access space for a sysctl request.  This is needed
// * so that we can use the interface from the kernel or from user-space.
// */
//struct sysctl_req {
//	struct thread	*td;
//	int		unused01;	/* was lock */
//	void		*oldptr;
//	size_t		oldlen;
//	size_t		oldidx;
//	int		(*oldfunc)(struct sysctl_req *, const void *, size_t);
//	void		*newptr;
//	size_t		newlen;
//	size_t		newidx;
//	int		(*newfunc)(struct sysctl_req *, void *, size_t);
//};
//
//SLIST_HEAD(sysctl_oid_list, sysctl_oid);
//
///*
// * This describes one "oid" in the MIB tree.  Potentially more nodes can
// * be hidden behind it, expanded by the handler.
// */
//struct sysctl_oid {
//	struct sysctl_oid_list *oid_parent;
//	SLIST_ENTRY(sysctl_oid) oid_link;
//	int		oid_number;
//	int		oid_kind;
//	void		*oid_arg1;
//	int		oid_arg2;
//	const char	*oid_name;
//	int 		(*oid_handler)(SYSCTL_HANDLER_ARGS);
//	const char	*oid_fmt;
//	int		oid_refcnt;
//	const char	*oid_descr;
//};
//
//#define SYSCTL_IN(r, p, l) (r->newfunc)(r, p, l)
//#define SYSCTL_OUT(r, p, l) (r->oldfunc)(r, p, l)
//
//int sysctl_handle_int(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_long(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_quad(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_intptr(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_string(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_opaque(SYSCTL_HANDLER_ARGS);
//
///*
// * These functions are used to add/remove an oid from the mib.
// */
//void sysctl_register_oid(struct sysctl_oid *oidp);
//void sysctl_unregister_oid(struct sysctl_oid *oidp);
//
///* Declare a static oid to allow child oids to be added to it. */
//#define SYSCTL_DECL(name)					\
//	extern struct sysctl_oid_list sysctl_##name##_children
//
///* Hide these in macros */
//#define	SYSCTL_SET_CHILDREN(oid_ptr, children) do {			\
//	(oid_ptr)->oid_arg1 = (children);				\
//} while(0)
//#define	SYSCTL_CHILDREN(oid_ptr) (struct sysctl_oid_list *) \
//	(oid_ptr)->oid_arg1
//#define	SYSCTL_STATIC_CHILDREN(oid_name) \
//	(&sysctl_##oid_name##_children)
//
///* === Structs and macros related to context handling === */
//
///* All dynamically created sysctls can be tracked in a context list. */
//struct sysctl_ctx_entry {
//	struct sysctl_oid *entry;
//	TAILQ_ENTRY(sysctl_ctx_entry) link;
//};
//
//TAILQ_HEAD(sysctl_ctx_list, sysctl_ctx_entry);
//
//#define	SYSCTL_NODE_CHILDREN(parent, name) \
//	sysctl_##parent##_##name##_children
//
///* This constructs a "raw" MIB oid. */
//#define SYSCTL_OID(parent, nbr, name, kind, a1, a2, handler, fmt, descr) \
//	static struct sysctl_oid sysctl__##parent##_##name = {		 \
//		&sysctl_##parent##_children, { 0 },			 \
//		nbr, kind, a1, a2, #name, handler, fmt, 0, descr };		 \
//	DATA_SET(sysctl_set, sysctl__##parent##_##name);
//
//#define SYSCTL_ADD_OID(ctx, parent, nbr, name, kind, a1, a2, handler, fmt, descr) \
//	sysctl_add_oid(ctx, parent, nbr, name, kind, a1, a2, handler, fmt, descr);
//
///* This constructs a node from which other oids can hang. */
//#define SYSCTL_NODE(parent, nbr, name, access, handler, descr)		    \
//	struct sysctl_oid_list sysctl_##parent##_##name##_children;	    \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_NODE|access,		    \
//		   (void*)&sysctl_##parent##_##name##_children, 0, handler, \
//		   "N", descr);
//
//#define SYSCTL_ADD_NODE(ctx, parent, nbr, name, access, handler, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_NODE|access,	    \
//	0, 0, handler, "N", descr)
//
///* Oid for a string.  len can be 0 to indicate '\0' termination. */
//#define SYSCTL_STRING(parent, nbr, name, access, arg, len, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_STRING|access, \
//		arg, len, sysctl_handle_string, "A", descr)
//
//#define SYSCTL_ADD_STRING(ctx, parent, nbr, name, access, arg, len, descr)  \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_STRING|access,	    \
//	arg, len, sysctl_handle_string, "A", descr)
//
///* Oid for an int.  If ptr is NULL, val is returned. */
//#define SYSCTL_INT(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_INT|access, \
//		ptr, val, sysctl_handle_int, "I", descr)
//
//#define SYSCTL_ADD_INT(ctx, parent, nbr, name, access, ptr, val, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_INT|access,	    \
//	ptr, val, sysctl_handle_int, "I", descr)
//
///* Oid for a quad.  If ptr is NULL, val is returned. */
//#define SYSCTL_QUAD(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_QUAD|access, \
//		ptr, val, sysctl_handle_quad, "Q", descr)
//
//#define SYSCTL_ADD_QUAD(ctx, parent, nbr, name, access, ptr, val, descr)    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_QUAD|access,	    \
//	ptr, val, sysctl_handle_quad, "Q", descr)
//
///* Oid for an unsigned quad.  If ptr is NULL, val is returned. */
//#define SYSCTL_UQUAD(parent, nbr, name, access, ptr, val, descr)	    \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_UQUAD|access,		    \
//		ptr, val, sysctl_handle_quad, "QU", descr)
//
//#define SYSCTL_ADD_UQUAD(ctx, parent, nbr, name, access, ptr, val, descr)   \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_UQUAD|access,	    \
//	ptr, val, sysctl_handle_quad, "QU", descr)
//
///* Oid for an unsigned int.  If ptr is NULL, val is returned. */
//#define SYSCTL_UINT(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_UINT|access, \
//		ptr, val, sysctl_handle_int, "IU", descr)
//
//#define SYSCTL_ADD_UINT(ctx, parent, nbr, name, access, ptr, val, descr)    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_UINT|access,	    \
//	ptr, val, sysctl_handle_int, "IU", descr)
//
///* Oid for a long.  The pointer must be non NULL. */
//#define SYSCTL_LONG(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_LONG|access, \
//		ptr, val, sysctl_handle_long, "L", descr)
//
//#define SYSCTL_ADD_LONG(ctx, parent, nbr, name, access, ptr, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_LONG|access,	    \
//	ptr, 0, sysctl_handle_long, "L", descr)
//
///* Oid for a long.  The pointer must be non NULL. */
//#define SYSCTL_ULONG(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_ULONG|access, \
//		ptr, val, sysctl_handle_long, "LU", descr)
//
//#define SYSCTL_ADD_ULONG(ctx, parent, nbr, name, access, ptr, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_ULONG|access,	    \
//	ptr, 0, sysctl_handle_long, "LU", descr)
//
///* Oid for an opaque object.  Specified by a pointer and a length. */
//#define SYSCTL_OPAQUE(parent, nbr, name, access, ptr, len, fmt, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_OPAQUE|access, \
//		ptr, len, sysctl_handle_opaque, fmt, descr)
//
//#define SYSCTL_ADD_OPAQUE(ctx, parent, nbr, name, access, ptr, len, fmt, descr)\
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_OPAQUE|access,	    \
//	ptr, len, sysctl_handle_opaque, fmt, descr)
//
///* Oid for a struct.  Specified by a pointer and a type. */
//#define SYSCTL_STRUCT(parent, nbr, name, access, ptr, type, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_OPAQUE|access, \
//		ptr, sizeof(struct type), sysctl_handle_opaque, \
//		"S," #type, descr)
//
//#define SYSCTL_ADD_STRUCT(ctx, parent, nbr, name, access, ptr, type, descr) \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_OPAQUE|access,	    \
//	ptr, sizeof(struct type), sysctl_handle_opaque, "S," #type, descr)
//
///* Oid for a procedure.  Specified by a pointer and an arg. */
//#define SYSCTL_PROC(parent, nbr, name, access, ptr, arg, handler, fmt, descr) \
//	SYSCTL_OID(parent, nbr, name, access, \
//		ptr, arg, handler, fmt, descr)
//
//#define SYSCTL_ADD_PROC(ctx, parent, nbr, name, access, ptr, arg, handler, fmt, descr) \
//	sysctl_add_oid(ctx, parent, nbr, name, access,			    \
//	ptr, arg, handler, fmt, descr)
//
//#endif /* _KERNEL */
//
///*
// * Top-level identifiers
// */
	CTL_UNSPEC	= 0		/* unused */
	CTL_KERN	= 1		/* "high kernel": proc, limits */
	CTL_VM		= 2		/* virtual memory */
	CTL_VFS		= 3		/* file system, mount type is next */
	CTL_NET		= 4		/* network, see socket.h */
	CTL_DEBUG	= 5		/* debugging parameters */
	CTL_HW		= 6		/* generic cpu/io */
	CTL_MACHDEP	= 7		/* machine dependent */
	CTL_USER	= 8		/* user-level */
	CTL_P1003_1B	= 9		/* POSIX 1003.1B */
 CTL_LWKT	= 10		/* light weight kernel threads */
	CTL_MAXID	= 11		/* number of valid top-level ids */
//
//#define CTL_NAMES { \
//	{ 0, 0 }, \
//	{ "kern", CTLTYPE_NODE }, \
//	{ "vm", CTLTYPE_NODE }, \
//	{ "vfs", CTLTYPE_NODE }, \
//	{ "net", CTLTYPE_NODE }, \
//	{ "debug", CTLTYPE_NODE }, \
//	{ "hw", CTLTYPE_NODE }, \
//	{ "machdep", CTLTYPE_NODE }, \
//	{ "user", CTLTYPE_NODE }, \
//	{ "p1003_1b", CTLTYPE_NODE }, \
//	{ "lwkt", CTLTYPE_NODE }, \
//}
//
///*
// * CTL_KERN identifiers
// */
//#define	KERN_OSTYPE	 	 1	/* string: system version */
//#define	KERN_OSRELEASE	 	 2	/* string: system release */
//#define	KERN_OSREV	 	 3	/* int: system revision */
//#define	KERN_VERSION	 	 4	/* string: compile time info */
//#define	KERN_MAXVNODES	 	 5	/* int: max vnodes */
//#define	KERN_MAXPROC	 	 6	/* int: max processes */
//#define	KERN_MAXFILES	 	 7	/* int: max open files */
//#define	KERN_ARGMAX	 	 8	/* int: max arguments to exec */
//#define	KERN_SECURELVL	 	 9	/* int: system security level */
//#define	KERN_HOSTNAME		10	/* string: hostname */
//#define	KERN_HOSTID		11	/* int: host identifier */
//#define	KERN_CLOCKRATE		12	/* struct: struct clockrate */
//#define	KERN_VNODE		13	/* struct: vnode structures */
//#define	KERN_PROC		14	/* struct: process entries */
//#define	KERN_FILE		15	/* struct: file entries */
//#define	KERN_PROF		16	/* node: kernel profiling info */
//#define	KERN_POSIX1		17	/* int: POSIX.1 version */
//#define	KERN_NGROUPS		18	/* int: # of supplemental group ids */
//#define	KERN_JOB_CONTROL	19	/* int: is job control available */
//#define	KERN_SAVED_IDS		20	/* int: saved set-user/group-ID */
//#define	KERN_BOOTTIME		21	/* struct: time kernel was booted */
//#define KERN_NISDOMAINNAME	22	/* string: YP domain name */
//#define KERN_UPDATEINTERVAL	23	/* int: update process sleep time */
//#define KERN_OSRELDATE		24	/* int: OS release date */
//#define KERN_NTP_PLL		25	/* node: NTP PLL control */
//#define	KERN_BOOTFILE		26	/* string: name of booted kernel */
//#define	KERN_MAXFILESPERPROC	27	/* int: max open files per proc */
//#define	KERN_MAXPROCPERUID 	28	/* int: max processes per uid */
//#define KERN_DUMPDEV		29	/* udev_t: device to dump on */
//#define	KERN_IPC		30	/* node: anything related to IPC */
//#define	KERN_DUMMY		31	/* unused */
//#define	KERN_PS_STRINGS		32	/* int: address of PS_STRINGS */
//#define	KERN_USRSTACK		33	/* int: address of USRSTACK */
//#define	KERN_LOGSIGEXIT		34	/* int: do we log sigexit procs? */
//#define	KERN_IOV_MAX		35	/* int: value of UIO_MAXIOV */
//#define KERN_MAXPOSIXLOCKSPERUID 36	/* int: max POSIX locks per uid */
//#define KERN_MAXID		37      /* number of valid kern ids */
//
//#define CTL_KERN_NAMES { \
//	{ 0, 0 }, \
//	{ "ostype", CTLTYPE_STRING }, \
//	{ "osrelease", CTLTYPE_STRING }, \
//	{ "osrevision", CTLTYPE_INT }, \
//	{ "version", CTLTYPE_STRING }, \
//	{ "maxvnodes", CTLTYPE_INT }, \
//	{ "maxproc", CTLTYPE_INT }, \
//	{ "maxfiles", CTLTYPE_INT }, \
//	{ "argmax", CTLTYPE_INT }, \
//	{ "securelevel", CTLTYPE_INT }, \
//	{ "hostname", CTLTYPE_STRING }, \
//	{ "hostid", CTLTYPE_UINT }, \
//	{ "clockrate", CTLTYPE_STRUCT }, \
//	{ "vnode", CTLTYPE_STRUCT }, \
//	{ "proc", CTLTYPE_STRUCT }, \
//	{ "file", CTLTYPE_STRUCT }, \
//	{ "profiling", CTLTYPE_NODE }, \
//	{ "posix1version", CTLTYPE_INT }, \
//	{ "ngroups", CTLTYPE_INT }, \
//	{ "job_control", CTLTYPE_INT }, \
//	{ "saved_ids", CTLTYPE_INT }, \
//	{ "boottime", CTLTYPE_STRUCT }, \
//	{ "nisdomainname", CTLTYPE_STRING }, \
//	{ "update", CTLTYPE_INT }, \
//	{ "osreldate", CTLTYPE_INT }, \
//	{ "ntp_pll", CTLTYPE_NODE }, \
//	{ "bootfile", CTLTYPE_STRING }, \
//	{ "maxfilesperproc", CTLTYPE_INT }, \
//	{ "maxprocperuid", CTLTYPE_INT }, \
//	{ "dumpdev", CTLTYPE_STRUCT }, /* we lie; don't print as int */ \
//	{ "ipc", CTLTYPE_NODE }, \
//	{ "dummy", CTLTYPE_INT }, \
//	{ "ps_strings", CTLTYPE_INT }, \
//	{ "usrstack", CTLTYPE_INT }, \
//	{ "logsigexit", CTLTYPE_INT }, \
//	{ "iov_max", CTLTYPE_INT }, \
//	{ "maxposixlocksperuid", CTLTYPE_INT }, \
//}
//
///*
// * CTL_VFS identifiers
// */
//#define CTL_VFS_NAMES { \
//	{ "vfsconf", CTLTYPE_STRUCT }, \
//}
//
///*
// * KERN_PROC subtypes
// */
//#define KERN_PROC_ALL		0	/* everything */
//#define	KERN_PROC_PID		1	/* by process id */
//#define	KERN_PROC_PGRP		2	/* by process group id */
//#define	KERN_PROC_SESSION	3	/* by session of pid */
//#define	KERN_PROC_TTY		4	/* by controlling tty */
//#define	KERN_PROC_UID		5	/* by effective uid */
//#define	KERN_PROC_RUID		6	/* by real uid */
//#define	KERN_PROC_ARGS		7	/* get/set arguments/proctitle */
//#define	KERN_PROC_CWD		8	/* get cwd */
//
//#define KERN_PROC_FLAGMASK	0x10
//#define KERN_PROC_FLAG_LWP	0x10
//
///*
// * KERN_IPC identifiers
// */
//#define KIPC_MAXSOCKBUF		1	/* int: max size of a socket buffer */
//#define	KIPC_SOCKBUF_WASTE	2	/* int: wastage factor in sockbuf */
//#define	KIPC_SOMAXCONN		3	/* int: max length of connection q */
//#define	KIPC_MAX_LINKHDR	4	/* int: max length of link header */
//#define	KIPC_MAX_PROTOHDR	5	/* int: max length of network header */
//#define	KIPC_MAX_HDR		6	/* int: max total length of headers */
//#define	KIPC_MAX_DATALEN	7	/* int: max length of data? */
//#define	KIPC_MBSTAT		8	/* struct: mbuf usage statistics */
//#define	KIPC_NMBCLUSTERS	9	/* int: maximum mbuf clusters */
//
///*
// * CTL_HW identifiers
// */
//#define	HW_MACHINE	 1		/* string: machine class */
//#define	HW_MODEL	 2		/* string: specific machine model */
//#define	HW_NCPU		 3		/* int: number of cpus */
//#define	HW_BYTEORDER	 4		/* int: machine byte order */
//#define	HW_PHYSMEM	 5		/* int: total memory */
//#define	HW_USERMEM	 6		/* int: non-kernel memory */
//#define	HW_PAGESIZE	 7		/* int: software page size */
//#define	HW_DISKNAMES	 8		/* strings: disk drive names */
//#define	HW_DISKSTATS	 9		/* struct: diskstats[] */
//#define HW_FLOATINGPT	10		/* int: has HW floating point? */
//#define HW_MACHINE_ARCH	11		/* string: machine architecture */
//#define HW_MACHINE_PLATFORM 12		/* string: platform architecture */
//#define HW_SENSORS	13		/* node: hardware sensors */
//#define HW_MAXID	14		/* number of valid hw ids */
//
//#define CTL_HW_NAMES { \
//	{ 0, 0 }, \
//	{ "machine", CTLTYPE_STRING }, \
//	{ "model", CTLTYPE_STRING }, \
//	{ "ncpu", CTLTYPE_INT }, \
//	{ "byteorder", CTLTYPE_INT }, \
//	{ "physmem", CTLTYPE_ULONG }, \
//	{ "usermem", CTLTYPE_UINT }, \
//	{ "pagesize", CTLTYPE_INT }, \
//	{ "disknames", CTLTYPE_STRUCT }, \
//	{ "diskstats", CTLTYPE_STRUCT }, \
//	{ "floatingpoint", CTLTYPE_INT }, \
//	{ "arch", CTLTYPE_STRING }, \
//	{ "platform", CTLTYPE_STRING }, \
//	{ "sensors", CTLTYPE_NODE }, \
//}
//
///*
// * CTL_USER definitions
// */
//#define	USER_CS_PATH		 1	/* string: _CS_PATH */
//#define	USER_BC_BASE_MAX	 2	/* int: BC_BASE_MAX */
//#define	USER_BC_DIM_MAX		 3	/* int: BC_DIM_MAX */
//#define	USER_BC_SCALE_MAX	 4	/* int: BC_SCALE_MAX */
//#define	USER_BC_STRING_MAX	 5	/* int: BC_STRING_MAX */
//#define	USER_COLL_WEIGHTS_MAX	 6	/* int: COLL_WEIGHTS_MAX */
//#define	USER_EXPR_NEST_MAX	 7	/* int: EXPR_NEST_MAX */
//#define	USER_LINE_MAX		 8	/* int: LINE_MAX */
//#define	USER_RE_DUP_MAX		 9	/* int: RE_DUP_MAX */
//#define	USER_POSIX2_VERSION	10	/* int: POSIX2_VERSION */
//#define	USER_POSIX2_C_BIND	11	/* int: POSIX2_C_BIND */
//#define	USER_POSIX2_C_DEV	12	/* int: POSIX2_C_DEV */
//#define	USER_POSIX2_CHAR_TERM	13	/* int: POSIX2_CHAR_TERM */
//#define	USER_POSIX2_FORT_DEV	14	/* int: POSIX2_FORT_DEV */
//#define	USER_POSIX2_FORT_RUN	15	/* int: POSIX2_FORT_RUN */
//#define	USER_POSIX2_LOCALEDEF	16	/* int: POSIX2_LOCALEDEF */
//#define	USER_POSIX2_SW_DEV	17	/* int: POSIX2_SW_DEV */
//#define	USER_POSIX2_UPE		18	/* int: POSIX2_UPE */
//#define	USER_STREAM_MAX		19	/* int: POSIX2_STREAM_MAX */
//#define	USER_TZNAME_MAX		20	/* int: POSIX2_TZNAME_MAX */
//#define	USER_MAXID		21	/* number of valid user ids */
//
//#define	CTL_USER_NAMES { \
//	{ 0, 0 }, \
//	{ "cs_path", CTLTYPE_STRING }, \
//	{ "bc_base_max", CTLTYPE_INT }, \
//	{ "bc_dim_max", CTLTYPE_INT }, \
//	{ "bc_scale_max", CTLTYPE_INT }, \
//	{ "bc_string_max", CTLTYPE_INT }, \
//	{ "coll_weights_max", CTLTYPE_INT }, \
//	{ "expr_nest_max", CTLTYPE_INT }, \
//	{ "line_max", CTLTYPE_INT }, \
//	{ "re_dup_max", CTLTYPE_INT }, \
//	{ "posix2_version", CTLTYPE_INT }, \
//	{ "posix2_c_bind", CTLTYPE_INT }, \
//	{ "posix2_c_dev", CTLTYPE_INT }, \
//	{ "posix2_char_term", CTLTYPE_INT }, \
//	{ "posix2_fort_dev", CTLTYPE_INT }, \
//	{ "posix2_fort_run", CTLTYPE_INT }, \
//	{ "posix2_localedef", CTLTYPE_INT }, \
//	{ "posix2_sw_dev", CTLTYPE_INT }, \
//	{ "posix2_upe", CTLTYPE_INT }, \
//	{ "stream_max", CTLTYPE_INT }, \
//	{ "tzname_max", CTLTYPE_INT }, \
//}
//
//#define CTL_P1003_1B_ASYNCHRONOUS_IO		1	/* boolean */
//#define CTL_P1003_1B_MAPPED_FILES		2	/* boolean */
//#define CTL_P1003_1B_MEMLOCK			3	/* boolean */
//#define CTL_P1003_1B_MEMLOCK_RANGE		4	/* boolean */
//#define CTL_P1003_1B_MEMORY_PROTECTION		5	/* boolean */
//#define CTL_P1003_1B_MESSAGE_PASSING		6	/* boolean */
//#define CTL_P1003_1B_PRIORITIZED_IO		7	/* boolean */
//#define CTL_P1003_1B_PRIORITY_SCHEDULING	8	/* boolean */
//#define CTL_P1003_1B_REALTIME_SIGNALS		9	/* boolean */
//#define CTL_P1003_1B_SEMAPHORES			10	/* boolean */
//#define CTL_P1003_1B_FSYNC			11	/* boolean */
//#define CTL_P1003_1B_SHARED_MEMORY_OBJECTS	12	/* boolean */
//#define CTL_P1003_1B_SYNCHRONIZED_IO		13	/* boolean */
//#define CTL_P1003_1B_TIMERS			14	/* boolean */
//#define CTL_P1003_1B_AIO_LISTIO_MAX		15	/* int */
//#define CTL_P1003_1B_AIO_MAX			16	/* int */
//#define CTL_P1003_1B_AIO_PRIO_DELTA_MAX		17	/* int */
//#define CTL_P1003_1B_DELAYTIMER_MAX		18	/* int */
//#define CTL_P1003_1B_UNUSED1			19	/* int */
//#define CTL_P1003_1B_PAGESIZE			20	/* int */
//#define CTL_P1003_1B_RTSIG_MAX			21	/* int */
//#define CTL_P1003_1B_SEM_NSEMS_MAX		22	/* int */
//#define CTL_P1003_1B_SEM_VALUE_MAX		23	/* int */
//#define CTL_P1003_1B_SIGQUEUE_MAX		24	/* int */
//#define CTL_P1003_1B_TIMER_MAX			25	/* int */
//
//#define CTL_P1003_1B_MAXID		26
//
//#define	CTL_P1003_1B_NAMES { \
//	{ 0, 0 }, \
//	{ "asynchronous_io", CTLTYPE_INT }, \
//	{ "mapped_files", CTLTYPE_INT }, \
//	{ "memlock", CTLTYPE_INT }, \
//	{ "memlock_range", CTLTYPE_INT }, \
//	{ "memory_protection", CTLTYPE_INT }, \
//	{ "message_passing", CTLTYPE_INT }, \
//	{ "prioritized_io", CTLTYPE_INT }, \
//	{ "priority_scheduling", CTLTYPE_INT }, \
//	{ "realtime_signals", CTLTYPE_INT }, \
//	{ "semaphores", CTLTYPE_INT }, \
//	{ "fsync", CTLTYPE_INT }, \
//	{ "shared_memory_objects", CTLTYPE_INT }, \
//	{ "synchronized_io", CTLTYPE_INT }, \
//	{ "timers", CTLTYPE_INT }, \
//	{ "aio_listio_max", CTLTYPE_INT }, \
//	{ "aio_max", CTLTYPE_INT }, \
//	{ "aio_prio_delta_max", CTLTYPE_INT }, \
//	{ "delaytimer_max", CTLTYPE_INT }, \
//	{ "unused1", CTLTYPE_INT }, \
//	{ "pagesize", CTLTYPE_INT }, \
//	{ "rtsig_max", CTLTYPE_INT }, \
//	{ "nsems_max", CTLTYPE_INT }, \
//	{ "sem_value_max", CTLTYPE_INT }, \
//	{ "sigqueue_max", CTLTYPE_INT }, \
//	{ "timer_max", CTLTYPE_INT }, \
//}
//
//#ifdef _KERNEL
//
///*
// * Declare some common oids.
// */
//extern struct sysctl_oid_list sysctl__children;
//SYSCTL_DECL(_kern);
//SYSCTL_DECL(_sysctl);
//SYSCTL_DECL(_vm);
//SYSCTL_DECL(_vfs);
//SYSCTL_DECL(_net);
//SYSCTL_DECL(_debug);
//SYSCTL_DECL(_debug_sizeof);
//SYSCTL_DECL(_hw);
//SYSCTL_DECL(_hw_bus);
//SYSCTL_DECL(_machdep);
//SYSCTL_DECL(_user);
//SYSCTL_DECL(_compat);
//SYSCTL_DECL(_lwkt);
//SYSCTL_DECL(_security);
//SYSCTL_DECL(_dsched);
//
///*
// * Common second-level oids.
// */
//SYSCTL_DECL(_kern_ipc);
//
//extern char	machine[];
//extern char	osrelease[];
//extern char	ostype[];
//extern char	kern_ident[];
//
///* Dynamic oid handling */
//struct sysctl_oid *sysctl_add_oid(struct sysctl_ctx_list *clist,
//		struct sysctl_oid_list *parent, int nbr, const char *name,
//		int kind, void *arg1, int arg2,
//		int (*handler) (SYSCTL_HANDLER_ARGS),
//		const char *fmt, const char *descr);
//int	sysctl_remove_oid(struct sysctl_oid *oidp, int del, int recurse);
//int	sysctl_ctx_init(struct sysctl_ctx_list *clist);
//int	sysctl_ctx_free(struct sysctl_ctx_list *clist);
//struct	sysctl_ctx_entry *sysctl_ctx_entry_add(struct sysctl_ctx_list *clist,
//		struct sysctl_oid *oidp);
//struct	sysctl_ctx_entry *sysctl_ctx_entry_find(struct sysctl_ctx_list *clist,
//		struct sysctl_oid *oidp);
//int	sysctl_ctx_entry_del(struct sysctl_ctx_list *clist,
//		struct sysctl_oid *oidp);
//
//int	kernel_sysctl(int *name, u_int namelen, void *old,
//		      size_t *oldlenp, void *new, size_t newlen,
//		      size_t *retval);
//int	kernel_sysctlbyname(char *name,
//		void *old, size_t *oldlenp, void *new, size_t newlen,
//		size_t *retval);
//int	userland_sysctl(int *name, u_int namelen, void *old,
//			size_t *oldlenp, int inkernel, void *new, size_t newlen,
//			size_t *retval);
//int	sysctl_find_oid(int *name, u_int namelen, struct sysctl_oid **noid,
//			int *nindx, struct sysctl_req *req);
//
//int	sysctl_int_range(SYSCTL_HANDLER_ARGS, int low, int high);
//
//#endif	/* _KERNEL */
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//
//#include <sys/cdefs.h>
//
//__BEGIN_DECLS
//int	sysctl (int *, u_int, void *, size_t *, void *, size_t);
//int	sysctlbyname (const char *, void *, size_t *, void *, size_t);
//int	sysctlnametomib (const char *, int *, size_t *);
//__END_DECLS
//
//#endif	/* _KERNEL && _KERNEL_VIRTUAL */
//
//#endif	/* !_SYS_SYSCTL_H_ */




	// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/fcntl.h
/*
 * File status flags: these are used by open(2), fcntl(2).
 * They are also used (indirectly) in the kernel file structure f_flags,
 * which is a superset of the open/fcntl flags.  Open flags and f_flags
 * are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
 * Open/fcntl flags begin with O_; kernel-internal flags begin with F.
 */
/* open-only flags */
O_RDONLY	= 0x0000		/* open for reading only */
O_WRONLY	= 0x0001		/* open for writing only */
O_RDWR		= 0x0002		/* open for reading and writing */
O_ACCMODE	= 0x0003		/* mask for above modes */

///*
// * Kernel encoding of open mode; separate read and write bits that are
// * independently testable: 1 greater than the above.
// *
// * XXX
// * FREAD and FWRITE are excluded from the #ifdef _KERNEL so that TIOCFLUSH,
// * which was documented to use FREAD/FWRITE, continues to work.
// */
//#ifndef _POSIX_SOURCE
	FREAD		= 0x0001
	FWRITE		= 0x0002
//#endif
	O_NONBLOCK	= 0x0004		/* no delay */
	O_APPEND	= 0x0008		/* set append mode */
//#ifndef _POSIX_SOURCE
	O_SHLOCK	= 0x0010		/* open with shared file lock */
	O_EXLOCK	= 0x0020		/* open with exclusive file lock */
	O_ASYNC		= 0x0040		/* signal pgrp when data ready */
	O_FSYNC		= 0x0080		/* synchronous writes */
	O_NOFOLLOW	= 0x0100		/* don't follow symlinks */
//#endif
	O_SYNC		= 0x0080		/* Same as O_FSYNC, but POSIX */
	O_CREAT		= 0x0200		/* create if nonexistent */
	O_TRUNC		= 0x0400		/* truncate to zero length */
	O_EXCL		= 0x0800		/* error if already exists */
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
	FMARK		= 0x1000		/* mark during gc() */
	FDEFER		= 0x2000		/* defer for next gc pass */
	FHASLOCK	= 0x4000		/* descriptor holds advisory lock */
//#endif
//
///* Defined by POSIX 1003.1; BSD default, but must be distinct from O_RDONLY. */
	O_NOCTTY	= 0x8000		/* don't assign controlling terminal */
//
///* Attempt to bypass the buffer cache */
	O_DIRECT	= 0x00010000
//
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
	O_CLOEXEC	= 0x00020000	/* atomically set FD_CLOEXEC */
//#endif
	O_FBLOCKING	= 0x00040000	/* force blocking I/O */
	O_FNONBLOCKING	= 0x00080000	/* force non-blocking I/O */
	O_FAPPEND	= 0x00100000	/* force append mode for write */
	O_FOFFSET	= 0x00200000	/* force specific offset */
	O_FSYNCWRITE	= 0x00400000	/* force synchronous write */
	O_FASYNCWRITE	= 0x00800000	/* force asynchronous write */
	O_FUNBUFFERED	= 0x01000000	/* force unbuffered (direct) I/O */
	O_FBUFFERED	= 0x02000000	/* force buffered I/O */
	O_MAPONREAD	= 0x04000000	/* memory map read buffer */
//
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
//#define O_DIRECTORY	= 0x08000000	/* error if not a directory */
//#endif
//
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
	FREVOKED	= 0x10000000	/* revoked by fdrevoke() */
	FAPPENDONLY	= 0x20000000	/* O_APPEND cannot be changed */
	FOFFSETLOCK	= 0x40000000	/* f_offset locked */
	FOFFSETWAKE	= 0x80000000	/* f_offset wakeup */
//#endif
//
//#define O_FMASK		(O_FBLOCKING|O_FNONBLOCKING|O_FAPPEND|O_FOFFSET|\
//			 O_FSYNCWRITE|O_FASYNCWRITE|O_FUNBUFFERED|O_FBUFFERED|\
//			 O_MAPONREAD)
//
//#ifdef _KERNEL
///* convert from open() flags to/from fflags; convert O_RD/WR to FREAD/FWRITE */
//#define	= FFLAGS(oflags)	((oflags) + 1)
//#define	= OFLAGS(fflags)	((fflags) - 1)
//
///* bits to save after open */
//#define	FMASK		= (FREAD|FWRITE|FAPPEND|FASYNC|FFSYNC|FNONBLOCK|\
//			 FAPPENDONLY|FREVOKED|O_DIRECT|O_MAPONREAD)
///* bits settable by fcntl(F_SETFL, ...) */
//#define	FCNTLFLAGS	= (FAPPEND|FASYNC|FFSYNC|FNONBLOCK|FPOSIXSHM|\
//			 O_DIRECT|O_MAPONREAD)
//#endif
//
///*
// * The O_* flags used to have only F* names, which were used in the kernel
// * and by fcntl.  We retain the F* names for the kernel f_flag field
// * and for backward compatibility for fcntl.
// */
//#ifndef _POSIX_SOURCE
	FAPPEND		= O_APPEND	/* kernel/compat */
	FASYNC		= O_ASYNC		/* kernel/compat */
	FFSYNC		= O_FSYNC		/* kernel */
	FNONBLOCK	= O_NONBLOCK	/* kernel */
	FNDELAY		= O_NONBLOCK	/* compat */
	O_NDELAY	= O_NONBLOCK	/* compat */
//#endif
//
///*
// * We are out of bits in f_flag (which is a short).  However,
// * the flag bits not set in FMASK are only meaningful in the
// * initial open syscall.  Those bits can thus be given a
// * different meaning for fcntl(2).
// */
//#ifndef _POSIX_SOURCE
//
///*
// * Set by shm_open(3) to get automatic MAP_ASYNC behavior
// * for POSIX shared memory objects (which are otherwise
// * implemented as plain files).
// */
	FPOSIXSHM	= O_NOFOLLOW
//#endif
//
///*
// * Constants used by "at" family of system calls.
// */
	AT_FDCWD		= 0xFFFAFDCD	/* invalid file descriptor */
	AT_SYMLINK_NOFOLLOW	= 1
	AT_REMOVEDIR		= 2
	AT_EACCESS		= 4
	AT_SYMLINK_FOLLOW	= 8
//
///*
// * Constants used for fcntl(2)
// */
//
///* command values */
	F_DUPFD		= 0		/* duplicate file descriptor */
	F_GETFD		= 1		/* get file descriptor flags */
	F_SETFD		= 2		/* set file descriptor flags */
	F_GETFL		= 3		/* get file status flags */
	F_SETFL		= 4		/* set file status flags */
//#ifndef _POSIX_SOURCE
	F_GETOWN	= 5		/* get SIGIO/SIGURG proc/pgrp */
	F_SETOWN	= 6		/* set SIGIO/SIGURG proc/pgrp */
//#endif
	F_GETLK		= 7		/* get record locking information */
	F_SETLK		= 8		/* set record locking information */
	F_SETLKW	= 9		/* F_SETLK; wait if blocked */
	F_DUP2FD	= 10		/* duplicate file descriptor to arg */
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
	F_DUPFD_CLOEXEC	= 17		/* Like F_DUPFD with FD_CLOEXEC set */
//#endif
//#if __BSD_VISIBLE
	F_DUP2FD_CLOEXEC = 18		/* Like F_DUP2FD with FD_CLOEXEC set */
//#endif
//
///* file descriptor flags (F_GETFD, F_SETFD) */
	FD_CLOEXEC	= 1		/* close-on-exec flag */
//
///* record locking flags (F_GETLK, F_SETLK, F_SETLKW) */
	F_RDLCK		= 1		/* shared or read lock */
	F_UNLCK		= 2		/* unlock */
	F_WRLCK		= 3		/* exclusive or write lock */
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
	F_WAIT		= 0x010		/* Wait until lock is granted */
	F_UNUSED020	= 0x020
	F_POSIX		= 0x040	 	/* Use POSIX semantics for lock */
	F_NOEND		= 0x080		/* l_len = 0, internally used */
//#endif
//
//
///*
// * Advisory file segment locking data type -
// * information passed to system by user
// */
//struct flock {
//	off_t	l_start;	/* starting offset */
//	off_t	l_len;		/* len = 0 means until end of file */
//	pid_t	l_pid;		/* lock owner */
//	short	l_type;		/* lock type: read/write, etc. */
//	short	l_whence;	/* type of l_start */
//};
//
//#ifdef _KERNEL
//union fcntl_dat {
//	int		fc_fd;		/* F_DUPFD */
//	int		fc_cloexec;	/* F_GETFD/F_SETFD */
//	int		fc_flags;	/* F_GETFL/F_SETFL */
//	int		fc_owner;	/* F_GETOWN/F_SETOWN */
//	struct flock	fc_flock;	/* F_GETLK/F_SETLK */
//};
//#endif /* _KERNEL */
//
//
//#ifndef _POSIX_SOURCE
///* lock operations for flock(2) */
	LOCK_SH		= 0x01		/* shared file lock */
	LOCK_EX		= 0x02		/* exclusive file lock */
	LOCK_NB		= 0x04		/* don't block when locking */
	LOCK_UN		= 0x08		/* unlock file */
//#endif
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//#include <sys/cdefs.h>
//
//__BEGIN_DECLS
//int	open (const char *, int, ...);
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
//int	openat (int, const char *, int, ...);
//#endif
//int	creat (const char *, mode_t);
//int	fcntl (int, int, ...);
//#ifndef _POSIX_SOURCE
//int	flock (int, int);
//#endif /* !_POSIX_SOURCE */
//__END_DECLS
//#endif
//
//#endif /* !_SYS_FCNTL_H_ */



// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/ttycom.h
///*-
// * Copyright (c) 1982, 1986, 1990, 1993, 1994
// *	The Regents of the University of California.  All rights reserved.
// * (c) UNIX System Laboratories, Inc.
// * All or some portions of this file are derived from material licensed
// * to the University of California by American Telephone and Telegraph
// * Co. or Unix System Laboratories, Inc. and are reproduced herein with
// * the permission of UNIX System Laboratories, Inc.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)ttycom.h	8.1 (Berkeley) 3/28/94
// * $FreeBSD: src/sys/sys/ttycom.h,v 1.16 2000/01/29 16:47:35 peter Exp $
// * $DragonFly: src/sys/sys/ttycom.h,v 1.3 2007/12/30 20:02:57 hasso Exp $
// */
//
//#ifndef	_SYS_TTYCOM_H_
//#define	_SYS_TTYCOM_H_
//
//#include <sys/ioccom.h>
//
///*
// * Tty ioctl's except for those supported only for backwards compatibility
// * with the old tty driver.
// */
//
///*
// * Window/terminal size structure.  This information is stored by the kernel
// * in order to provide a consistent interface, but is not used by the kernel.
// */
//struct winsize {
//	unsigned short	ws_row;		/* rows, in characters */
//	unsigned short	ws_col;		/* columns, in characters */
//	unsigned short	ws_xpixel;	/* horizontal size, pixels */
//	unsigned short	ws_ypixel;	/* vertical size, pixels */
//};
//

// Macros defined in http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/ioccom.h
//#define _IO(g,n)        _IOC(IOC_VOID,  (g), (n), 0)

//#define	TIOCMODG	_IOR('t', 3, int)	/* get modem control state */
//#define	TIOCMODS	_IOW('t', 4, int)	/* set modem control state */
//#define		TIOCM_LE	0001		/* line enable */
//#define		TIOCM_DTR	0002		/* data terminal ready */
//#define		TIOCM_RTS	0004		/* request to send */
//#define		TIOCM_ST	0010		/* secondary transmit */
//#define		TIOCM_SR	0020		/* secondary receive */
//#define		TIOCM_CTS	0040		/* clear to send */
//#define		TIOCM_CAR	0100		/* carrier detect */
//#define		TIOCM_CD	TIOCM_CAR
//#define		TIOCM_RNG	0200		/* ring */
//#define		TIOCM_RI	TIOCM_RNG
//#define		TIOCM_DSR	0400		/* data set ready */
//						/* 8-10 compat */
//#define	TIOCEXCL	 _IO('t', 13)		/* set exclusive use of tty */
TIOCEXCL = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((13))))
//#define	TIOCNXCL	 _IO('t', 14)		/* reset exclusive use of tty */
TIOCNXCL = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((14))))
//						/* 15 unused */
//#define	TIOCFLUSH	_IOW('t', 16, int)	/* flush buffers */
//						/* 17-18 compat */
//#define	TIOCGETA	_IOR('t', 19, struct termios) /* get termios struct */
//#define	TIOCSETA	_IOW('t', 20, struct termios) /* set termios struct */
//#define	TIOCSETAW	_IOW('t', 21, struct termios) /* drain output, set */
//#define	TIOCSETAF	_IOW('t', 22, struct termios) /* drn out, fls in, set */
//#define	TIOCGETD	_IOR('t', 26, int)	/* get line discipline */
//#define	TIOCSETD	_IOW('t', 27, int)	/* set line discipline */
//						/* 127-124 compat */
//#define	TIOCSBRK	 _IO('t', 123)		/* set break bit */
TIOCSBRK = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((123))))
//#define	TIOCCBRK	 _IO('t', 122)		/* clear break bit */
TIOCCBRK = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((122))))
//#define	TIOCSDTR	 _IO('t', 121)		/* set data terminal ready */
TIOCSDTR = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((121))))
//#define	TIOCCDTR	 _IO('t', 120)		/* clear data terminal ready */
TIOCCDTR = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((120))))
//#define	TIOCGPGRP	_IOR('t', 119, int)	/* get pgrp of tty */
//#define	TIOCSPGRP	_IOW('t', 118, int)	/* set pgrp of tty */
//						/* 117-116 compat */
//#define	TIOCOUTQ	_IOR('t', 115, int)	/* output queue size */
//#define	TIOCSTI		_IOW('t', 114, char)	/* simulate terminal input */
//#define	TIOCNOTTY	 _IO('t', 113)		/* void tty association */
TIOCNOTTY = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((113))))

//#define	TIOCPKT		_IOW('t', 112, int)	/* pty: set/clear packet mode */
		TIOCPKT_DATA		= 0x00	/* data packet */
		TIOCPKT_FLUSHREAD	= 0x01	/* flush packet */
		TIOCPKT_FLUSHWRITE	= 0x02	/* flush packet */
		TIOCPKT_STOP		= 0x04	/* stop output */
		TIOCPKT_START		= 0x08	/* start output */
		TIOCPKT_NOSTOP		= 0x10	/* no more ^S, ^Q */
		TIOCPKT_DOSTOP		= 0x20	/* now do ^S ^Q */
		TIOCPKT_IOCTL		= 0x40	/* state change of pty driver */
//#define	TIOCSTOP	 _IO('t', 111)		/* stop output, like ^S */
TIOCSTOP = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((111))))
//#define	TIOCSTART	 _IO('t', 110)		/* start output, like ^Q */
TIOCSTART = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((110))))
//#define	TIOCMSET	_IOW('t', 109, int)	/* set all modem bits */
//#define	TIOCMBIS	_IOW('t', 108, int)	/* bis modem bits */
//#define	TIOCMBIC	_IOW('t', 107, int)	/* bic modem bits */
//#define	TIOCMGET	_IOR('t', 106, int)	/* get all modem bits */
//#define	TIOCREMOTE	_IOW('t', 105, int)	/* remote input editing */
//#define	TIOCGWINSZ	_IOR('t', 104, struct winsize)	/* get window size */
//#define	TIOCSWINSZ	_IOW('t', 103, struct winsize)	/* set window size */
//#define	TIOCUCNTL	_IOW('t', 102, int)	/* pty: set/clr usr cntl mode */
//#define	TIOCSTAT	 _IO('t', 101)		/* simulate ^T status message */
TIOCSTAT = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((101))))
//#define		UIOCCMD(n)	_IO('u', n)	/* usr cntl op "n" */
//#define	TIOCGSID	_IOR('t', 99, int)	/* get session id */
//#define	TIOCCONS	_IOW('t', 98, int)	/* become virtual console */
//#define	TIOCSCTTY	 _IO('t', 97)		/* become controlling tty */

TIOCSCTTY = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((97))))

//#define	TIOCEXT		_IOW('t', 96, int)	/* pty: external processing */
//#define	TIOCSIG		 _IO('t', 95)		/* pty: generate signal */
TIOCSIG = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((95))))
//#define	TIOCDRAIN	 _IO('t', 94)		/* wait till output drained */
TIOCDRAIN = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((94))))
//#define	TIOCMSDTRWAIT	_IOW('t', 91, int)	/* modem: set wait on close */
//#define	TIOCMGDTRWAIT	_IOR('t', 90, int)	/* modem: get wait on close */
//#define	TIOCTIMESTAMP	_IOR('t', 89, struct timeval)	/* enable/get timestamp
//						 * of last input event */
//#define	TIOCDCDTIMESTAMP _IOR('t', 88, struct timeval)	/* enable/get timestamp
//						 * of last DCd rise */
//#define	TIOCSDRAINWAIT	_IOW('t', 87, int)	/* set ttywait timeout */
//#define	TIOCGDRAINWAIT	_IOR('t', 86, int)	/* get ttywait timeout */
//#define	TIOCISPTMASTER	_IO('t', 85)	/* is pty master */
TIOCISPTMASTER = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((85))))
//
//#define	TTYDISC		0		/* termios tty line discipline */
//#define	SLIPDISC	4		/* serial IP discipline */
//#define	PPPDISC		5		/* PPP discipline */
//#define	NETGRAPHDISC	6		/* Netgraph tty node discipline */
//#define	BTUARTDISC	7		/* Bluetooth btuart discipline */
//
//#endif /* !_SYS_TTYCOM_H_ */


// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/ioccom.h

///*-
// * Copyright (c) 1982, 1986, 1990, 1993, 1994
// *	The Regents of the University of California.  All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)ioccom.h	8.2 (Berkeley) 3/28/94
// * $FreeBSD: src/sys/sys/ioccom.h,v 1.9 1999/12/29 04:24:42 peter Exp $
// * $DragonFly: src/sys/sys/ioccom.h,v 1.4 2007/01/10 13:33:22 swildner Exp $
// */
//
//#ifndef	_SYS_IOCCOM_H_
//#define	_SYS_IOCCOM_H_
//
///*
// * Ioctl's have the command encoded in the lower word, and the size of
// * any in or out parameters in the upper word.  The high 3 bits of the
// * upper word are used to encode the in/out status of the parameter.
// */
	IOCPARM_MASK	= 0x1fff		/* parameter length, at most 13 bits */
//#define	IOCPARM_LEN(x)	= (((x) >> 16) & IOCPARM_MASK)
//#define	IOCBASECMD(x)	= ((x) & ~(IOCPARM_MASK << 16))
	//IOCGROUP(x)	= (((x) >> 8) & 0xff)
//
//#define	IOCPARM_MAX	PAGE_SIZE		/* max size of ioctl, mult. of PAGE_SIZE */
	IOC_VOID	= 0x20000000	/* no parameters */
	IOC_OUT		= 0x40000000	/* copy out parameters */
	IOC_IN		= 0x80000000	/* copy in parameters */
	IOC_INOUT	= (IOC_IN|IOC_OUT)
	IOC_DIRMASK	= 0xe0000000	/* mask for IN/OUT/VOID */
//
//#define	_IOC(inout,group,num,len) \
//	((unsigned long)(inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num)))
//#define	_IO(g,n)	_IOC(IOC_VOID,	(g), (n), 0)
//#define	_IOR(g,n,t)	_IOC(IOC_OUT,	(g), (n), sizeof(t))
//#define	_IOW(g,n,t)	_IOC(IOC_IN,	(g), (n), sizeof(t))
///* this should be _IORW, but stdio got there first */
//#define	_IOWR(g,n,t)	_IOC(IOC_INOUT,	(g), (n), sizeof(t))
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//
//#include <sys/cdefs.h>
//
//__BEGIN_DECLS
//int	ioctl (int, unsigned long, ...);
//__END_DECLS
//
//#endif
//
//#endif /* !_SYS_IOCCOM_H_ */




// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/event.h

///*-
// * Copyright (c) 1999,2000,2001 Jonathan Lemon <jlemon@FreeBSD.org>
// * All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// *
// * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	$FreeBSD: src/sys/sys/event.h,v 1.5.2.6 2003/02/09 15:28:13 nectar Exp $
// *	$DragonFly: src/sys/sys/event.h,v 1.7 2007/01/15 01:26:56 dillon Exp $
// */
//
//#ifndef _SYS_EVENT_H_
//#define _SYS_EVENT_H_
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#ifndef _NET_NETISR_H_
//#include <net/netisr.h>			/* struct notifymsglist */
//#endif
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
//#include <sys/queue.h>
//#endif
//
	EVFILT_READ		= (-1)
	EVFILT_WRITE		= (-2)
	EVFILT_AIO		= (-3)	/* attached to aio requests */
	EVFILT_VNODE		= (-4)	/* attached to vnodes */
	EVFILT_PROC		= (-5)	/* attached to struct proc */
	EVFILT_SIGNAL		= (-6)	/* attached to struct proc */
	EVFILT_TIMER		= (-7)	/* timers */
	EVFILT_EXCEPT		= (-8)	/* exceptional conditions */
//
//#define EVFILT_MARKER		0xF	/* placemarker for tailq */
//
//#define EVFILT_SYSCOUNT		8
//
//#define EV_SET(kevp_, a, b, c, d, e, f) do {	\
//	struct kevent *kevp = (kevp_);		\
//	(kevp)->ident = (a);			\
//	(kevp)->filter = (b);			\
//	(kevp)->flags = (c);			\
//	(kevp)->fflags = (d);			\
//	(kevp)->data = (e);			\
//	(kevp)->udata = (f);			\
//} while(0)
//
//struct kevent {
//	uintptr_t	ident;		/* identifier for this event */
//	short		filter;		/* filter for event */
//	u_short		flags;
//	u_int		fflags;
//	intptr_t	data;
//	void		*udata;		/* opaque user data identifier */
//};
//
///* actions */
	EV_ADD		= 0x0001		/* add event to kq (implies enable) */
	EV_DELETE	= 0x0002		/* delete event from kq */
	EV_ENABLE	= 0x0004		/* enable event */
	EV_DISABLE	= 0x0008		/* disable event (not reported) */
//
///* flags */
	EV_ONESHOT	= 0x0010		/* only report one occurrence */
	EV_CLEAR	= 0x0020		/* clear event state after reporting */
//
	EV_SYSFLAGS	= 0xF000		/* reserved by system */
	EV_FLAG1	= 0x2000		/* filter-specific flag */
//
///* returned values */
	EV_EOF		= 0x8000		/* EOF detected */
	EV_ERROR	= 0x4000		/* error, data contains errno */
	EV_NODATA	= 0x1000		/* EOF and no more data */
//
///*
// * data/hint flags for EVFILT_{READ|WRITE}, shared with userspace
// */
//#define NOTE_LOWAT	0x0001			/* low water mark */
//
///*
// * data/hint flags for EVFILT_EXCEPT, shared with userspace and with
// * EVFILT_{READ|WRITE}
// */
//#define NOTE_OOB	0x0002			/* OOB data on a socket */
//
///*
// * data/hint flags for EVFILT_VNODE, shared with userspace
// */
//#define	NOTE_DELETE	0x0001			/* vnode was removed */
//#define	NOTE_WRITE	0x0002			/* data contents changed */
//#define	NOTE_EXTEND	0x0004			/* size increased */
//#define	NOTE_ATTRIB	0x0008			/* attributes changed */
//#define	NOTE_LINK	0x0010			/* link count changed */
//#define	NOTE_RENAME	0x0020			/* vnode was renamed */
//#define	NOTE_REVOKE	0x0040			/* vnode access was revoked */
//
///*
// * data/hint flags for EVFILT_PROC, shared with userspace
// */
//#define	NOTE_EXIT	0x80000000		/* process exited */
//#define	NOTE_FORK	0x40000000		/* process forked */
//#define	NOTE_EXEC	0x20000000		/* process exec'd */
//#define	NOTE_PCTRLMASK	0xf0000000		/* mask for hint bits */
//#define	NOTE_PDATAMASK	0x000fffff		/* mask for pid */
//
///* additional flags for EVFILT_PROC */
//#define	NOTE_TRACK	0x00000001		/* follow across forks */
//#define	NOTE_TRACKERR	0x00000002		/* could not track child */
//#define	NOTE_CHILD	0x00000004		/* am a child process */
//
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
//
//struct knote;
//SLIST_HEAD(klist, knote);
//
///*
// * Used to maintain information about processes that wish to be
// * notified when I/O becomes possible.
// */
//struct kqinfo {
//	struct	klist ki_note;		/* kernel note list */
//	struct	notifymsglist ki_mlist;	/* list of pending predicate messages */
//};
//
//#endif
//
//#ifdef _KERNEL
//
///*
// * Global token for kqueue subsystem
// */
//extern struct lwkt_token kq_token;
//
//#ifdef MALLOC_DECLARE
//MALLOC_DECLARE(M_KQUEUE);
//#endif
//
//#define KNOTE(list, hint)	if ((list) != NULL) knote(list, hint)
//
///*
// * Flag indicating hint is a signal.  Used by EVFILT_SIGNAL, and also
// * shared by EVFILT_PROC  (all knotes attached to p->p_klist)
// *
// * NOTE_OLDAPI is used to signal that standard filters are being called
// * from the select/poll wrapper.
// */
//#define NOTE_SIGNAL	0x08000000
//#define NOTE_OLDAPI	0x04000000	/* select/poll note */
//
//#define FILTEROP_ISFD	0x0001		/* if ident == filedescriptor */
//#define FILTEROP_MPSAFE	0x0002
//
//struct filterops {
//	u_short	f_flags;
//
//	/* f_attach returns 0 on success or valid error code on failure */
//	int	(*f_attach)	(struct knote *kn);
//	void	(*f_detach)	(struct knote *kn);
//
//        /* f_event returns boolean truth */
//	int	(*f_event)	(struct knote *kn, long hint);
//};
//
//struct knote {
//	SLIST_ENTRY(knote)	kn_link;	/* for fd */
//	TAILQ_ENTRY(knote)	kn_kqlink;	/* for kq_knlist */
//	SLIST_ENTRY(knote)	kn_next;	/* for struct kqinfo */
//	TAILQ_ENTRY(knote)	kn_tqe;		/* for kq_head */
//	struct			kqueue *kn_kq;	/* which queue we are on */
//	struct 			kevent kn_kevent;
//	int			kn_status;
//	int			kn_sfflags;	/* saved filter flags */
//	intptr_t		kn_sdata;	/* saved data field */
//	union {
//		struct		file *p_fp;	/* file data pointer */
//		struct		proc *p_proc;	/* proc pointer */
//	} kn_ptr;
//	struct			filterops *kn_fop;
//	caddr_t			kn_hook;
//};
//
//#define KN_ACTIVE	0x0001			/* event has been triggered */
//#define KN_QUEUED	0x0002			/* event is on queue */
//#define KN_DISABLED	0x0004			/* event is disabled */
//#define KN_DETACHED	0x0008			/* knote is detached */
//#define KN_REPROCESS	0x0010			/* force reprocessing race */
//#define KN_DELETING	0x0020			/* deletion in progress */
//#define KN_PROCESSING	0x0040			/* event processing in prog */
//#define KN_WAITING	0x0080			/* waiting on processing */
//
//#define kn_id		kn_kevent.ident
//#define kn_filter	kn_kevent.filter
//#define kn_flags	kn_kevent.flags
//#define kn_fflags	kn_kevent.fflags
//#define kn_data		kn_kevent.data
//#define kn_fp		kn_ptr.p_fp
//
//struct proc;
//struct thread;
//struct filedesc;
//struct kevent_args;
//
//typedef int	(*k_copyout_fn)(void *arg, struct kevent *kevp, int count,
//    int *res);
//typedef int	(*k_copyin_fn)(void *arg, struct kevent *kevp, int max,
//    int *events);
//int kern_kevent(struct kqueue *kq, int nevents, int *res, void *uap,
//    k_copyin_fn kevent_copyin, k_copyout_fn kevent_copyout,
//    struct timespec *tsp);
//
//extern void	knote(struct klist *list, long hint);
//extern void	knote_insert(struct klist *klist, struct knote *kn);
//extern void	knote_remove(struct klist *klist, struct knote *kn);
///*extern void	knote_empty(struct klist *list);*/
//extern void	knote_assume_knotes(struct kqinfo *, struct kqinfo *,
//		    struct filterops *, void *);
//extern void	knote_fdclose(struct file *fp, struct filedesc *fdp, int fd);
//extern void	kqueue_init(struct kqueue *kq, struct filedesc *fdp);
//extern void	kqueue_terminate(struct kqueue *kq);
//extern int 	kqueue_register(struct kqueue *kq, struct kevent *kev);
//
//#endif 	/* _KERNEL */
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//
//#include <sys/cdefs.h>
//struct timespec;
//
//__BEGIN_DECLS
//int     kqueue (void);
//int     kevent (int, const struct kevent *, int, struct kevent *,
//		int, const struct timespec *);
//__END_DECLS
//#endif /* !_KERNEL */
//
//#endif /* !_SYS_EVENT_H_ */




)


// Errors
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/errno.h
const (
	EPERM		= Errno(1)		/* Operation not permitted */
	ENOENT		= Errno(2)		/* No such file or directory */
	ESRCH		= Errno(3)		/* No such process */
	EINTR		= Errno(4)		/* Interrupted system call */
	EIO		= Errno(5)		/* Input/output error */
	ENXIO		= Errno(6)		/* Device not configured */
	E2BIG		= Errno(7)		/* Argument list too long */
	ENOEXEC		= Errno(8)		/* Exec format error */
	EBADF		= Errno(9)		/* Bad file descriptor */
	ECHILD		= Errno(10)		/* No child processes */
	EDEADLK		= Errno(11)		/* Resource deadlock avoided */
						/* 11 was EAGAIN */
	ENOMEM		= Errno(12)		/* Cannot allocate memory */
	EACCES		= Errno(13)		/* Permission denied */
	EFAULT		= Errno(14)		/* Bad address */
	EBUSY		= Errno(16)		/* Device busy */
	EEXIST		= Errno(17)		/* File exists */
	EXDEV		= Errno(18)		/* Cross-device link */
	ENODEV		= Errno(19)		/* Operation not supported by device */
	ENOTDIR		= Errno(20)		/* Not a directory */
	EISDIR		= Errno(21)		/* Is a directory */
	EINVAL		= Errno(22)		/* Invalid argument */
	ENFILE		= Errno(23)		/* Too many open files in system */
	EMFILE		= Errno(24)		/* Too many open files */
	ENOTTY		= Errno(25)		/* Inappropriate ioctl for device */
	EFBIG		= Errno(27)		/* File too large */
	ENOSPC		= Errno(28)		/* No space left on device */
	ESPIPE		= Errno(29)		/* Illegal seek */
	EROFS		= Errno(30)		/* Read-only filesystem */
	EMLINK		= Errno(31)		/* Too many links */
	EPIPE		= Errno(32)		/* Broken pipe */

	/* math software */
	EDOM		= Errno(33)		/* Numerical argument out of domain */
	ERANGE		= Errno(34)		/* Result too large */

	/* non-blocking and interrupt i/o */
	EAGAIN		= Errno(35)		/* Resource temporarily unavailable */
	EWOULDBLOCK	= Errno(EAGAIN)		/* Operation would block */
	EINPROGRESS	= Errno(36)		/* Operation now in progress */
	EALREADY	= Errno(37)		/* Operation already in progress */

	/* ipc/network software -- argument errors */
	ENOTSOCK	= Errno(38)		/* Socket operation on non-socket */
	EDESTADDRREQ	= Errno(39)		/* Destination address required */
	EMSGSIZE	= Errno(40)		/* Message too long */
	EPROTOTYPE	= Errno(41)		/* Protocol wrong type for socket */
	ENOPROTOOPT	= Errno(42)		/* Protocol not available */
	EPROTONOSUPPORT	= Errno(43)		/* Protocol not supported */
	ESOCKTNOSUPPORT	= Errno(44)		/* Socket type not supported */
	EOPNOTSUPP	= Errno(45)		/* Operation not supported */
	ENOTSUP		= Errno(EOPNOTSUPP)	/* Operation not supported */
	EPFNOSUPPORT	= Errno(46)		/* Protocol family not supported */
	EAFNOSUPPORT	= Errno(47)		/* Address family not supported by protocol family */
	EADDRINUSE	= Errno(48)		/* Address already in use */
	EADDRNOTAVAIL	= Errno(49)		/* Can't assign requested address */

	/* ipc/network software -- operational errors */
	ENETDOWN	= Errno(50)		/* Network is down */
	ENETUNREACH	= Errno(51)		/* Network is unreachable */
	ENETRESET	= Errno(52)		/* Network dropped connection on reset */
	ECONNABORTED	= Errno(53)		/* Software caused connection abort */
	ECONNRESET	= Errno(54)		/* Connection reset by peer */
	ENOBUFS		= Errno(55)		/* No buffer space available */
	EISCONN		= Errno(56)		/* Socket is already connected */
	ENOTCONN	= Errno(57)		/* Socket is not connected */
	ESHUTDOWN	= Errno(58)		/* Can't send after socket shutdown */
	ETOOMANYREFS	= Errno(59)		/* Too many references: can't splice */
	ETIMEDOUT	= Errno(60)		/* Operation timed out */
	ECONNREFUSED	= Errno(61)		/* Connection refused */

	ELOOP		= Errno(62)		/* Too many levels of symbolic links */
	ENAMETOOLONG	= Errno(63)		/* File name too long */

	/* should be rearranged */
	ENOTEMPTY	= Errno(66)		/* Directory not empty */

	/* quotas & mush */

	ENOLCK		= Errno(77)		/* No locks available */
	ENOSYS		= Errno(78)		/* Function not implemented */

	EBADMSG		= Errno(89)		/* Bad message */
	EMULTIHOP	= Errno(90)		/* Multihop attempted */
	ENOLINK		= Errno(91)		/* Link has been severed */
	EPROTO		= Errno(92)		/* Protocol error */






// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/socket.h

///*
// * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
// *	The Regents of the University of California.  All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)socket.h	8.4 (Berkeley) 2/21/94
// * $FreeBSD: src/sys/sys/socket.h,v 1.39.2.7 2001/07/03 11:02:01 ume Exp $
// */
//
//#ifndef _SYS_SOCKET_H_
//#define	_SYS_SOCKET_H_
//
//#include <sys/_iovec.h>
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#include <machine/stdint.h>
//
//#define _NO_NAMESPACE_POLLUTION
//#include <machine/param.h>
//#undef _NO_NAMESPACE_POLLUTION
//
///*
// * Definitions related to sockets: types, address families, options.
// */
//
///*
// * Data types.
// */
//typedef __uint8_t	sa_family_t;
//
//#ifndef _SOCKLEN_T_DECLARED
//#define _SOCKLEN_T_DECLARED
//typedef __socklen_t	socklen_t;
//#endif
//
// 
///*
// * Types
// */
//#define	SOCK_STREAM	1		/* stream socket */
	SOCK_STREAM	= 1		/* stream socket */
//#define	SOCK_DGRAM	2		/* datagram socket */
	SOCK_DGRAM	= 2		/* datagram socket */
//#define	SOCK_RAW	3		/* raw-protocol interface */
	SOCK_RAW	= 3		/* raw-protocol interface */
//#define	SOCK_RDM	4		/* reliably-delivered message */
	SOCK_RDM	= 4		/* reliably-delivered message */
//#define	SOCK_SEQPACKET	5		/* sequenced packet stream */
	SOCK_SEQPACKET	= 5		/* sequenced packet stream */
//
///*
// * Option flags per-socket.
// */
//#define	SO_DEBUG	0x0001		/* turn on debugging info recording */
//#define	SO_ACCEPTCONN	0x0002		/* socket has had listen() */
//#define	SO_REUSEADDR	0x0004		/* allow local address reuse */
//#define	SO_KEEPALIVE	0x0008		/* keep connections alive */
//#define	SO_DONTROUTE	0x0010		/* just use interface addresses */
//#define	SO_BROADCAST	0x0020		/* permit sending of broadcast msgs */
//#define	SO_USELOOPBACK	0x0040		/* bypass hardware when possible */
//#define	SO_LINGER	0x0080		/* linger on close if data present */
//#define	SO_OOBINLINE	0x0100		/* leave received OOB data in line */
//#define	SO_REUSEPORT	0x0200		/* allow local address & port reuse */
//#define	SO_TIMESTAMP	0x0400		/* timestamp received dgram traffic */
//#define	SO_NOSIGPIPE	0x0800		/* no SIGPIPE from EPIPE */
//#define	SO_ACCEPTFILTER	0x1000		/* there is an accept filter */
//
///*
// * Additional options, not kept in so_options.
// */
 SO_SNDBUF	= 0x1001		/* send buffer size */
 SO_RCVBUF	= 0x1002		/* receive buffer size */
 SO_SNDLOWAT	= 0x1003		/* send low-water mark */
 SO_RCVLOWAT	= 0x1004		/* receive low-water mark */
 SO_SNDTIMEO	= 0x1005		/* send timeout */
 SO_RCVTIMEO	= 0x1006		/* receive timeout */
	SO_ERROR	= 0x1007		/* get error status and clear */
	SO_TYPE		= 0x1008		/* get socket type */
	SO_PRIVSTATE	= 0x1009		/*   get/deny privileged state */
	SO_SNDSPACE	= 0x100a		/* get appr. send buffer free space */
//
///*
// * Structure used for manipulating linger option.
// */
//struct	linger {
//	int	l_onoff;		/* option on/off */
//	int	l_linger;		/* linger time */
//};
//
//struct	accept_filter_arg {
//	char	af_name[16];
//	char	af_arg[256-16];
//};
//
///*
// * Level number for (get/set)sockopt() to apply to socket itself.
// */
	SOL_SOCKET	= 0xffff		/* options for socket level */
//
///*
// * Address families.
// */
//#define	AF_UNSPEC	0		/* unspecified */
//#define	AF_LOCAL	1		/* local to host (pipes, portals) */
//#define	AF_UNIX		AF_LOCAL	/* backward compatibility */
//#define	AF_INET		2		/* internetwork: UDP, TCP, etc. */
//#define	AF_IMPLINK	3		/* arpanet imp addresses */
//#define	AF_PUP		4		/* pup protocols: e.g. BSP */
//#define	AF_CHAOS	5		/* mit CHAOS protocols */
//#define	AF_NS		6		/* XEROX NS protocols */
//#define	AF_ISO		7		/* ISO protocols */
//#define	AF_OSI		AF_ISO
//#define	AF_ECMA		8		/* European computer manufacturers */
//#define	AF_DATAKIT	9		/* datakit protocols */
//#define	AF_CCITT	10		/* CCITT protocols, X.25 etc */
//#define	AF_SNA		11		/* IBM SNA */
//#define AF_DECnet	12		/* DECnet */
//#define AF_DLI		13		/* DEC Direct data link interface */
//#define AF_LAT		14		/* LAT */
//#define	AF_HYLINK	15		/* NSC Hyperchannel */
//#define	AF_APPLETALK	16		/* Apple Talk */
//#define	AF_ROUTE	17		/* Internal Routing Protocol */
//#define	AF_LINK		18		/* Link layer interface */
//#define	pseudo_AF_XTP	19		/* eXpress Transfer Protocol (no AF) */
//#define	AF_COIP		20		/* connection-oriented IP, aka ST II */
//#define	AF_CNT		21		/* Computer Network Technology */
//#define pseudo_AF_RTIP	22		/* Help Identify RTIP packets */
//#define	AF_IPX		23		/* Novell Internet Protocol */
//#define	AF_SIP		24		/* Simple Internet Protocol */
//#define	pseudo_AF_PIP	25		/* Help Identify PIP packets */
//#define	AF_ISDN		26		/* Integrated Services Digital Network*/
//#define	AF_E164		AF_ISDN		/* CCITT E.164 recommendation */
//#define	pseudo_AF_KEY	27		/* Internal key-management function */
//#define	AF_INET6	28		/* IPv6 */
//#define	AF_NATM		29		/* native ATM access */
//#define	AF_ATM		30		/* ATM */
//#define pseudo_AF_HDRCMPLT 31		/* Used by BPF to not rewrite headers
//					 * in interface output routine
//					 */
//#define	AF_NETGRAPH	32		/* Netgraph sockets */
//#define	AF_BLUETOOTH	33		/* Bluetooth */
//#define	AF_MPLS		34		/* Multi-Protocol Label Switching */
//#define	AF_IEEE80211	35		/* IEEE 802.11 protocol */
//
//#define	AF_MAX		36
//
///*
// * Structure used by kernel to store most
// * addresses.
// */
//struct sockaddr {
//	__uint8_t	sa_len;		/* total length */
//	sa_family_t	sa_family;	/* address family */
//	char		sa_data[14];	/* actually longer; address value */
//};
//#define	SOCK_MAXADDRLEN	255		/* longest possible addresses */
//
//#ifdef _KERNEL
//
//#ifndef _SYS_LIBKERN_H_
//#include <sys/libkern.h>		/* for bcmp() */
//#endif
//
//static __inline boolean_t
//sa_equal(const struct sockaddr *a1, const struct sockaddr *a2)
//{
//	return (bcmp(a1, a2, a1->sa_len) == 0);
//}
//#endif
//
///*
// * Structure used by kernel to pass protocol
// * information in raw sockets.
// */
//struct sockproto {
//	__uint16_t	sp_family;		/* address family */
//	__uint16_t	sp_protocol;		/* protocol */
//};
//
///*
// * RFC 2553: protocol-independent placeholder for socket addresses
// */
//#define	_SS_MAXSIZE	128
//#define	_SS_ALIGNSIZE	(sizeof(int64_t))
//#define	_SS_PAD1SIZE	(_SS_ALIGNSIZE - sizeof(unsigned char) - sizeof(sa_family_t))
//#define	_SS_PAD2SIZE	(_SS_MAXSIZE - sizeof(unsigned char) - sizeof(sa_family_t) - \
//				_SS_PAD1SIZE - _SS_ALIGNSIZE)
//
//struct sockaddr_storage {
//	__uint8_t	ss_len;		/* address length */
//	sa_family_t	ss_family;	/* address family */
//	char		__ss_pad1[_SS_PAD1SIZE];
//	__int64_t	__ss_align;	/* force desired structure storage alignment */
//	char		__ss_pad2[_SS_PAD2SIZE];
//};
//
///*
// * Protocol families, same as address families for now.
// */
//#define	PF_UNSPEC	AF_UNSPEC
//#define	PF_LOCAL	AF_LOCAL
//#define	PF_UNIX		PF_LOCAL	/* backward compatibility */
//#define	PF_INET		AF_INET
//#define	PF_IMPLINK	AF_IMPLINK
//#define	PF_PUP		AF_PUP
//#define	PF_CHAOS	AF_CHAOS
//#define	PF_NS		AF_NS
//#define	PF_ISO		AF_ISO
//#define	PF_OSI		AF_ISO
//#define	PF_ECMA		AF_ECMA
//#define	PF_DATAKIT	AF_DATAKIT
//#define	PF_CCITT	AF_CCITT
//#define	PF_SNA		AF_SNA
//#define PF_DECnet	AF_DECnet
//#define PF_DLI		AF_DLI
//#define PF_LAT		AF_LAT
//#define	PF_HYLINK	AF_HYLINK
//#define	PF_APPLETALK	AF_APPLETALK
//#define	PF_ROUTE	AF_ROUTE
//#define	PF_LINK		AF_LINK
//#define	PF_XTP		pseudo_AF_XTP	/* really just proto family, no AF */
//#define	PF_COIP		AF_COIP
//#define	PF_CNT		AF_CNT
//#define	PF_SIP		AF_SIP
//#define	PF_IPX		AF_IPX		/* same format as AF_NS */
//#define PF_RTIP		pseudo_AF_RTIP	/* same format as AF_INET */
//#define PF_PIP		pseudo_AF_PIP
//#define	PF_ISDN		AF_ISDN
//#define	PF_KEY		pseudo_AF_KEY
//#define	PF_INET6	AF_INET6
//#define	PF_NATM		AF_NATM
//#define	PF_ATM		AF_ATM
//#define	PF_NETGRAPH	AF_NETGRAPH
//#define	PF_BLUETOOTH	AF_BLUETOOTH
//
//#define	PF_MAX		AF_MAX
//
///*
// * Definitions for network related sysctl, CTL_NET.
// *
// * Second level is protocol family.
// * Third level is protocol number.
// *
// * Further levels are defined by the individual families below.
// */
//#define NET_MAXID	AF_MAX
//
//#define CTL_NET_NAMES { \
//	{ 0, 0 }, \
//	{ "unix", CTLTYPE_NODE }, \
//	{ "inet", CTLTYPE_NODE }, \
//	{ "implink", CTLTYPE_NODE }, \
//	{ "pup", CTLTYPE_NODE }, \
//	{ "chaos", CTLTYPE_NODE }, \
//	{ "xerox_ns", CTLTYPE_NODE }, \
//	{ "iso", CTLTYPE_NODE }, \
//	{ "emca", CTLTYPE_NODE }, \
//	{ "datakit", CTLTYPE_NODE }, \
//	{ "ccitt", CTLTYPE_NODE }, \
//	{ "ibm_sna", CTLTYPE_NODE }, \
//	{ "decnet", CTLTYPE_NODE }, \
//	{ "dec_dli", CTLTYPE_NODE }, \
//	{ "lat", CTLTYPE_NODE }, \
//	{ "hylink", CTLTYPE_NODE }, \
//	{ "appletalk", CTLTYPE_NODE }, \
//	{ "route", CTLTYPE_NODE }, \
//	{ "link_layer", CTLTYPE_NODE }, \
//	{ "xtp", CTLTYPE_NODE }, \
//	{ "coip", CTLTYPE_NODE }, \
//	{ "cnt", CTLTYPE_NODE }, \
//	{ "rtip", CTLTYPE_NODE }, \
//	{ "ipx", CTLTYPE_NODE }, \
//	{ "sip", CTLTYPE_NODE }, \
//	{ "pip", CTLTYPE_NODE }, \
//	{ "isdn", CTLTYPE_NODE }, \
//	{ "key", CTLTYPE_NODE }, \
//	{ "inet6", CTLTYPE_NODE }, \
//	{ "natm", CTLTYPE_NODE }, \
//	{ "atm", CTLTYPE_NODE }, \
//	{ "hdrcomplete", CTLTYPE_NODE }, \
//	{ "netgraph", CTLTYPE_NODE }, \
//	{ "bluetooth", CTLTYPE_NODE}, \
//}
//
///*
// * PF_ROUTE - Routing table
// *
// * Three additional levels are defined:
// *	Fourth: address family, 0 is wildcard
// *	Fifth: type of info, defined below
// *	Sixth: flag(s) to mask with for NET_RT_FLAGS
// */
//#define NET_RT_DUMP	1		/* dump; may limit to a.f. */
 NET_RT_DUMP	= 1		/* dump; may limit to a.f. */
//#define NET_RT_FLAGS	2		/* by flags, e.g. RESOLVING */
 NET_RT_FLAGS	= 2		/* by flags, e.g. RESOLVING */
//#define NET_RT_IFLIST	3		/* survey interface list */
 NET_RT_IFLIST	= 3		/* survey interface list */
//#define	NET_RT_MAXID	4
	NET_RT_MAXID	= 4
//
//#define CTL_NET_RT_NAMES { \
//	{ 0, 0 }, \
//	{ "dump", CTLTYPE_STRUCT }, \
//	{ "flags", CTLTYPE_STRUCT }, \
//	{ "iflist", CTLTYPE_STRUCT }, \
//}
//
///*
// * Maximum queue length specifiable by listen.
// */
	SOMAXCONN	= 128
//
///*
// * Maximum setsockopt buffer size
// */
//#define SOMAXOPT_SIZE	65536
//
///*
// * Message header for recvmsg and sendmsg calls.
// * Used value-result for recvmsg, value only for sendmsg.
// */
//struct msghdr {
//	void		*msg_name;		/* optional address */
//	socklen_t	 msg_namelen;		/* size of address */
//	struct iovec	*msg_iov;		/* scatter/gather array */
//	int		 msg_iovlen;		/* # elements in msg_iov */
//	void		*msg_control;		/* ancillary data, see below */
//	socklen_t	 msg_controllen;	/* ancillary data buffer len */
//	int		 msg_flags;		/* flags on received message */
//};
//
//#define	MSG_OOB		0x00000001	/* process out-of-band data */
//#define	MSG_PEEK	0x00000002	/* peek at incoming message */
//#define	MSG_DONTROUTE	0x00000004	/* send without using routing tables */
//#define	MSG_EOR		0x00000008	/* data completes record */
//#define	MSG_TRUNC	0x00000010	/* data discarded before delivery */
//#define	MSG_CTRUNC	0x00000020	/* control data lost before delivery */
//#define	MSG_WAITALL	0x00000040	/* wait for full request or error */
//#define	MSG_DONTWAIT	0x00000080	/* this message should be nonblocking */
//#define	MSG_EOF		0x00000100	/* data completes connection */
//#define	MSG_NOTIFICATION 0x00000200	/* notification message */
//#define	MSG_NOSIGNAL	0x00000400	/* No SIGPIPE to unconnected socket stream */
//#define	MSG_SYNC	0x00000800	/* No asynchronized pru_send */
//
///*
// * These override FIONBIO.  MSG_FNONBLOCKING is functionally equivalent to
// * MSG_DONTWAIT.
// */
//#define MSG_FBLOCKING	0x00010000	/* force blocking operation */
//#define MSG_FNONBLOCKING 0x00020000	/* force non-blocking operation */
//
//#define MSG_FMASK	0xFFFF0000	/* force mask */
//
///*
// * Header for ancillary data objects in msg_control buffer.
// * Used for additional information with/about a datagram
// * not expressible by flags.  The format is a sequence
// * of message elements headed by cmsghdr structures.
// */
//struct cmsghdr {
//	socklen_t	cmsg_len;		/* data byte count, including hdr */
//	int		cmsg_level;		/* originating protocol */
//	int		cmsg_type;		/* protocol-specific type */
///* followed by	u_char  cmsg_data[]; */
//};
//
///*
// * While we may have more groups than this, the cmsgcred struct must
// * be able to fit in an mbuf, and NGROUPS_MAX is too large to allow
// * this.
//*/
//#define CMGROUP_MAX 16
//
///*
// * Credentials structure, used to verify the identity of a peer
// * process that has sent us a message. This is allocated by the
// * peer process but filled in by the kernel. This prevents the
// * peer from lying about its identity. (Note that cmcred_groups[0]
// * is the effective GID.)
// */
//struct cmsgcred {
//	pid_t	cmcred_pid;		/* PID of sending process */
//	uid_t	cmcred_uid;		/* real UID of sending process */
//	uid_t	cmcred_euid;		/* effective UID of sending process */
//	gid_t	cmcred_gid;		/* real GID of sending process */
//	short	cmcred_ngroups;		/* number or groups */
//	gid_t	cmcred_groups[CMGROUP_MAX];	/* groups */
//};
//
///* Alignment requirement for CMSG struct manipulation */
//#define _CMSG_ALIGN(n)		(((n) + 3) & ~3)
//
//#ifdef _KERNEL
//#define CMSG_ALIGN(n)		_CMSG_ALIGN(n)
//#endif
//
///* given pointer to struct cmsghdr, return pointer to data */
//#define	CMSG_DATA(cmsg)		((unsigned char *)(cmsg) + \
//				 _CMSG_ALIGN(sizeof(struct cmsghdr)))
//
///* given pointer to struct cmsghdr, return pointer to next cmsghdr */
//#define	CMSG_NXTHDR(mhdr, cmsg)	\
//	(((caddr_t)(cmsg) + _CMSG_ALIGN((cmsg)->cmsg_len) + \
//	  _CMSG_ALIGN(sizeof(struct cmsghdr)) > \
//	    (caddr_t)(mhdr)->msg_control + (mhdr)->msg_controllen) ? \
//	    NULL : \
//	    (struct cmsghdr *)((caddr_t)(cmsg) + _CMSG_ALIGN((cmsg)->cmsg_len)))
//
///*
// * RFC 2292 requires to check msg_controllen, in case that the kernel returns
// * an empty list for some reasons.
// */
//#define	CMSG_FIRSTHDR(mhdr) \
//	((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \
//	 (struct cmsghdr *)(mhdr)->msg_control : \
//	 NULL)
//
///* RFC 2292 additions */
//	
//#define	CMSG_SPACE(l)		(_CMSG_ALIGN(sizeof(struct cmsghdr)) + _CMSG_ALIGN(l))
//#define	CMSG_LEN(l)		(_CMSG_ALIGN(sizeof(struct cmsghdr)) + (l))
//
///* "Socket"-level control message types: */
//#define	SCM_RIGHTS	0x01		/* access rights (array of int) */
//#define	SCM_TIMESTAMP	0x02		/* timestamp (struct timeval) */
//#define	SCM_CREDS	0x03		/* process creds (struct cmsgcred) */
//
///*
// * howto arguments for shutdown(2), specified by Posix.1g.
// */
//#define	SHUT_RD		0		/* shut down the reading side */
	SHUT_RD		= 0		/* shut down the reading side */
//#define	SHUT_WR		1		/* shut down the writing side */
	SHUT_WR		= 1		/* shut down the writing side */
//#define	SHUT_RDWR	2		/* shut down both sides */
	SHUT_RDWR	= 2		/* shut down both sides */
//
///*
// * sendfile(2) header/trailer struct
// */
//struct sf_hdtr {
//	struct iovec *headers;	/* pointer to an array of header struct iovec's */
//	int hdr_cnt;		/* number of header iovec's */
//	struct iovec *trailers;	/* pointer to an array of trailer struct iovec's */
//	int trl_cnt;		/* number of trailer iovec's */
//};
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//
//#ifndef _SYS_CDEFS_H_
//#include <sys/cdefs.h>
//#endif
//
//__BEGIN_DECLS
//int	accept (int, struct sockaddr *, socklen_t *);
//int	extaccept (int, int, struct sockaddr *, socklen_t *);
//int	bind (int, const struct sockaddr *, socklen_t);
//int	connect (int, const struct sockaddr *, socklen_t);
//int	extconnect (int, int, struct sockaddr *, socklen_t);
//int	getpeername (int, struct sockaddr *, socklen_t *);
//int	getsockname (int, struct sockaddr *, socklen_t *);
//int	getsockopt (int, int, int, void *, socklen_t *);
//int	listen (int, int);
//ssize_t	recv (int, void *, size_t, int);
//ssize_t	recvfrom (int, void *, size_t, int, struct sockaddr *, socklen_t *);
//ssize_t	recvmsg (int, struct msghdr *, int);
//ssize_t	send (int, const void *, size_t, int);
//ssize_t	sendto (int, const void *,
//	    size_t, int, const struct sockaddr *, socklen_t);
//ssize_t	sendmsg (int, const struct msghdr *, int);
//int	sendfile (int, int, off_t, size_t, struct sf_hdtr *, off_t *, int);
//int	setsockopt (int, int, int, const void *, socklen_t);
//int	shutdown (int, int);
//int	sockatmark(int);
//int	socketpair (int, int, int, int *);
//
//void	pfctlinput (int, struct sockaddr *);
//__END_DECLS
//
//#endif /* !_KERNEL */
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//#ifndef _SYS_CDEFS_H_
//#include <sys/cdefs.h>
//#endif
//
//__BEGIN_DECLS
//int	socket (int, int, int);
//__END_DECLS
//#endif	/* !_KERNEL || _KERNEL_VIRTUAL */
//
//#endif /* !_SYS_SOCKET_H_ */

// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/net/route.h

///*
// * Copyright (c) 2004, 2005 The DragonFly Project.  All rights reserved.
// *
// * This code is derived from software contributed to The DragonFly Project
// * by Jeffrey M. Hsu.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. Neither the name of The DragonFly Project nor the names of its
// *    contributors may be used to endorse or promote products derived
// *    from this software without specific, prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
// * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
// * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
// * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
// * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// */
//
///*
// * Copyright (c) 1980, 1986, 1993
// *	The Regents of the University of California.  All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)route.h	8.4 (Berkeley) 1/9/95
// * $FreeBSD: src/sys/net/route.h,v 1.36.2.5 2002/02/01 11:48:01 ru Exp $
// * $DragonFly: src/sys/net/route.h,v 1.24 2008/09/11 11:23:29 sephe Exp $
// */
//
//#ifndef _NET_ROUTE_H_
//#define _NET_ROUTE_H_
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#ifndef _SYS_PARAM_H_
//#include <sys/param.h>
//#endif
//#ifndef _SYS_SOCKET_H_
//#include <sys/socket.h>
//#endif
//
///*
// * Kernel resident routing tables.
// *
// * The routing tables are initialized when interface addresses
// * are set by making entries for all directly connected interfaces.
// */
//
///*
// * A route consists of a destination address and a reference
// * to a routing entry.  These are often held by protocols
// * in their control blocks, e.g. inpcb.
// */
//struct route {
//	struct	rtentry *ro_rt;
//	struct	sockaddr ro_dst;
//};
//
///*
// * These numbers are used by reliable protocols for determining
// * retransmission behavior and are included in the routing structure.
// */
//struct rt_metrics {	/* grouped for locality of reference */
//	u_long	rmx_locks;	/* Kernel must leave these values alone */
//	u_long	rmx_mtu;	/* MTU for this path */
//	u_long	rmx_pksent;	/* packets sent using this route */
//	u_long	rmx_expire;	/* lifetime for route */
//
//	u_long	rmx_sendpipe;	/* outbound delay-bandwidth product */
//	u_long	rmx_ssthresh;	/* outbound gateway buffer limit */
//	u_long	rmx_rtt;	/* estimated round trip time */
//	u_long	rmx_rttvar;	/* estimated rtt variance */
//
//	u_long	rmx_recvpipe;	/* inbound delay-bandwidth product */
//	u_long	rmx_hopcount;	/* max hops expected */
//	u_short rmx_mssopt;	/* peer's cached MSS */
//	u_short	rmx_pad;	/* explicit pad */
//	u_long	rmx_msl;	/* maximum segment lifetime, unit: ms */
//	u_long	rmx_iwmaxsegs;	/* IW segments max */
//	u_long	rmx_iwcapsegs;	/* IW segments */
//};
//
///*
// * rmx_rtt and rmx_rttvar are stored as microseconds;
// * RTTTOPRHZ(rtt) converts to a value suitable for use
// * by a protocol slowtimo counter.
// */
//#define	RTM_RTTUNIT	1000000	/* units for rtt, rttvar, as units per sec */
//#define	RTTTOPRHZ(r)	((r) / (RTM_RTTUNIT / PR_SLOWHZ))
//
///*
// * XXX kernel function pointer `rt_output' is visible to applications.
// */
//struct mbuf;
//
///*
// * We distinguish between routes to hosts and routes to networks,
// * preferring the former if available.  For each route we infer
// * the interface to use from the gateway address supplied when
// * the route was entered.  Routes that forward packets through
// * gateways are marked so that the output routines know to address the
// * gateway rather than the ultimate destination.
// */
//#ifndef RNF_NORMAL
//#include <net/radix.h>
//#endif
//
//struct rtentry {
//	struct	radix_node rt_nodes[2];	/* tree glue, and other values */
//#define	rt_key(r)	((struct sockaddr *)((r)->rt_nodes->rn_key))
//#define	rt_mask(r)	((struct sockaddr *)((r)->rt_nodes->rn_mask))
//	struct	sockaddr *rt_gateway;	/* value */
//	long	rt_refcnt;		/* # held references */
//	u_long	rt_flags;		/* up/down?, host/net */
//	struct	ifnet *rt_ifp;		/* the answer: interface to use */
//	struct	ifaddr *rt_ifa;		/* the answer: interface to use */
//	struct	sockaddr *rt_genmask;	/* for generation of cloned routes */
//	void	*rt_llinfo;		/* pointer to link level info cache */
//	struct	rt_metrics rt_rmx;	/* metrics used by rx'ing protocols */
//	struct	rtentry *rt_gwroute;	/* implied entry for gatewayed routes */
//	int	(*rt_output) (struct ifnet *, struct mbuf *, struct sockaddr *,
//			      struct rtentry *);
//					/* output routine for this (rt,if) */
//	struct	rtentry *rt_parent;	/* cloning parent of this route */
//	int	rt_cpuid;		/* owner cpu */
//	struct	sockaddr *rt_shim[3];	/* mpls label / operation array */
//};
//
///*
// * Following structure necessary for 4.3 compatibility;
// * We should eventually move it to a compat file.
// */
//struct ortentry {
//	u_long	rt_hash;		/* to speed lookups */
//	struct	sockaddr rt_dst;	/* key */
//	struct	sockaddr rt_gateway;	/* value */
//	short	rt_flags;		/* up/down?, host/net */
//	short	rt_refcnt;		/* # held references */
//	u_long	rt_use;			/* raw # packets forwarded */
//	struct	ifnet *rt_ifp;		/* the answer: interface to use */
//};
//
//#define rt_use rt_rmx.rmx_pksent
//
//#define	RTF_UP		0x1		/* route usable */
//#define	RTF_GATEWAY	0x2		/* destination is a gateway */
//#define	RTF_HOST	0x4		/* host entry (net otherwise) */
//#define	RTF_REJECT	0x8		/* host or net unreachable */
//#define	RTF_DYNAMIC	0x10		/* created dynamically (by redirect) */
//#define	RTF_MODIFIED	0x20		/* modified dynamically (by redirect) */
//#define RTF_DONE	0x40		/* message confirmed */
///*			0x80		   unused, was RTF_DELCLONE */
//#define RTF_CLONING	0x100		/* generate new routes on use */
//#define RTF_XRESOLVE	0x200		/* external daemon resolves name */
//#define RTF_LLINFO	0x400		/* generated by link layer (e.g. ARP) */
//#define RTF_STATIC	0x800		/* manually added */
//#define RTF_BLACKHOLE	0x1000		/* just discard pkts (during updates) */
//#define RTF_PROTO2	0x4000		/* protocol specific routing flag */
//#define RTF_PROTO1	0x8000		/* protocol specific routing flag */
//
//#define RTF_PRCLONING	0x10000		/* protocol requires cloning */
//#define RTF_WASCLONED	0x20000		/* route generated through cloning */
//#define RTF_PROTO3	0x40000		/* protocol specific routing flag */
///*			0x80000		   unused */
//#define RTF_PINNED	0x100000	/* future use */
//#define	RTF_LOCAL	0x200000	/* route represents a local address */
//#define	RTF_BROADCAST	0x400000	/* route represents a bcast address */
//#define	RTF_MULTICAST	0x800000	/* route represents a mcast address */
//#define	RTF_MPLSOPS	0x1000000	/* route uses mpls label operations */
//					/* 0x2000000 and up unassigned */
//
///*
// * Routing statistics.
// */
//struct	rtstatistics {
//	u_long	rts_badredirect;	/* bogus redirect calls */
//	u_long	rts_dynamic;		/* routes created by redirects */
//	u_long	rts_newgateway;		/* routes modified by redirects */
//	u_long	rts_unreach;		/* lookups which failed */
//	u_long	rts_wildcard;		/* lookups satisfied by a wildcard */
//};
///*
// * Structures for routing messages.
// */
//struct rt_msghdr {
//	u_short	rtm_msglen;	/* to skip over non-understood messages */
//	u_char	rtm_version;	/* future binary compatibility */
//	u_char	rtm_type;	/* message type */
//	u_short	rtm_index;	/* index for associated ifp */
//	int	rtm_flags;	/* flags, incl. kern & message, e.g. DONE */
//	int	rtm_addrs;	/* bitmask identifying sockaddrs in msg */
//	pid_t	rtm_pid;	/* identify sender */
//	int	rtm_seq;	/* for sender to identify action */
//	int	rtm_errno;	/* why failed */
//	int	rtm_use;	/* from rtentry */
//	u_long	rtm_inits;	/* which metrics we are initializing */
//	struct	rt_metrics rtm_rmx; /* metrics themselves */
//};
//
 RTM_VERSION	= 6	/* Up the ante and ignore older versions */
//
///*
// * Message types.
// */
 RTM_ADD		= 0x1	/* Add Route */
 RTM_DELETE	= 0x2	/* Delete Route */
 RTM_CHANGE	= 0x3	/* Change Metrics or flags */
 RTM_GET		= 0x4	/* Report Metrics */
 RTM_LOSING	= 0x5	/* Kernel Suspects Partitioning */
 RTM_REDIRECT	= 0x6	/* Told to use different route */
 RTM_MISS	= 0x7	/* Lookup failed on this address */
 RTM_LOCK	= 0x8	/* fix specified metrics */
 RTM_OLDADD	= 0x9	/* caused by SIOCADDRT */
 RTM_OLDDEL	= 0xa	/* caused by SIOCDELRT */
 RTM_RESOLVE	= 0xb	/* req to resolve dst to LL addr */
 RTM_NEWADDR	= 0xc	/* address being added to iface */
 RTM_DELADDR	= 0xd	/* address being removed from iface */
 RTM_IFINFO	= 0xe	/* iface going up/down etc. */
	RTM_NEWMADDR	= 0xf	/* mcast group membership being added to if */
	RTM_DELMADDR	= 0x10	/* mcast group membership being deleted */
	RTM_IFANNOUNCE	= 0x11	/* iface arrival/departure */
	RTM_IEEE80211	= 0x12	/* IEEE80211 wireless event */
//
///*
// * Bitmask values for rtm_inits and rmx_locks.
// */
//#define RTV_MTU		0x1	/* init or lock _mtu */
//#define RTV_HOPCOUNT	0x2	/* init or lock _hopcount */
//#define RTV_EXPIRE	0x4	/* init or lock _expire */
//#define RTV_RPIPE	0x8	/* init or lock _recvpipe */
//#define RTV_SPIPE	0x10	/* init or lock _sendpipe */
//#define RTV_SSTHRESH	0x20	/* init or lock _ssthresh */
//#define RTV_RTT		0x40	/* init or lock _rtt */
//#define RTV_RTTVAR	0x80	/* init or lock _rttvar */
//#define RTV_MSL		0x100	/* init or lock _msl */
//#define RTV_IWMAXSEGS	0x200	/* init or lock _iwmaxsegs */
//#define RTV_IWCAPSEGS	0x400	/* init or lock _iwcapsegs */
//
///*
// * Bitmask values for rtm_addrs.
// */
 RTA_DST		= 0x1	/* destination sockaddr present */
 RTA_GATEWAY	= 0x2	/* gateway sockaddr present */
 RTA_NETMASK	= 0x4	/* netmask sockaddr present */
 RTA_GENMASK	= 0x8	/* cloning mask sockaddr present */
 RTA_IFP		= 0x10	/* interface name sockaddr present */
 RTA_IFA		= 0x20	/* interface addr sockaddr present */
 RTA_AUTHOR	= 0x40	/* sockaddr for author of redirect */
 RTA_BRD		= 0x80	/* for NEWADDR, broadcast or p-p dest addr */
 RTA_MPLS1	= 0x100	/* mpls label and/or operation present */
 RTA_MPLS2	= 0x200	/* mpls label and/or operation present */
 RTA_MPLS3	= 0x400	/* mpls label and/or operation present */
//
///*
// * Index offsets for sockaddr array for alternate internal encoding.
// */
 RTAX_DST	= 0	/* destination sockaddr present */
 RTAX_GATEWAY	= 1	/* gateway sockaddr present */
 RTAX_NETMASK	= 2	/* netmask sockaddr present */
 RTAX_GENMASK	= 3	/* cloning mask sockaddr present */
 RTAX_IFP	= 4	/* interface name sockaddr present */
 RTAX_IFA	= 5	/* interface addr sockaddr present */
 RTAX_AUTHOR	= 6	/* sockaddr for author of redirect */
 RTAX_BRD	= 7	/* for NEWADDR, broadcast or p-p dest addr */
 RTAX_MPLS1	= 8	/* mpls label and/or operation present */
 RTAX_MPLS2	= 9	/* mpls label and/or operation present */
 RTAX_MPLS3	= 10	/* mpls label and/or operation present */
 RTAX_MAX	= 11	/* size of array to allocate */
//
//struct rt_addrinfo {
//	int		 rti_addrs;
//	struct sockaddr	*rti_info[RTAX_MAX];
//	int		 rti_flags;
//	struct ifaddr	*rti_ifa;
//	struct ifnet	*rti_ifp;
//};
//
//#ifdef _KERNEL
//
//#define	rti_dst		rti_info[RTAX_DST]
//#define	rti_gateway	rti_info[RTAX_GATEWAY]
//#define	rti_netmask	rti_info[RTAX_NETMASK]
//#define	rti_genmask	rti_info[RTAX_GENMASK]
//#define	rti_ifpaddr	rti_info[RTAX_IFP]
//#define	rti_ifaaddr	rti_info[RTAX_IFA]
//#define	rti_author	rti_info[RTAX_AUTHOR]
//#define	rti_bcastaddr	rti_info[RTAX_BRD]
//#define	rti_mpls1	rti_info[RTAX_MPLS1]
//#define	rti_mpls2	rti_info[RTAX_MPLS2]
//#define	rti_mpls3	rti_info[RTAX_MPLS3]
//
//extern struct radix_node_head *rt_tables[MAXCPU][AF_MAX+1];
//
//struct ifmultiaddr;
//struct proc;
//struct ucred;
//
//void	 route_init (void);
//void	 rt_dstmsg(int type, struct sockaddr *dst, int error);
//int	 rt_getifa (struct rt_addrinfo *);
//void	 rt_ieee80211msg(struct ifnet *, int, void *, size_t);
//void	 rt_ifannouncemsg (struct ifnet *, int);
//void	 rt_ifmsg (struct ifnet *);
//int	 rt_llroute (struct sockaddr *dst, struct rtentry *rt0,
//	    struct rtentry **drt);
//void	 rt_missmsg (int, struct rt_addrinfo *, int, int);
//void	 rt_newaddrmsg (int, struct ifaddr *, int, struct rtentry *);
//void	 rt_newmaddrmsg (int, struct ifmultiaddr *);
//void	 rt_rtmsg(int cmd, struct rtentry *rt, struct ifnet *ifp, int error);
//int	 rt_setgate (struct rtentry *,
//	    struct sockaddr *, struct sockaddr *, boolean_t);
//void	 rtalloc (struct route *);
//void	 rtalloc_ign (struct route *, u_long);
//
//struct rtentry *
//	 _rtlookup (struct sockaddr *, __boolean_t, u_long);
//#define		RTL_REPORTMSG	TRUE
//#define		RTL_DONTREPORT	FALSE
//
///* flags to ignore */
//#define		RTL_DOCLONE	0UL
//#define		RTL_DONTCLONE	(RTF_CLONING | RTF_PRCLONING)
//
///*
// * Look up a route with no cloning side-effects or miss reports generated.
// */
//static __inline struct rtentry *
//rtpurelookup(struct sockaddr *dst)
//{
//	return _rtlookup(dst, RTL_DONTREPORT, RTL_DONTCLONE);
//}
//
///*
// * Do full route lookup with cloning and reporting on misses.
// */
//static __inline struct rtentry *
//rtlookup(struct sockaddr *dst)
//{
//	return _rtlookup(dst, RTL_REPORTMSG, RTL_DOCLONE);
//}
//
//typedef void (*rtrequest1_callback_func_t)(int, int, struct rt_addrinfo *,
//				      struct rtentry *, void *);
//typedef int (*rtsearch_callback_func_t)(int, struct rt_addrinfo *,
//					struct rtentry *, void *, int);
//
//void	 rtfree (struct rtentry *);
//int	 rtinit (struct ifaddr *, int, int);
//int	 rtchange (struct ifaddr *, struct ifaddr *);
//int	 rtioctl (u_long, caddr_t, struct ucred *);
//void	 rtredirect (struct sockaddr *, struct sockaddr *,
//	    struct sockaddr *, int, struct sockaddr *);
//int	 rtrequest (int, struct sockaddr *,
//	    struct sockaddr *, struct sockaddr *, int, struct rtentry **);
//int	 rtrequest_global (int, struct sockaddr *,
//	    struct sockaddr *, struct sockaddr *, int);
//int	 rtrequest1 (int, struct rt_addrinfo *, struct rtentry **);
//int	 rtrequest1_global (int, struct rt_addrinfo *,
//	    rtrequest1_callback_func_t, void *, boolean_t);
//
//#define RTS_EXACTMATCH		TRUE
//#define RTS_NOEXACTMATCH	FALSE
//
//#define RTREQ_PRIO_HIGH		TRUE
//#define RTREQ_PRIO_NORM		FALSE
//
//int	 rtsearch_global(int, struct rt_addrinfo *,
//	    rtsearch_callback_func_t, void *, boolean_t, boolean_t);
//
//int	 rtmask_add_global(struct sockaddr *, boolean_t);
//
//struct sockaddr *_rtmask_lookup(struct sockaddr *, boolean_t);
//
//static __inline struct sockaddr *
//rtmask_lookup(struct sockaddr *_mask)
//{
//	return _rtmask_lookup(_mask, FALSE);
//}
//
//static __inline struct sockaddr *
//rtmask_purelookup(struct sockaddr *_mask)
//{
//	return _rtmask_lookup(_mask, TRUE);
//}
//
//void	rtfree_oncpu(struct rtentry *);
//void	rtfree_remote(struct rtentry *);
//void	rt_print(struct rt_addrinfo *, struct rtentry *);
//void	rt_addrinfo_print(int cmd, struct rt_addrinfo *);
//void	sockaddr_print(struct sockaddr *);
//
//struct netmsg_base;
//int	rt_domsg_global(struct netmsg_base *);
//
//#ifndef _SYS_GLOBALDATA_H_
//#include <sys/globaldata.h>
//#endif
//
//static __inline void
//RTFREE(struct rtentry *rt)
//{
//	if (rt->rt_cpuid == mycpuid) {
//		if (rt->rt_refcnt <= 1)
//			rtfree_oncpu(rt);
//		else
//			--rt->rt_refcnt;
//	} else {
//		rtfree_remote(rt);
//	}
//}
//
//int	in_inithead(void **, int);
//#endif
//
//#endif


// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/net/if.h

///*
// * Copyright (c) 1982, 1986, 1989, 1993
// *	The Regents of the University of California.  All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)if.h	8.1 (Berkeley) 6/10/93
// * $FreeBSD: src/sys/net/if.h,v 1.58.2.9 2002/08/30 14:23:38 sobomax Exp $
// */
//
//#ifndef _NET_IF_H_
//#define	_NET_IF_H_
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#ifndef _SYS_TIME_H_
//#include <sys/time.h>
//#endif
//#ifndef _SYS_SOCKET_H_
//#include <sys/socket.h>
//#endif
//
//#ifdef _KERNEL
//
//#ifndef _SYS_QUEUE_H_
//#include <sys/queue.h>
//#endif
//
//#endif
//
///*
// * Values for if_link_state.
// */
//#define	LINK_STATE_UNKNOWN	0	/* link invalid/unknown */
//#define	LINK_STATE_DOWN		1	/* link is down */
//#define	LINK_STATE_UP		2	/* link is up */
//#define	LINK_STATE_IS_UP(_s)	((_s) >= LINK_STATE_UP)
//
//struct ifnet;
//
///*
// * Length of interface external name, including terminating '\0'.
// * Note: this is the same size as a generic device's external name.
// */
		IFNAMSIZ	= 16
		IF_NAMESIZE	= IFNAMSIZ
		IF_MAXUNIT	= 0x7fff		/* if_unit is 15bits */
//
///*
// * Structure used to query names of interface cloners.
// * XXX should be moved to net/if_clone.h
// */
//struct if_clonereq {
//	int	ifcr_total;		/* total cloners (out) */
//	int	ifcr_count;		/* room for this many in user buffer */
//	char	*ifcr_buffer;		/* buffer for cloner names */
//};
//
///*
// * Structure describing information about an interface
// * which may be of interest to management entities.
// */
//struct if_data {
//	/* generic interface information */
//	u_char	ifi_type;		/* ethernet, tokenring, etc */
//	u_char	ifi_physical;		/* e.g., AUI, Thinnet, 10base-T, etc */
//	u_char	ifi_addrlen;		/* media address length */
//	u_char	ifi_hdrlen;		/* media header length */
//	u_char	ifi_recvquota;		/* polling quota for receive intrs */
//	u_char	ifi_xmitquota;		/* polling quota for xmit intrs */
//	u_long	ifi_mtu;		/* maximum transmission unit */
//	u_long	ifi_metric;		/* routing metric (external only) */
//	u_long  ifi_link_state;		/* current link state */
//	uint64_t ifi_baudrate;		/* linespeed */
//	/* volatile statistics */
//	u_long	ifi_ipackets;		/* packets received on interface */
//	u_long	ifi_ierrors;		/* input errors on interface */
//	u_long	ifi_opackets;		/* packets sent on interface */
//	u_long	ifi_oerrors;		/* output errors on interface */
//	u_long	ifi_collisions;		/* collisions on csma interfaces */
//	u_long	ifi_ibytes;		/* total number of octets received */
//	u_long	ifi_obytes;		/* total number of octets sent */
//	u_long	ifi_imcasts;		/* packets received via multicast */
//	u_long	ifi_omcasts;		/* packets sent via multicast */
//	u_long	ifi_iqdrops;		/* dropped on input, this interface */
//	u_long	ifi_noproto;		/* destined for unsupported protocol */
//	u_long	ifi_hwassist;		/* HW offload capabilities */
//	u_long	ifi_unused;		/* XXX was ifi_xmittiming */
//	struct	timeval ifi_lastchange;	/* time of last administrative change */
//};
//
	IFF_UP		= 0x1		/* interface is up */
	IFF_BROADCAST	= 0x2		/* broadcast address valid */
	IFF_DEBUG	= 0x4		/* turn on debugging */
	IFF_LOOPBACK	= 0x8		/* is a loopback net */
	IFF_POINTOPOINT	= 0x10		/* interface is point-to-point link */
	IFF_SMART	= 0x20		/* interface manages own routes */
	IFF_RUNNING	= 0x40		/* resources allocated */
	IFF_NOARP	= 0x80		/* no address resolution protocol */
	IFF_PROMISC	= 0x100		/* receive all packets */
	IFF_ALLMULTI	= 0x200		/* receive all multicast packets */
	IFF_OACTIVE_COMPAT = 0x400	/* was transmission in progress */
	IFF_SIMPLEX	= 0x800		/* can't hear own transmissions */
	IFF_LINK0	= 0x1000		/* per link layer defined bit */
	IFF_LINK1	= 0x2000		/* per link layer defined bit */
	IFF_LINK2	= 0x4000		/* per link layer defined bit */
	IFF_ALTPHYS	= IFF_LINK2	/* use alternate physical connection */
	IFF_MULTICAST	= 0x8000		/* supports multicast */
	IFF_POLLING_COMPAT = 0x10000	/* was interface is in polling mode */
	IFF_PPROMISC	= 0x20000		/* user-requested promisc mode */
	IFF_MONITOR	= 0x40000		/* user-requested monitor mode */
 IFF_STATICARP	= 0x80000		/* static ARP */
 IFF_NPOLLING	= 0x100000	/* interface is in polling mode */
//
///* flags set internally only: */
//#define	IFF_CANTCHANGE \
//	(IFF_BROADCAST|IFF_POINTOPOINT|IFF_RUNNING|IFF_OACTIVE_COMPAT|\
//	 IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI|IFF_SMART|IFF_POLLING_COMPAT|\
//	 IFF_NPOLLING)
//
//#ifndef _KERNEL
///*
// * User space compat
// */
//#define IFF_OACTIVE	IFF_OACTIVE_COMPAT
//#define IFF_POLLING	IFF_POLLING_COMPAT
//#endif
//
///*
// * Some convenience macros used for setting ifi_baudrate.
// * XXX 1000 vs. 1024? --thorpej@netbsd.org
// */
//#define	IF_Kbps(x)	((x) * 1000)		/* kilobits/sec. */
//#define	IF_Mbps(x)	(IF_Kbps((x) * 1000))	/* megabits/sec. */
//#define	IF_Gbps(x)	(IF_Mbps((x) * 1000))	/* gigabits/sec. */
//
///* Capabilities that interfaces can advertise. */
//#define IFCAP_RXCSUM		0x00001 /* can offload checksum on RX */
//#define IFCAP_TXCSUM		0x00002 /* can offload checksum on TX */
//#define IFCAP_NETCONS		0x00004 /* can be a network console */
//#define IFCAP_VLAN_MTU		0x00008	/* VLAN-compatible MTU */
//#define IFCAP_VLAN_HWTAGGING	0x00010	/* hardware VLAN tag support */
//#define IFCAP_JUMBO_MTU		0x00020	/* 9000 byte MTU support */
//#define IFCAP_RSS		0x00040	/* Receive Side Scaling for IPv4 */
//#define IFCAP_VLAN_HWCSUM	0x00080	/* can do IFCAP_HWCSUM on VLANs */
//#define IFCAP_TSO4		0x00100	/* can offload TCP segmentation */
//#define IFCAP_TSO		IFCAP_TSO4
//#define IFCAP_TSO6		0x00200	/* can offload TCP6 segmentation */
//
//#define IFCAP_HWCSUM	(IFCAP_RXCSUM | IFCAP_TXCSUM)
//
//
//#define	IFQ_MAXLEN	250
//#define	IFNET_SLOWHZ	1		/* granularity is 1 second */
//
///*
// * Message format for use in obtaining information about interfaces
// * from getkerninfo and the routing socket
// */
//struct if_msghdr {
//	u_short	ifm_msglen;	/* to skip over non-understood messages */
//	u_char	ifm_version;	/* future binary compatibility */
//	u_char	ifm_type;	/* message type */
//	int	ifm_addrs;	/* like rtm_addrs */
//	int	ifm_flags;	/* value of if_flags */
//	u_short	ifm_index;	/* index for associated ifp */
//	struct	if_data ifm_data;/* statistics and other data about if */
//};
//
///*
// * Message format for use in obtaining information about interface addresses
// * from getkerninfo and the routing socket
// */
//struct ifa_msghdr {
//	u_short	ifam_msglen;	/* to skip over non-understood messages */
//	u_char	ifam_version;	/* future binary compatibility */
//	u_char	ifam_type;	/* message type */
//	int	ifam_addrs;	/* like rtm_addrs */
//	int	ifam_flags;	/* value of ifa_flags */
//	u_short	ifam_index;	/* index for associated ifp */
//	int	ifam_metric;	/* value of ifa_metric */
//};
//
///*
// * Message format for use in obtaining information about multicast addresses
// * from the routing socket
// */
//struct ifma_msghdr {
//	u_short	ifmam_msglen;	/* to skip over non-understood messages */
//	u_char	ifmam_version;	/* future binary compatibility */
//	u_char	ifmam_type;	/* message type */
//	int	ifmam_addrs;	/* like rtm_addrs */
//	int	ifmam_flags;	/* value of ifa_flags */
//	u_short	ifmam_index;	/* index for associated ifp */
//};
//
///*
// * Message format announcing the arrival or departure of a network interface.
// */
//struct if_announcemsghdr {
//	u_short	ifan_msglen;	/* to skip over non-understood messages */
//	u_char	ifan_version;	/* future binary compatibility */
//	u_char	ifan_type;	/* message type */
//	u_short	ifan_index;	/* index for associated ifp */
//	char	ifan_name[IFNAMSIZ]; /* if name, e.g. "en0" */
//	u_short	ifan_what;	/* what type of announcement */
//};
//
//#define	IFAN_ARRIVAL	0	/* interface arrival */
//#define	IFAN_DEPARTURE	1	/* interface departure */
//
///*
// * Interface request structure used for socket
// * ioctl's.  All interface ioctl's must have parameter
// * definitions which begin with ifr_name.  The
// * remainder may be interface specific.
// */
//struct	ifreq {
//	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
//	union {
//		struct	sockaddr ifru_addr;
//		struct	sockaddr ifru_dstaddr;
//		struct	sockaddr ifru_broadaddr;
//		short	ifru_flags[2];
//		short	ifru_index;
//		int	ifru_metric;
//		int	ifru_mtu;
//		int	ifru_phys;
//		int	ifru_media;
//		void   *ifru_data;
//		int	ifru_cap[2];
//		int	ifru_pollcpu;
//		int	ifru_tsolen;
//	} ifr_ifru;
//#define	ifr_addr	ifr_ifru.ifru_addr	/* address */
//#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */
//#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
//#define	ifr_flags	ifr_ifru.ifru_flags[0]	/* flags (low 16 bits) */
//#define	ifr_flagshigh	ifr_ifru.ifru_flags[1]	/* flags (high 16 bits) */
//#define	ifr_metric	ifr_ifru.ifru_metric	/* metric */
//#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu */
//#define ifr_phys	ifr_ifru.ifru_phys	/* physical wire */
//#define ifr_media	ifr_ifru.ifru_media	/* physical media */
//#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface */
//#define	ifr_reqcap	ifr_ifru.ifru_cap[0]	/* requested capabilities */
//#define	ifr_curcap	ifr_ifru.ifru_cap[1]	/* current capabilities */
//#define	ifr_index	ifr_ifru.ifru_index	/* interface index */
//#define ifr_pollcpu	ifr_ifru.ifru_pollcpu	/* deprecated */
//#define ifr_tsolen	ifr_ifru.ifru_tsolen	/* max TSO length */
//};
//
//#define	_SIZEOF_ADDR_IFREQ(ifr) \
//	((ifr).ifr_addr.sa_len > sizeof(struct sockaddr) ? \
//	 (sizeof(struct ifreq) - sizeof(struct sockaddr) + \
//	  (ifr).ifr_addr.sa_len) : sizeof(struct ifreq))
//
//struct ifaliasreq {
//	char	ifra_name[IFNAMSIZ];		/* if name, e.g. "en0" */
//	struct	sockaddr ifra_addr;
//	struct	sockaddr ifra_broadaddr;
//	struct	sockaddr ifra_mask;
//};
//
//struct ifmediareq {
//	char	ifm_name[IFNAMSIZ];	/* if name, e.g. "en0" */
//	int	ifm_current;		/* current media options */
//	int	ifm_mask;		/* don't care mask */
//	int	ifm_status;		/* media status */
//	int	ifm_active;		/* active options */
//	int	ifm_count;		/* # entries in ifm_ulist array */
//	int	*ifm_ulist;		/* media words */
//};
//
//struct  ifdrv {
//	char            ifd_name[IFNAMSIZ];     /* if name, e.g. "en0" */
//	unsigned long   ifd_cmd;
//	size_t          ifd_len;
//	void            *ifd_data;
//};
//
///* 
// * Structure used to retrieve aux status data from interfaces.
// * Kernel suppliers to this interface should respect the formatting
// * needed by ifconfig(8): each line starts with a TAB and ends with
// * a newline.  The canonical example to copy and paste is in if_tun.c.
// */
//
//#define	IFSTATMAX	800		/* 10 lines of text */
//struct ifstat {
//	char	ifs_name[IFNAMSIZ];	/* if name, e.g. "en0" */
//	char	ascii[IFSTATMAX + 1];
//};
//
///*
// * Structure used in SIOCGIFCONF request.
// * Used to retrieve interface configuration
// * for machine (useful for programs which
// * must know all networks accessible).
// */
//struct	ifconf {
//	int	ifc_len;		/* size of associated buffer */
//	union {
//		caddr_t	ifcu_buf;
//		struct	ifreq *ifcu_req;
//	} ifc_ifcu;
//#define	ifc_buf	ifc_ifcu.ifcu_buf	/* buffer address */
//#define	ifc_req	ifc_ifcu.ifcu_req	/* array of structures returned */
//};
//
///*
// * interface groups
// */
//
//#define	IFG_ALL		"all"		/* group contains all interfaces */
///* XXX: will we implement this? */
//#define	IFG_EGRESS	"egress"	/* if(s) default route(s) point to */
//
//struct ifg_req {
//	union {
//		char			 ifgrqu_group[IFNAMSIZ];
//		char			 ifgrqu_member[IFNAMSIZ];
//	} ifgrq_ifgrqu;
//#define	ifgrq_group	ifgrq_ifgrqu.ifgrqu_group
//#define	ifgrq_member	ifgrq_ifgrqu.ifgrqu_member
//};
//
///*
// * Used to lookup groups for an interface
// */
//struct ifgroupreq {
//	char	ifgr_name[IFNAMSIZ];
//	u_int	ifgr_len;
//	union {
//		char	ifgru_group[IFNAMSIZ];
//		struct	ifg_req *ifgru_groups;
//	} ifgr_ifgru;
//#define ifgr_group	ifgr_ifgru.ifgru_group
//#define ifgr_groups	ifgr_ifgru.ifgru_groups
//};
//
///*
// * Structure for SIOC[AGD]LIFADDR
// */
//struct if_laddrreq {
//	char	iflr_name[IFNAMSIZ];
//	u_int	flags;
//#define	IFLR_PREFIX	0x8000  /* in: prefix given  out: kernel fills id */
//	u_int	prefixlen;         /* in/out */
//	struct	sockaddr_storage addr;   /* in/out */
//	struct	sockaddr_storage dstaddr; /* out */
//};
//
//#ifndef _KERNEL
//struct if_nameindex {
//	u_int	 if_index;	/* 1, 2, ... */
//	char	*if_name;	/* null terminated name: "lnc0", ... */
//};
//
//__BEGIN_DECLS
//u_int	 if_nametoindex (const char *);
//char	*if_indextoname(u_int, char *);
//struct	 if_nameindex *if_nameindex (void);
//void	 if_freenameindex (struct if_nameindex *);
//__END_DECLS
//#endif
//
//#ifdef _KERNEL
//struct thread;
//struct ucred;
//
//int	prison_if (struct ucred *cred, struct sockaddr *sa);
//
///* XXX - this should go away soon. */
//#include <net/if_var.h>
//#endif
//
//#endif /* !_NET_IF_H_ */



// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/netinet/in.h

///*
// * Copyright (c) 1982, 1986, 1990, 1993
// *	The Regents of the University of California.  All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)in.h	8.3 (Berkeley) 1/3/94
// * $FreeBSD: src/sys/netinet/in.h,v 1.48.2.10 2003/08/24 08:24:38 hsu Exp $
// * $DragonFly: src/sys/netinet/in.h,v 1.16 2007/08/16 20:03:57 dillon Exp $
// */
//
//#ifndef _NETINET_IN_H_
//#define _NETINET_IN_H_
//
//#include <sys/types.h>
//
//#ifndef _KERNEL
//#include <machine/endian.h>
//#ifndef htonl
//#define	htonl(x)	__htonl(x)
//#endif
//#ifndef htons
//#define	htons(x)	__htons(x)
//#endif
//#ifndef ntohl
//#define	ntohl(x)	__ntohl(x)
//#endif
//#ifndef ntohs
//#define	ntohs(x)	__ntohs(x)
//#endif
//#endif
//
///*
// * Constants and structures defined by the internet system,
// * Per RFC 790, September 1981, and numerous additions.
// */
//
///*
// * Protocols (RFC 1700)
// */
	IPPROTO_IP		= 0		/* dummy for IP */
	IPPROTO_HOPOPTS		= 0		/* IP6 hop-by-hop options */
	IPPROTO_ICMP		= 1		/* control message protocol */
	IPPROTO_IGMP		= 2		/* group mgmt protocol */
	IPPROTO_GGP		= 3		/* gateway^2 (deprecated) */
 IPPROTO_IPV4		= 4		/* IPv4 encapsulation */
 IPPROTO_IPIP		= IPPROTO_IPV4	/* for compatibility */
	IPPROTO_TCP		= 6		/* tcp */
	IPPROTO_ST		= 7		/* Stream protocol II */
	IPPROTO_EGP		= 8		/* exterior gateway protocol */
	IPPROTO_PIGP		= 9		/* private interior gateway */
	IPPROTO_RCCMON		= 10		/* BBN RCC Monitoring */
	IPPROTO_NVPII		= 11		/* network voice protocol*/
	IPPROTO_PUP		= 12		/* pup */
	IPPROTO_ARGUS		= 13		/* Argus */
	IPPROTO_EMCON		= 14		/* EMCON */
	IPPROTO_XNET		= 15		/* Cross Net Debugger */
	IPPROTO_CHAOS		= 16		/* Chaos*/
	IPPROTO_UDP		= 17		/* user datagram protocol */
	IPPROTO_MUX		= 18		/* Multiplexing */
	IPPROTO_MEAS		= 19		/* DCN Measurement Subsystems */
	IPPROTO_HMP		= 20		/* Host Monitoring */
	IPPROTO_PRM		= 21		/* Packet Radio Measurement */
	IPPROTO_IDP		= 22		/* xns idp */
	IPPROTO_TRUNK1		= 23		/* Trunk-1 */
	IPPROTO_TRUNK2		= 24		/* Trunk-2 */
	IPPROTO_LEAF1		= 25		/* Leaf-1 */
	IPPROTO_LEAF2		= 26		/* Leaf-2 */
	IPPROTO_RDP		= 27		/* Reliable Data */
	IPPROTO_IRTP		= 28		/* Reliable Transaction */
	IPPROTO_TP		= 29		/* tp-4 w/ class negotiation */
	IPPROTO_BLT		= 30		/* Bulk Data Transfer */
	IPPROTO_NSP		= 31		/* Network Services */
	IPPROTO_INP		= 32		/* Merit Internodal */
	IPPROTO_SEP		= 33		/* Sequential Exchange */
	IPPROTO_3PC		= 34		/* Third Party Connect */
	IPPROTO_IDPR		= 35		/* InterDomain Policy Routing */
	IPPROTO_XTP		= 36		/* XTP */
	IPPROTO_DDP		= 37		/* Datagram Delivery */
	IPPROTO_CMTP		= 38		/* Control Message Transport */
	IPPROTO_TPXX		= 39		/* TP++ Transport */
	IPPROTO_IL		= 40		/* IL transport protocol */
	IPPROTO_IPV6		= 41		/* IP6 header */
	IPPROTO_SDRP		= 42		/* Source Demand Routing */
	IPPROTO_ROUTING		= 43		/* IP6 routing header */
	IPPROTO_FRAGMENT	= 44		/* IP6 fragmentation header */
	IPPROTO_IDRP		= 45		/* InterDomain Routing*/
	IPPROTO_RSVP		= 46		/* resource reservation */
	IPPROTO_GRE		= 47		/* General Routing Encap. */
	IPPROTO_MHRP		= 48		/* Mobile Host Routing */
	IPPROTO_BHA		= 49		/* BHA */
	IPPROTO_ESP		= 50		/* IP6 Encap Sec. Payload */
	IPPROTO_AH		= 51		/* IP6 Auth Header */
	IPPROTO_INLSP		= 52		/* Integ. Net Layer Security */
	IPPROTO_SWIPE		= 53		/* IP with encryption */
	IPPROTO_NHRP		= 54		/* Next Hop Resolution */
	IPPROTO_MOBILE		= 55		/* IP Mobility */
	IPPROTO_TLSP		= 56		/* Transport Layer Security */
	IPPROTO_SKIP		= 57		/* SKIP */
	IPPROTO_ICMPV6		= 58		/* ICMP6 */
	IPPROTO_NONE		= 59		/* IP6 no next header */
	IPPROTO_DSTOPTS		= 60		/* IP6 destination option */
	IPPROTO_AHIP		= 61		/* any host internal protocol */
	IPPROTO_CFTP		= 62		/* CFTP */
	IPPROTO_HELLO		= 63		/* "hello" routing protocol */
	IPPROTO_SATEXPAK	= 64		/* SATNET/Backroom EXPAK */
	IPPROTO_KRYPTOLAN	= 65		/* Kryptolan */
	IPPROTO_RVD		= 66		/* Remote Virtual Disk */
	IPPROTO_IPPC		= 67		/* Pluribus Packet Core */
	IPPROTO_ADFS		= 68		/* Any distributed FS */
	IPPROTO_SATMON		= 69		/* Satnet Monitoring */
	IPPROTO_VISA		= 70		/* VISA Protocol */
	IPPROTO_IPCV		= 71		/* Packet Core Utility */
	IPPROTO_CPNX		= 72		/* Comp. Prot. Net. Executive */
	IPPROTO_CPHB		= 73		/* Comp. Prot. HeartBeat */
	IPPROTO_WSN		= 74		/* Wang Span Network */
	IPPROTO_PVP		= 75		/* Packet Video Protocol */
	IPPROTO_BRSATMON	= 76		/* BackRoom SATNET Monitoring */
	IPPROTO_ND		= 77		/* Sun net disk proto (temp.) */
	IPPROTO_WBMON		= 78		/* WIDEBAND Monitoring */
	IPPROTO_WBEXPAK		= 79		/* WIDEBAND EXPAK */
	IPPROTO_EON		= 80		/* ISO cnlp */
	IPPROTO_VMTP		= 81		/* VMTP */
	IPPROTO_SVMTP		= 82		/* Secure VMTP */
	IPPROTO_VINES		= 83		/* Banyon VINES */
	IPPROTO_TTP		= 84		/* TTP */
	IPPROTO_IGP		= 85		/* NSFNET-IGP */
	IPPROTO_DGP		= 86		/* dissimilar gateway prot. */
	IPPROTO_TCF		= 87		/* TCF */
	IPPROTO_IGRP		= 88		/* Cisco/GXS IGRP */
	IPPROTO_OSPFIGP		= 89		/* OSPFIGP */
	IPPROTO_SRPC		= 90		/* Strite RPC protocol */
	IPPROTO_LARP		= 91		/* Locus Address Resoloution */
	IPPROTO_MTP		= 92		/* Multicast Transport */
	IPPROTO_AX25		= 93		/* AX.25 Frames */
	IPPROTO_IPEIP		= 94		/* IP encapsulated in IP */
	IPPROTO_MICP		= 95		/* Mobile Int.ing control */
	IPPROTO_SCCSP		= 96		/* Semaphore Comm. security */
	IPPROTO_ETHERIP		= 97		/* Ethernet IP encapsulation */
	IPPROTO_ENCAP		= 98		/* encapsulation header */
	IPPROTO_APES		= 99		/* any private encr. scheme */
	IPPROTO_GMTP		= 100		/* GMTP*/
	IPPROTO_IPCOMP		= 108		/* payload compression (IPComp) */
///* 101-254: Partly Unassigned */
	IPPROTO_PIM		= 103		/* Protocol Independent Mcast */
	IPPROTO_CARP		= 112		/* CARP */
	IPPROTO_PGM		= 113		/* PGM */
	IPPROTO_SCTP		= 132		/* SCTP */
	IPPROTO_PFSYNC		= 240		/* PFSYNC */
///* 255: Reserved */
///* BSD Private, local use, namespace incursion */
	IPPROTO_DIVERT		= 254		/* divert pseudo-protocol */
	IPPROTO_RAW		= 255		/* raw IP packet */
	IPPROTO_MAX		= 256
//
///* last return value of *_input(), meaning "all job for this pkt is done".  */
	IPPROTO_DONE		= 257
//
///* Used by RSS: the layer3 protocol is unknown */
 IPPROTO_UNKNOWN		= 258
//
///*
// * Local port number conventions:
// *
// * When a user does a bind(2) or connect(2) with a port number of zero,
// * a non-conflicting local port address is chosen.
// * The default range is IPPORT_RESERVED through
// * IPPORT_USERRESERVED, although that is settable by sysctl.
// *
// * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
// * default assignment range.
// *
// * The value IP_PORTRANGE_DEFAULT causes the default behavior.
// *
// * The value IP_PORTRANGE_HIGH changes the range of candidate port numbers
// * into the "high" range.  These are reserved for client outbound connections
// * which do not want to be filtered by any firewalls.
// *
// * The value IP_PORTRANGE_LOW changes the range to the "low" are
// * that is (by convention) restricted to privileged processes.  This
// * convention is based on "vouchsafe" principles only.  It is only secure
// * if you trust the remote host to restrict these ports.
// *
// * The default range of ports and the high range can be changed by
// * sysctl(3).  (net.inet.ip.port{hi,low}{first,last}_auto)
// *
// * Changing those values has bad security implications if you are
// * using a a stateless firewall that is allowing packets outside of that
// * range in order to allow transparent outgoing connections.
// *
// * Such a firewall configuration will generally depend on the use of these
// * default values.  If you change them, you may find your Security
// * Administrator looking for you with a heavy object.
// *
// * For a slightly more orthodox text view on this:
// *   ftp://ftp.isi.edu/in-notes/iana/assignments/port-numbers
// *
// *   port numbers are divided into three ranges:
// *		0 -  1023 Well Known Ports
// *	     1024 - 49151 Registered Ports
// *	    49152 - 65535 Dynamic and/or Private Ports
// */
//
///*
// * Ports < IPPORT_RESERVED are reserved for
// * privileged processes (e.g. root).  (IP_PORTRANGE_LOW)
// * Ports > IPPORT_USERRESERVED are reserved
// * for servers, not necessarily privileged.  (IP_PORTRANGE_DEFAULT)
// */
//#define	IPPORT_RESERVED		1024
//#define	IPPORT_USERRESERVED	5000
//
///*
// * Default local port range to use by setting IP_PORTRANGE_HIGH
// */
//#define	IPPORT_HIFIRSTAUTO	49152
//#define	IPPORT_HILASTAUTO	65535
//
///*
// * Scanning for a free reserved port return a value below IPPORT_RESERVED,
// * but higher than IPPORT_RESERVEDSTART.  Traditionally the start value was
// * 512, but that conflicts with some well-known-services that firewalls may
// * have a fit if we use.
// */
//#define IPPORT_RESERVEDSTART	600
//
//#ifndef _STRUCT_IN_ADDR_DECLARED
//#define _STRUCT_IN_ADDR_DECLARED
///*
// * Internet address (a structure for historical reasons)
// */
//struct in_addr {
//	in_addr_t s_addr;
//};
//#endif
//
///*
// * Definitions of bits in internet address integers.
// * On subnets, the decomposition of addresses to host and net parts
// * is done according to subnet mask, not the masks here.
// */
//#define	IN_CLASSA(i)		(((u_int32_t)(i) & 0x80000000) == 0)
//#define	IN_CLASSA_NET		0xff000000
//#define	IN_CLASSA_NSHIFT	24
//#define	IN_CLASSA_HOST		0x00ffffff
//#define	IN_CLASSA_MAX		128
//
//#define	IN_CLASSB(i)		(((u_int32_t)(i) & 0xc0000000) == 0x80000000)
//#define	IN_CLASSB_NET		0xffff0000
//#define	IN_CLASSB_NSHIFT	16
//#define	IN_CLASSB_HOST		0x0000ffff
//#define	IN_CLASSB_MAX		65536
//
//#define	IN_CLASSC(i)		(((u_int32_t)(i) & 0xe0000000) == 0xc0000000)
//#define	IN_CLASSC_NET		0xffffff00
//#define	IN_CLASSC_NSHIFT	8
//#define	IN_CLASSC_HOST		0x000000ff
//
//#define	IN_CLASSD(i)		(((u_int32_t)(i) & 0xf0000000) == 0xe0000000)
//#define	IN_CLASSD_NET		0xf0000000	/* These ones aren't really */
//#define	IN_CLASSD_NSHIFT	28		/* net and host fields, but */
//#define	IN_CLASSD_HOST		0x0fffffff	/* routing needn't know.    */
//#define	IN_MULTICAST(i)		IN_CLASSD(i)
//
//#define	IN_EXPERIMENTAL(i)	(((u_int32_t)(i) & 0xf0000000) == 0xf0000000)
//#define	IN_BADCLASS(i)		(((u_int32_t)(i) & 0xf0000000) == 0xf0000000)
//
//#define	INADDR_ANY		(u_int32_t)0x00000000
//#define	INADDR_LOOPBACK		(u_int32_t)0x7f000001
//#define	INADDR_BROADCAST	(u_int32_t)0xffffffff	/* must be masked */
//#ifndef _KERNEL
//#define	INADDR_NONE		0xffffffff		/* -1 return */
//#endif
//
//#define	INADDR_UNSPEC_GROUP	(u_int32_t)0xe0000000	/* 224.0.0.0 */
//#define	INADDR_ALLHOSTS_GROUP	(u_int32_t)0xe0000001	/* 224.0.0.1 */
//#define	INADDR_ALLRTRS_GROUP	(u_int32_t)0xe0000002	/* 224.0.0.2 */
//#define	INADDR_CARP_GROUP       (u_int32_t)0xe0000012   /* 224.0.0.18 */
//#define	INADDR_PFSYNC_GROUP	(u_int32_t)0xe00000f0	/* 224.0.0.240 */
//#define	INADDR_MAX_LOCAL_GROUP	(u_int32_t)0xe00000ff	/* 224.0.0.255 */
//
//#define	IN_LOOPBACKNET		127			/* official! */
//
///*
// * Socket address, internet style.
// */
//struct sockaddr_in {
//	u_char	sin_len;
//	u_char	sin_family;
//	u_short	sin_port;
//	struct	in_addr sin_addr;
//	char	sin_zero[8];
//};
//
//#define	INET_ADDRSTRLEN		16
//
///*
// * Options for use with [gs]etsockopt at the IP level.
// * First word of comment is data type; bool is stored in int.
// */
//#define	IP_OPTIONS		1    /* buf/ip_opts; set/get IP options */
//#define	IP_HDRINCL		2    /* int; header is included with data */
//#define	IP_TOS			3    /* int; IP type of service and preced. */
//#define	IP_TTL			4    /* int; IP time to live */
//#define	IP_RECVOPTS		5    /* bool; receive all IP opts w/dgram */
//#define	IP_RECVRETOPTS		6    /* bool; receive IP opts for response */
//#define	IP_RECVDSTADDR		7    /* bool; receive IP dst addr w/dgram */
//#define	IP_RETOPTS		8    /* ip_opts; set/get IP options */
//#define	IP_MULTICAST_IF		9    /* u_char; set/get IP multicast i/f  */
//#define	IP_MULTICAST_TTL	10   /* u_char; set/get IP multicast ttl */
//#define	IP_MULTICAST_LOOP	11   /* u_char; set/get IP multicast loopback */
//#define	IP_ADD_MEMBERSHIP	12   /* ip_mreq; add an IP group membership */
//#define	IP_DROP_MEMBERSHIP	13   /* ip_mreq; drop an IP group membership */
//#define IP_MULTICAST_VIF	14   /* set/get IP mcast virt. iface */
//#define IP_RSVP_ON		15   /* enable RSVP in kernel */
//#define IP_RSVP_OFF		16   /* disable RSVP in kernel */
//#define IP_RSVP_VIF_ON		17   /* set RSVP per-vif socket */
//#define IP_RSVP_VIF_OFF		18   /* unset RSVP per-vif socket */
//#define IP_PORTRANGE		19   /* int; range to choose for unspec port */
//#define	IP_RECVIF		20   /* bool; receive reception if w/dgram */
///* for IPSEC */
//#define	IP_IPSEC_POLICY		21   /* int; set/get security policy */
//#define	IP_FAITH		22   /* bool; accept FAITH'ed connections */
//
//#define	IP_FW_ADD		50   /* add a firewall rule to chain */
//#define	IP_FW_DEL		51   /* delete a firewall rule from chain */
//#define	IP_FW_FLUSH		52   /* flush firewall rule chain */
//#define	IP_FW_ZERO		53   /* clear single/all firewall counter(s) */
//#define	IP_FW_GET		54   /* get entire firewall rule chain */
//#define	IP_FW_RESETLOG		55   /* reset logging counters */
//
//#define	IP_DUMMYNET_CONFIGURE	60   /* add/configure a dummynet pipe */
//#define	IP_DUMMYNET_DEL		61   /* delete a dummynet pipe from chain */
//#define	IP_DUMMYNET_FLUSH	62   /* flush dummynet */
//#define	IP_DUMMYNET_GET		64   /* get entire dummynet pipes */
//
//#define	IP_RECVTTL		65   /* bool; receive IP TTL w/dgram */
//#define	IP_MINTTL		66   /* minimum TTL for packet or drop */
//
///*
// * Defaults and limits for options
// */
//#define	IP_DEFAULT_MULTICAST_TTL  1	/* normally limit m'casts to 1 hop  */
//#define	IP_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */
//#define	IP_MAX_MEMBERSHIPS	20	/* per socket */
//
///*
// * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
// */
//struct ip_mreq {
//	struct	in_addr imr_multiaddr;	/* IP multicast address of group */
//	struct	in_addr imr_interface;	/* local IP address of interface */
//};
//
///*
// * Argument for IP_PORTRANGE:
// * - which range to search when port is unspecified at bind() or connect()
// */
//#define	IP_PORTRANGE_DEFAULT	0	/* default range */
//#define	IP_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
//#define	IP_PORTRANGE_LOW	2	/* "low" - vouchsafe security */
//
///*
// * Definitions for inet sysctl operations.
// *
// * Third level is protocol number.
// * Fourth level is desired variable within that protocol.
// */
//#define	IPPROTO_MAXID	(IPPROTO_AH + 1)	/* don't list to IPPROTO_MAX */
//
//#define	CTL_IPPROTO_NAMES { \
//	{ "ip", CTLTYPE_NODE }, \
//	{ "icmp", CTLTYPE_NODE }, \
//	{ "igmp", CTLTYPE_NODE }, \
//	{ "ggp", CTLTYPE_NODE }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ "tcp", CTLTYPE_NODE }, \
//	{ 0, 0 }, \
//	{ "egp", CTLTYPE_NODE }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ "pup", CTLTYPE_NODE }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ "udp", CTLTYPE_NODE }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ "idp", CTLTYPE_NODE }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ "ipsec", CTLTYPE_NODE }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ 0, 0 }, \
//	{ "pim", CTLTYPE_NODE }, \
//}
//
///*
// * Names for IP sysctl objects
// */
//#define	IPCTL_FORWARDING	1	/* act as router */
//#define	IPCTL_SENDREDIRECTS	2	/* may send redirects when forwarding */
//#define	IPCTL_DEFTTL		3	/* default TTL */
//#ifdef notyet
//#define	IPCTL_DEFMTU		4	/* default MTU */
//#endif
//#define IPCTL_RTEXPIRE		5	/* cloned route expiration time */
//#define IPCTL_RTMINEXPIRE	6	/* min value for expiration time */
//#define IPCTL_RTMAXCACHE	7	/* trigger level for dynamic expire */
//#define	IPCTL_SOURCEROUTE	8	/* may perform source routes */
//#define	IPCTL_DIRECTEDBROADCAST	9	/* may re-broadcast received packets */
//#define IPCTL_INTRQMAXLEN	10	/* max length of netisr queue */
//#define	IPCTL_INTRQDROPS	11	/* number of netisr q drops */
//#define	IPCTL_STATS		12	/* ipstat structure */
//#define	IPCTL_ACCEPTSOURCEROUTE	13	/* may accept source routed packets */
//#define	IPCTL_FASTFORWARDING	14	/* use fast IP forwarding code */
//#define	IPCTL_KEEPFAITH		15	/* FAITH IPv4->IPv6 translater ctl */
//#define	IPCTL_GIF_TTL		16	/* default TTL for gif encap packet */
//#define	IPCTL_MAXID		17
//
//#define	IPCTL_NAMES { \
//	{ 0, 0 }, \
//	{ "forwarding", CTLTYPE_INT }, \
//	{ "redirect", CTLTYPE_INT }, \
//	{ "ttl", CTLTYPE_INT }, \
//	{ "mtu", CTLTYPE_INT }, \
//	{ "rtexpire", CTLTYPE_INT }, \
//	{ "rtminexpire", CTLTYPE_INT }, \
//	{ "rtmaxcache", CTLTYPE_INT }, \
//	{ "sourceroute", CTLTYPE_INT }, \
//	{ "directed-broadcast", CTLTYPE_INT }, \
//	{ "intr-queue-maxlen", CTLTYPE_INT }, \
//	{ "intr-queue-drops", CTLTYPE_INT }, \
//	{ "stats", CTLTYPE_STRUCT }, \
//	{ "accept_sourceroute", CTLTYPE_INT }, \
//	{ "fastforwarding", CTLTYPE_INT }, \
//}
//
//#ifdef _KERNEL
//struct ifnet; struct mbuf;	/* forward declarations for Standard C */
//#endif
//
///* INET6 stuff */
//#define	__KAME_NETINET_IN_H_INCLUDED_
//#include <netinet6/in6.h>
//#undef __KAME_NETINET_IN_H_INCLUDED_
//
//#ifdef _KERNEL
//
//struct thread;
//
//int	 in_broadcast (struct in_addr, struct ifnet *);
//int	 in_canforward (struct in_addr);
//int	 in_localaddr (struct in_addr);
//char	*inet_ntoa (struct in_addr); /* in libkern */
//
//int	prison_replace_wildcards (struct thread *td, struct sockaddr *ip);
//int	prison_remote_ip (struct thread *td, struct sockaddr *ip);
//
//#define in_hosteq(s, t)	((s).s_addr == (t).s_addr)
//#define in_nullhost(x)	((x).s_addr == INADDR_ANY)
//
//#define satosin(sa)	((struct sockaddr_in *)(sa))
//#define sintosa(sin)	((struct sockaddr *)(sin))
//#define ifatoia(ifa)	((struct in_ifaddr *)(ifa))
//
//#endif
//
//#endif


// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/netinet6/in6.h


///*	$FreeBSD: src/sys/netinet6/in6.h,v 1.7.2.7 2002/08/01 19:38:50 ume Exp $	*/
///*	$DragonFly: src/sys/netinet6/in6.h,v 1.12 2008/09/14 08:58:33 hasso Exp $	*/
///*	$KAME: in6.h,v 1.89 2001/05/27 13:28:35 itojun Exp $	*/
//
///*
// * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
// * All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. Neither the name of the project nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// */
//
///*
// * Copyright (c) 1982, 1986, 1990, 1993
// *	The Regents of the University of California.  All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)in.h	8.3 (Berkeley) 1/3/94
// */
//
//#ifndef __KAME_NETINET_IN_H_INCLUDED_
//#error "do not include netinet6/in6.h directly, include netinet/in.h.  see RFC2553"
//#endif
//
//#ifndef _NETINET6_IN6_H_
//#define _NETINET6_IN6_H_
//
///*
// * Identification of the network protocol stack
// * for *BSD-current/release: http://www.kame.net/dev/cvsweb.cgi/kame/COVERAGE
// * has the table of implementation/integration differences.
// */
//#define __KAME__
//#define __KAME_VERSION		"20010528/FreeBSD"
//
//#ifndef _SOCKLEN_T_DECLARED
//#define _SOCKLEN_T_DECLARED
//typedef __socklen_t	socklen_t;
//#endif
//
///*
// * Local port number conventions:
// *
// * Ports < IPPORT_RESERVED are reserved for privileged processes (e.g. root),
// * unless a kernel is compiled with IPNOPRIVPORTS defined.
// *
// * When a user does a bind(2) or connect(2) with a port number of zero,
// * a non-conflicting local port address is chosen.
// *
// * The default range is IPPORT_ANONMIN to IPPORT_ANONMAX, although
// * that is settable by sysctl(3); net.inet.ip.anonportmin and
// * net.inet.ip.anonportmax respectively.
// *
// * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
// * default assignment range.
// *
// * The value IP_PORTRANGE_DEFAULT causes the default behavior.
// *
// * The value IP_PORTRANGE_HIGH is the same as IP_PORTRANGE_DEFAULT,
// * and exists only for FreeBSD compatibility purposes.
// *
// * The value IP_PORTRANGE_LOW changes the range to the "low" are
// * that is (by convention) restricted to privileged processes.
// * This convention is based on "vouchsafe" principles only.
// * It is only secure if you trust the remote host to restrict these ports.
// * The range is IPPORT_RESERVEDMIN to IPPORT_RESERVEDMAX.
// */
//
//#define	IPV6PORT_RESERVED	1024
//#define	IPV6PORT_ANONMIN	49152
//#define	IPV6PORT_ANONMAX	65535
//#define	IPV6PORT_RESERVEDMIN	600
//#define	IPV6PORT_RESERVEDMAX	(IPV6PORT_RESERVED-1)
//
///*
// * IPv6 address
// */
//#ifndef _STRUCT_IN6_ADDR_DECLARED
//struct in6_addr {
//	union {
//		uint8_t   __u6_addr8[16];
//		uint16_t  __u6_addr16[8];
//		uint32_t  __u6_addr32[4];
//	} __u6_addr;			/* 128-bit IP6 address */
//};
//#define _STRUCT_IN6_ADDR_DECLARED
//#endif
//
//#define s6_addr		__u6_addr.__u6_addr8
//#define _s6_addr16	__u6_addr.__u6_addr16		/* internal use */
//#define _s6_addr32	__u6_addr.__u6_addr32		/* internal use */
//#if __BSD_VISIBLE					/* XXX nonstandard */
//#define s6_addr8	__u6_addr.__u6_addr8
//#define s6_addr16	__u6_addr.__u6_addr16
//#define s6_addr32	__u6_addr.__u6_addr32
//#endif
//
//#define INET6_ADDRSTRLEN	46
//
///*
// * Socket address for IPv6
// */
//#ifndef _XOPEN_SOURCE
//#define SIN6_LEN
//#endif
//struct sockaddr_in6 {
//	uint8_t		sin6_len;	/* length of this struct(sa_family_t)*/
//	uint8_t		sin6_family;	/* AF_INET6 (sa_family_t) */
//	uint16_t	sin6_port;	/* Transport layer port # (in_port_t)*/
//	uint32_t	sin6_flowinfo;	/* IP6 flow information */
//	struct in6_addr	sin6_addr;	/* IP6 address */
//	uint32_t	sin6_scope_id;	/* scope zone index */
//};
//
///*
// * Local definition for masks
// */
//#ifdef _KERNEL	/* XXX nonstandard */
//#define IN6MASK0	{{{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }}}
//#define IN6MASK32	{{{ 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, \
//			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
//#define IN6MASK64	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
//			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
//#define IN6MASK96	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
//			    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 }}}
//#define IN6MASK128	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
//			    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}}
//#endif
//
//#ifdef _KERNEL
//extern const struct sockaddr_in6 sa6_any;
//
//extern const struct in6_addr in6mask0;
//extern const struct in6_addr in6mask32;
//extern const struct in6_addr in6mask64;
//extern const struct in6_addr in6mask96;
//extern const struct in6_addr in6mask128;
//#endif /* _KERNEL */
//
///*
// * Macros started with IPV6_ADDR is KAME local
// */
//#if BYTE_ORDER == BIG_ENDIAN
//#define _IPV6_ADDR_INT16_UL_MASK	0xffc0
//#define _IPV6_ADDR_INT16_ULL		0xfe80
//#define _IPV6_ADDR_INT16_USL		0xfec0
//#else
//#define _IPV6_ADDR_INT16_UL_MASK	0xc0ff
//#define _IPV6_ADDR_INT16_ULL		0x80fe
//#define _IPV6_ADDR_INT16_USL		0xc0fe
//#endif
//
//#ifdef _KERNEL	/* XXX nonstandard */
//#if BYTE_ORDER == BIG_ENDIAN
//#define IPV6_ADDR_INT32_ONE	1
//#define IPV6_ADDR_INT32_TWO	2
//#define IPV6_ADDR_INT32_MNL	0xff010000
//#define IPV6_ADDR_INT32_MLL	0xff020000
//#define IPV6_ADDR_INT32_SMP	0x0000ffff
//#define IPV6_ADDR_INT16_MLL	0xff02
//#elif BYTE_ORDER == LITTLE_ENDIAN
//#define IPV6_ADDR_INT32_ONE	0x01000000
//#define IPV6_ADDR_INT32_TWO	0x02000000
//#define IPV6_ADDR_INT32_MNL	0x000001ff
//#define IPV6_ADDR_INT32_MLL	0x000002ff
//#define IPV6_ADDR_INT32_SMP	0xffff0000
//#define IPV6_ADDR_INT16_MLL	0x02ff
//#endif
//#define IPV6_ADDR_INT16_ULL	_IPV6_ADDR_INT16_ULL
//#define IPV6_ADDR_INT16_USL	_IPV6_ADDR_INT16_USL
//#endif
//
///*
// * Definition of some useful macros to handle IP6 addresses
// */
//#define IN6ADDR_ANY_INIT						\
//	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		\
//	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
//#define IN6ADDR_LOOPBACK_INIT						\
//	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		\
//	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
//#define IN6ADDR_NODELOCAL_ALLNODES_INIT					\
//	{{{ 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		\
//	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
//#define IN6ADDR_LINKLOCAL_ALLNODES_INIT					\
//	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		\
//	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
//#define IN6ADDR_LINKLOCAL_ALLROUTERS_INIT				\
//	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		\
//	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 }}}
//
//#ifdef _KERNEL
//extern const struct in6_addr kin6addr_any;
//extern const struct in6_addr kin6addr_loopback;
//extern const struct in6_addr kin6addr_nodelocal_allnodes;
//extern const struct in6_addr kin6addr_linklocal_allnodes;
//extern const struct in6_addr kin6addr_linklocal_allrouters;
//#else
//extern const struct in6_addr in6addr_any;
//extern const struct in6_addr in6addr_loopback;
//extern const struct in6_addr in6addr_nodelocal_allnodes;
//extern const struct in6_addr in6addr_linklocal_allnodes;
//#endif
//
//#define IN6_ARE_ADDR_EQUAL(a, b)					\
//    (memcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
//
//#ifdef _KERNEL			/* non standard */
///* see if two addresses are equal in a scope-conscious manner. */
//#define SA6_ARE_ADDR_EQUAL(a, b) \
//	(((a)->sin6_scope_id == 0 || (b)->sin6_scope_id == 0 ||		\
//	  (a)->sin6_scope_id == (b)->sin6_scope_id) &&			\
//	 (bcmp(&(a)->sin6_addr, &(b)->sin6_addr, sizeof(struct in6_addr)) == 0))
//#endif
//
///*
// * Unspecified
// */
//#define IN6_IS_ADDR_UNSPECIFIED(a)					\
//	((a)->_s6_addr32[0] == 0 && (a)->_s6_addr32[1] == 0 &&		\
//	 (a)->_s6_addr32[2] == 0 && (a)->_s6_addr32[3] == 0)
//
///*
// * Loopback
// */
//#define IN6_IS_ADDR_LOOPBACK(a)						\
//	((a)->_s6_addr32[0] == 0 && (a)->_s6_addr32[1] == 0 &&	\
//	 (a)->_s6_addr32[2] == 0 && (a)->_s6_addr32[3] == ntohl(1))
//
///*
// * Mapped
// */
//#define IN6_IS_ADDR_V4MAPPED(a)						\
//	((a)->_s6_addr32[0] == 0 && (a)->_s6_addr32[1] == 0 &&		\
//	 (a)->_s6_addr32[2] == ntohl(0x0000ffff))
//
///*
// * IPv4 compatible.  Deprecated by RFC4291.
// */
//#define IN6_IS_ADDR_V4COMPAT(a)						\
//	((a)->_s6_addr32[0] == 0 &&					\
//	 (a)->_s6_addr32[1] == 0 &&					\
//	 (a)->_s6_addr32[2] == 0 &&					\
//	 (a)->_s6_addr32[3] != 0 && (a)->_s6_addr32[3] != ntohl(1))
//
///*
// * KAME Scope Values
// */
//
//#define __IPV6_ADDR_SCOPE_NODELOCAL	0x01
//#define __IPV6_ADDR_SCOPE_LINKLOCAL	0x02
//#define __IPV6_ADDR_SCOPE_SITELOCAL	0x05
//#define __IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
//#define __IPV6_ADDR_SCOPE_GLOBAL	0x0e
//
//#ifdef _KERNEL					/* XXX nonstandard */
//#define IPV6_ADDR_SCOPE_NODELOCAL	0x01
//#define IPV6_ADDR_SCOPE_INTFACELOCAL	0x01
//#define IPV6_ADDR_SCOPE_LINKLOCAL	0x02
//#define IPV6_ADDR_SCOPE_SITELOCAL	0x05
//#define IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
//#define IPV6_ADDR_SCOPE_GLOBAL		0x0e
//#endif
//
///*
// * Unicast Scope
// * Note that we must check topmost 10 bits only, not 16 bits (see RFC2373).
// */
//#define IN6_IS_ADDR_LINKLOCAL(a)					\
//    (((a)->_s6_addr16[0] & _IPV6_ADDR_INT16_UL_MASK) == _IPV6_ADDR_INT16_ULL)
//#define IN6_IS_ADDR_SITELOCAL(a)					\
//    (((a)->_s6_addr16[0] & _IPV6_ADDR_INT16_UL_MASK) == _IPV6_ADDR_INT16_USL)
//
///*
// * Multicast
// */
//#define IN6_IS_ADDR_MULTICAST(a)	((a)->s6_addr[0] == 0xff)
//#define __IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
//#ifdef _KERNEL					/* XXX nonstandard */
//#define IPV6_ADDR_MC_SCOPE(a)		__IPV6_ADDR_MC_SCOPE(a)
//#endif
//
///*
// * Multicast Scope
// */
//#define IN6_IS_ADDR_MC_NODELOCAL(a)					\
//	(IN6_IS_ADDR_MULTICAST(a) &&					\
//	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_NODELOCAL))
//
//#define IN6_IS_ADDR_MC_INTFACELOCAL(a)					\
//	(IN6_IS_ADDR_MULTICAST(a) &&					\
//	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_INTFACELOCAL))
//
//#define IN6_IS_ADDR_MC_LINKLOCAL(a)					\
//	(IN6_IS_ADDR_MULTICAST(a) &&					\
//	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_LINKLOCAL))
//
//#define IN6_IS_ADDR_MC_SITELOCAL(a)					\
//	(IN6_IS_ADDR_MULTICAST(a) &&					\
//	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_SITELOCAL))
//
//#define IN6_IS_ADDR_MC_ORGLOCAL(a)					\
//	(IN6_IS_ADDR_MULTICAST(a) &&					\
//	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_ORGLOCAL))
//
//#define IN6_IS_ADDR_MC_GLOBAL(a)					\
//	(IN6_IS_ADDR_MULTICAST(a) &&					\
//	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_GLOBAL))
//
//#ifdef _KERNEL	/* nonstandard */
///*
// * KAME Scope
// */
//#define IN6_IS_SCOPE_LINKLOCAL(a)					\
//	(IN6_IS_ADDR_LINKLOCAL(a) || IN6_IS_ADDR_MC_LINKLOCAL(a))
//#define	IN6_IS_SCOPE_EMBED(a)						\
//	((IN6_IS_ADDR_LINKLOCAL(a)) ||					\
//	 (IN6_IS_ADDR_MC_LINKLOCAL(a)) ||				\
//	 (IN6_IS_ADDR_MC_INTFACELOCAL(a)))
//
//
//#define IFA6_IS_DEPRECATED(a)						\
//	((a)->ia6_lifetime.ia6t_preferred != 0 &&			\
//	 (a)->ia6_lifetime.ia6t_preferred < time_second)
//
//#define IFA6_IS_INVALID(a)						\
//	((a)->ia6_lifetime.ia6t_expire != 0 &&				\
//	 (a)->ia6_lifetime.ia6t_expire < time_second)
//#endif
//
///*
// * IP6 route structure
// */
//#ifndef _XOPEN_SOURCE
//struct route_in6 {
//	struct rtentry		*ro_rt;
//	struct sockaddr_in6	ro_dst;
//};
//#endif
//
///*
// * Options for use with [gs]etsockopt at the IPV6 level.
// * First word of comment is data type; bool is stored in int.
// */
///* no hdrincl */
//#if 0 /* the followings are relic in IPv4 and hence are disabled */
 IPV6_OPTIONS		= 1  /* buf/ip6_opts; set/get IP6 options */
 IPV6_RECVOPTS		= 5  /* bool; receive all IP6 opts w/dgram */
 IPV6_RECVRETOPTS	= 6  /* bool; receive IP6 opts for response */
 IPV6_RECVDSTADDR	= 7  /* bool; receive IP6 dst addr w/dgram */
 IPV6_RETOPTS		= 8  /* ip6_opts; set/get IP6 options */
//#endif
 IPV6_SOCKOPT_RESERVED1	= 3  /* reserved for future use */
 IPV6_UNICAST_HOPS	= 4  /* int; IP6 hops */
 IPV6_MULTICAST_IF	= 9  /* u_int; set/get IP6 multicast i/f  */
 IPV6_MULTICAST_HOPS	= 10 /* int; set/get IP6 multicast hops */
 IPV6_MULTICAST_LOOP	= 11 /* u_int; set/get IP6 multicast loopback */
 IPV6_JOIN_GROUP	= 12 /* ip6_mreq; join a group membership */
 IPV6_LEAVE_GROUP	= 13 /* ip6_mreq; leave a group membership */
 IPV6_PORTRANGE		= 14 /* int; range to choose for unspec port */
 ICMP6_FILTER		= 18 /* icmp6_filter; icmp6 filter */
///* RFC2292 options */
//#ifdef _KERNEL
 IPV6_2292PKTINFO	= 19 /* bool; send/recv if, src/dst addr */
 IPV6_2292HOPLIMIT	= 20 /* bool; hop limit */
 IPV6_2292NEXTHOP	= 21 /* bool; next hop addr */
 IPV6_2292HOPOPTS	= 22 /* bool; hop-by-hop option */
 IPV6_2292DSTOPTS	= 23 /* bool; destinaion option */
 IPV6_2292RTHDR		= 24 /* bool; routing header */
 IPV6_2292PKTOPTIONS	= 25 /* buf/cmsghdr; set/get IPv6 options */
//#endif
//
 IPV6_CHECKSUM		= 26 /* int; checksum offset for raw socket */
 IPV6_V6ONLY		= 27 /* bool; only bind INET6 at wildcard bind */
//#ifndef _KERNEL
//#define IPV6_BINDV6ONLY		IPV6_V6ONLY
//#endif
//
//#if 1 /* IPSEC */
 IPV6_IPSEC_POLICY	= 28 /* struct; get/set security policy */
//#endif
 IPV6_FAITH		= 29 /* bool; accept FAITH'ed connections */
//
//#if 1 /* IPV6FIREWALL */
 IPV6_FW_ADD		= 30 /* add a firewall rule to chain */
 IPV6_FW_DEL		= 31 /* delete a firewall rule from chain */
 IPV6_FW_FLUSH		= 32 /* flush firewall rule chain */
 IPV6_FW_ZERO		= 33 /* clear single/all firewall counter(s) */
 IPV6_FW_GET		= 34 /* get entire firewall rule chain */
//#endif
//
///* 
// * new socket options introduced in RFC3542 
// */
 IPV6_RTHDRDSTOPTS	= 35 /* ip6_dest; send dst option before rthdr */
 IPV6_RECVPKTINFO	= 36 /* bool; recv if, dst addr */
 IPV6_RECVHOPLIMIT	= 37 /* bool; recv hop limit */
 IPV6_RECVRTHDR		= 38 /* bool; recv routing header */
 IPV6_RECVHOPOPTS	= 39 /* bool; recv hop-by-hop option */
 IPV6_RECVDSTOPTS	= 40 /* bool; recv dst option after rthdr */
//#ifdef _KERNEL
 IPV6_RECVRTHDRDSTOPTS	= 41 /* bool; recv dst option before rthdr */
//#endif
 IPV6_USE_MIN_MTU	= 42 /* bool; send packets at the minimum MTU */
 IPV6_RECVPATHMTU	= 43 /* bool; notify an according MTU */
//
///* mtuinfo; get the current path MTU (sopt),
// * 4 bytes int; MTU notification (cmsg) 
// */
 IPV6_PATHMTU		= 44 
//#if 0 /*obsoleted during 2292bis -> 3542*/
 IPV6_REACHCONF		= 45 /* no data; ND reachability confirm
//				      (cmsg only/not in of RFC3542) */
//#endif
 IPV6_PKTINFO		= 46 /* in6_pktinfo; send if, src addr */
 IPV6_HOPLIMIT		= 47 /* int; send hop limit */
 IPV6_NEXTHOP		= 48 /* sockaddr; next hop addr */
 IPV6_HOPOPTS		= 49 /* ip6_hbh; send hop-by-hop option */
 IPV6_DSTOPTS		= 50 /* ip6_dest; send dst option befor rthdr */
 IPV6_RTHDR		= 51 /* ip6_rthdr; send routing header */
 IPV6_PKTOPTIONS		= 52 /* buf/cmsghdr; set/get IPv6 options, this is obsoleted by RFC3542 */
//
 IPV6_RECVTCLASS		= 57 /* bool; recv traffic class values */
//
 IPV6_AUTOFLOWLABEL	= 59 /* bool; attach flowlabel automagically */
//
 IPV6_TCLASS		= 61 /* int; send traffic class value */
 IPV6_DONTFRAG		= 62 /* bool; disable IPv6 fragmentation */
//
 IPV6_PREFER_TEMPADDR	= 63 /* int; prefer temporary addresses as
//				    * the source address.
//				    */
///*
// * The following option is private; do not use it from user applications.
// * It is deliberately defined to the same value as IP_MSFILTER.
// */
	IPV6_MSFILTER		= 74 /* struct __msfilterreq;
//				    * set/get multicast source filter list.
//				    */ 
///* to define items, should talk with KAME guys first, for *BSD compatibility */
//
//#define IPV6_RTHDR_LOOSE     0 /* this hop need not be a neighbor. XXX old spec */
//#define IPV6_RTHDR_STRICT    1 /* this hop must be a neighbor. XXX old spec */
//#define IPV6_RTHDR_TYPE_0    0 /* IPv6 routing header type 0 */
//
///*
// * Defaults and limits for options
// */
//#define IPV6_DEFAULT_MULTICAST_HOPS 1	/* normally limit m'casts to 1 hop */
//#define IPV6_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member */
//
///*
// * Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP.
// */
//struct ipv6_mreq {
//	struct in6_addr	ipv6mr_multiaddr;
//	unsigned int	ipv6mr_interface;
//};
//
///*
// * IPV6_PKTINFO: Packet information(RFC2292 sec 5)
// */
//struct in6_pktinfo {
//	struct in6_addr	ipi6_addr;	/* src/dst IPv6 address */
//	unsigned int	ipi6_ifindex;	/* send/recv interface index */
//};
//
///*
// * New Control structure for IPV6_RECVPATHMTU socket option introduced in RFC3542.
// */
//struct ip6_mtuinfo {
//	struct sockaddr_in6 ip6m_addr;	/* or sockaddr_storage? */
//	uint32_t ip6m_mtu;
//};
//
///*
// * Argument for IPV6_PORTRANGE:
// * - which range to search when port is unspecified at bind() or connect()
// */
//#define	IPV6_PORTRANGE_DEFAULT	0	/* default range */
//#define	IPV6_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
//#define	IPV6_PORTRANGE_LOW	2	/* "low" - vouchsafe security */
//
//#ifndef _XOPEN_SOURCE
///*
// * Definitions for inet6 sysctl operations.
// *
// * Third level is protocol number.
// * Fourth level is desired variable within that protocol.
// */
//#define IPV6PROTO_MAXID	(IPPROTO_PIM + 1)	/* don't list to IPV6PROTO_MAX */
//
//#define CTL_IPV6PROTO_NAMES {					\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 },						\
//	{ "tcp6", CTLTYPE_NODE },				\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ "udp6", CTLTYPE_NODE },				\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 },						\
//	{ "ip6", CTLTYPE_NODE },				\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 },						\
//	{ "ipsec6", CTLTYPE_NODE },				\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ "icmp6", CTLTYPE_NODE },				\
//	{ 0, 0 },						\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },	\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ 0, 0 },						\
//	{ "pim6", CTLTYPE_NODE },				\
//}
//
///*
// * Names for IP sysctl objects
// */
//#define IPV6CTL_FORWARDING	1	/* act as router */
//#define IPV6CTL_SENDREDIRECTS	2	/* may send redirects when forwarding*/
//#define IPV6CTL_DEFHLIM		3	/* default Hop-Limit */
//#ifdef notyet
//#define IPV6CTL_DEFMTU		4	/* default MTU */
//#endif
//#define IPV6CTL_FORWSRCRT	5	/* forward source-routed dgrams */
//#define IPV6CTL_STATS		6	/* stats */
//#define IPV6CTL_MRTSTATS	7	/* multicast forwarding stats */
//#define IPV6CTL_MRTPROTO	8	/* multicast routing protocol */
//#define IPV6CTL_MAXFRAGPACKETS	9	/* max packets reassembly queue */
//#define IPV6CTL_SOURCECHECK	10	/* verify source route and intf */
//#define IPV6CTL_SOURCECHECK_LOGINT 11	/* minimume logging interval */
//#define IPV6CTL_ACCEPT_RTADV	12
//#define IPV6CTL_KEEPFAITH	13
//#define IPV6CTL_LOG_INTERVAL	14
//#define IPV6CTL_HDRNESTLIMIT	15
//#define IPV6CTL_DAD_COUNT	16
//#define IPV6CTL_AUTO_FLOWLABEL	17
//#define IPV6CTL_DEFMCASTHLIM	18
//#define IPV6CTL_GIF_HLIM	19	/* default HLIM for gif encap packet */
//#define IPV6CTL_KAME_VERSION	20
//#define IPV6CTL_USE_DEPRECATED	21	/* use deprecated addr (RFC2462 5.5.4) */
//#define IPV6CTL_RR_PRUNE	22	/* walk timer for router renumbering */
//#if 0	/* obsolete */
//#define IPV6CTL_MAPPED_ADDR	23
//#endif
//#define IPV6CTL_V6ONLY		24
//#define IPV6CTL_RTEXPIRE	25	/* cloned route expiration time */
//#define IPV6CTL_RTMINEXPIRE	26	/* min value for expiration time */
//#define IPV6CTL_RTMAXCACHE	27	/* trigger level for dynamic expire */
//
//#define IPV6CTL_USETEMPADDR	32	/* use temporary addresses (RFC3041) */
//#define IPV6CTL_TEMPPLTIME	33	/* preferred lifetime for tmpaddrs */
//#define IPV6CTL_TEMPVLTIME	34	/* valid lifetime for tmpaddrs */
//#define IPV6CTL_AUTO_LINKLOCAL	35	/* automatic link-local addr assign */
//#define IPV6CTL_RIP6STATS	36	/* raw_ip6 stats */
//
//#define IPV6CTL_ADDRCTLPOLICY	38	/* get/set address selection policy */
//
///* New entries should be added here from current IPV6CTL_MAXID value. */
///* to define items, should talk with KAME guys first, for *BSD compatibility */
//#define IPV6CTL_MAXID		42
//
//#endif /* !_XOPEN_SOURCE */
//
///*
// * Redefinition of mbuf flags
// */
//#define	M_AUTHIPHDR	M_PROTO2
//#define	M_DECRYPTED	M_PROTO3
//#define	M_LOOP		M_PROTO4
//#define	M_AUTHIPDGM	M_PROTO5
//
//#ifdef _KERNEL
//
//struct ifnet;
//struct mbuf;
//struct sockaddr;
//struct sockaddr_in;
//struct sockaddr_in6;
//
//int	in6_cksum (struct mbuf *, uint8_t, uint32_t, uint32_t);
//int	in6_localaddr (struct in6_addr *);
//int	in6_addrscope (struct in6_addr *);
//struct	in6_ifaddr *in6_ifawithscope (struct ifnet *, struct in6_addr *);
//struct	in6_ifaddr *in6_ifawithifp (struct ifnet *, struct in6_addr *);
//void	in6_if_up (struct ifnet *);
//
//void	in6_sin6_2_sin (struct sockaddr_in *sin, struct sockaddr_in6 *sin6);
//void	in6_sin_2_v4mapsin6(struct sockaddr_in *sin, struct sockaddr_in6 *sin6);
//void	in6_sin6_2_sin_in_sock (struct sockaddr *nam);
//void	in6_sin_2_v4mapsin6_in_sock (struct sockaddr **nam);
//void	addrsel_policy_init (void);
//
//#define	satosin6(sa)	((struct sockaddr_in6 *)(sa))
//#define	sin6tosa(sin6)	((struct sockaddr *)(sin6))
//#define	ifatoia6(ifa)	((struct in6_ifaddr *)(ifa))
//
//extern int (*faithprefix_p)(struct in6_addr *);
//#endif /* _KERNEL */
//
//#include <sys/cdefs.h>		/* for __BEGIN_DECLS and __END_DECLS */
//
//__BEGIN_DECLS
//struct cmsghdr;
//
//uint8_t *inet6_option_alloc (struct cmsghdr *, int, int, int);
//int inet6_option_append (struct cmsghdr *, const uint8_t *, int, int);
//int inet6_option_find (const struct cmsghdr *, uint8_t **, int);
//int inet6_option_init (void *, struct cmsghdr **, int);
//int inet6_option_next (const struct cmsghdr *, uint8_t **);
//int inet6_option_space (int);
//
//int inet6_opt_append (void *, socklen_t, int, uint8_t, socklen_t, uint8_t, void **);
//int inet6_opt_find (void *, socklen_t, int, uint8_t, socklen_t *, void **);
//int inet6_opt_finish (void *, socklen_t, int);
//int inet6_opt_get_val (void *, int, void *, socklen_t);
//int inet6_opt_init (void *, socklen_t);
//int inet6_opt_next (void *, socklen_t, int, uint8_t *, socklen_t *, void **);
//int inet6_opt_set_val (void *, int, void *, socklen_t);
//
//int		 inet6_rth_add (void *, const struct in6_addr *);
//struct in6_addr *inet6_rth_getaddr (const void *, int);
//void		*inet6_rth_init (void *, socklen_t, int, int);
//int		 inet6_rth_reverse (const void *, void *);
//int		 inet6_rth_segments (const void *);
//socklen_t	 inet6_rth_space (int, int);
//
//int		 inet6_rthdr_add (struct cmsghdr *, const struct in6_addr *,
//				  unsigned int);
//struct in6_addr *inet6_rthdr_getaddr (struct cmsghdr *, int);
//int		 inet6_rthdr_getflags (const struct cmsghdr *, int);
//struct cmsghdr	*inet6_rthdr_init (void *, int);
//int		 inet6_rthdr_lasthop (struct cmsghdr *, unsigned int);
//#if 0					/* not implemented yet */
//int		 inet6_rthdr_reverse (const struct cmsghdr *, struct cmsghdr *);
//#endif
//int		 inet6_rthdr_segments (const struct cmsghdr *);
//size_t		 inet6_rthdr_space (int, int);
//__END_DECLS
//
//#endif /* !_NETINET6_IN6_H_ */

)

// Signals
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/signal.h
const (
	SIGHUP		= Signal(1)	/* hangup */
	SIGINT		= Signal(2)	/* interrupt */
	SIGQUIT		= Signal(3)	/* quit */
	SIGILL		= Signal(4)	/* illegal instr. (not reset when caught) */
	SIGTRAP		= Signal(5)	/* trace trap (not reset when caught) */
	SIGABRT		= Signal(6)	/* abort() */
	SIGIOT		= Signal(SIGABRT)	/* compatibility */
	SIGEMT		= Signal(7)	/* EMT instruction */
	SIGFPE		= Signal(8)	/* floating point exception */
	SIGKILL		= Signal(9)	/* kill (cannot be caught or ignored) */
	SIGBUS		= Signal(10)	/* bus error */
	SIGSEGV		= Signal(11)	/* segmentation violation */
	SIGSYS		= Signal(12)	/* non-existent system call invoked */
	SIGPIPE		= Signal(13)	/* write on a pipe with no one to read it */
	SIGALRM		= Signal(14)	/* alarm clock */
	SIGTERM		= Signal(15)	/* software termination signal from kill */
	SIGURG		= Signal(16)	/* urgent condition on IO channel */
	SIGSTOP		= Signal(17)	/* sendable stop signal not from tty */
	SIGTSTP		= Signal(18)	/* stop signal from tty */
	SIGCONT		= Signal(19)	/* continue a stopped process */
	SIGCHLD		= Signal(20)	/* to parent on child stop or exit */
	SIGTTIN		= Signal(21)	/* to readers pgrp upon background tty read */
	SIGTTOU		= Signal(22)	/* like TTIN if (tp->t_local&LTOSTOP) */
	SIGIO		= Signal(23)	/* input/output possible signal */
	SIGXCPU		= Signal(24)	/* exceeded CPU time limit */
	SIGXFSZ		= Signal(25)	/* exceeded file size limit */
	SIGVTALRM	= Signal(26)	/* virtual time alarm */
	SIGPROF		= Signal(27)	/* profiling time alarm */
	SIGWINCH	= Signal(28)	/* window size changes */
	SIGINFO		= Signal(29)	/* information request */
	SIGUSR1		= Signal(30)	/* user defined signal 1 */
	SIGUSR2		= Signal(31)	/* user defined signal 2 */
	SIGTHR          = Signal(32)      /* Thread interrupt (FreeBSD-5 reserved) */
	SIGCKPT         = Signal(33)      /* checkpoint and continue */
	SIGCKPTEXIT     = Signal(34)      /* checkpoint and exit */
)

// Error table
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/errno.h
var errors = [...]string{
	1: "Operation not permitted",
	2: "No such file or directory",
	3: "No such process",
	4: "Interrupted system call",
	5: "Input/output error",
	6: "Device not configured",
	7: "Argument list too long",
	8: "Exec format error",
	9: "Bad file descriptor",
	10: "No child processes",
	11: "Resource deadlock avoided",
	12: "Cannot allocate memory",
	13: "Permission denied",
	14: "Bad address",
	16: "Device busy",
	17: "File exists",
	18: "Cross-device link",
	19: "Operation not supported by device",
	20: "Not a directory",
	21: "Is a directory",
	22: "Invalid argument",
	23: "Too many open files in system",
	24: "Too many open files",
	25: "Inappropriate ioctl for device",
	27: "File too large",
	28: "No space left on device",
	29: "Illegal seek",
	30: "Read-only filesystem",
	31: "Too many links",
	32: "Broken pipe",

	/* math software */
	33: "Numerical argument out of domain",
	34: "Result too large",

	/* non-blocking and interrupt i/o */
	35: "Resource temporarily unavailable",
	63: "File name too long",

	/* should be rearranged */
	66: "Directory not empty",

	/* quotas & mush */

	77: "No locks available",
	78: "Function not implemented",

	89: "Bad message",
	90: "Multihop attempted",
	91: "Link has been severed",
	92: "Protocol error",
}

// Signal table
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/lib/libc/gen/siglist.c
var signals = [...]string{
	SIGHUP:		"Hangup",
	SIGINT:		"Interrupt",
	SIGQUIT:	"Quit",
	SIGILL:		"Illegal instruction",
	SIGTRAP:	"Trace/BPT trap",
	SIGABRT:	"Abort trap",
	SIGEMT:		"EMT trap",
	SIGFPE:		"Floating point exception",
	SIGKILL:	"Killed",
	SIGBUS:		"Bus error",
	SIGSEGV:	"Segmentation fault",
	SIGSYS:		"Bad system call",
	SIGPIPE:	"Broken pipe",
	SIGALRM:	"Alarm clock",
	SIGTERM:	"Terminated",
	SIGURG:		"Urgent I/O condition",
	SIGSTOP:	"Suspended (signal)",
	SIGTSTP:	"Suspended",
	SIGCONT:	"Continued",
	SIGCHLD:	"Child exited",
	SIGTTIN:	"Stopped (tty input)",
	SIGTTOU:	"Stopped (tty output)",
	SIGIO:		"I/O possible",
	SIGXCPU:	"Cputime limit exceeded",
	SIGXFSZ:	"Filesize limit exceeded",
	SIGVTALRM:	"Virtual timer expired",
	SIGPROF:	"Profiling timer expired",
	SIGWINCH:	"Window size changes",
	SIGINFO:	"Information request",
	SIGUSR1:	"User defined signal 1",
	SIGUSR2:	"User defined signal 2",
}
