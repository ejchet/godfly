// mkerrors.sh -m64
// NOT MACHINE GENERATED BY THE COMMAND ABOVE; DO EDIT

// Not Created by cgo -godefs - DO EDIT
// cgo -godefs -- -m64 _const.go

package syscall




const (
	// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/socket.h
	AF_UNSPEC	= 0		/* unspecified */
	AF_LOCAL	= 1		/* local to host (pipes, portals) */
	AF_UNIX		= AF_LOCAL	/* backward compatibility */
	AF_INET		= 2		/* internetwork: UDP, TCP, etc. */
	AF_IMPLINK	= 3		/* arpanet imp addresses */
	AF_PUP		= 4		/* pup protocols: e.g. BSP */
	AF_CHAOS	= 5		/* mit CHAOS protocols */
	AF_NS		= 6		/* XEROX NS protocols */
	AF_ISO		= 7		/* ISO protocols */
	AF_OSI		= AF_ISO
	AF_ECMA		= 8		/* European computer manufacturers */
	AF_DATAKIT	= 9		/* datakit protocols */
	AF_CCITT	= 10		/* CCITT protocols, X.25 etc */
	AF_SNA		= 11		/* IBM SNA */
	AF_DECnet	= 12		/* DECnet */
	AF_DLI		= 13		/* DEC Direct data link interface */
	AF_LAT		= 14		/* LAT */
	AF_HYLINK	= 15		/* NSC Hyperchannel */
	AF_APPLETALK	= 16		/* Apple Talk */
	AF_ROUTE	= 17		/* Internal Routing Protocol */
	AF_LINK		= 18		/* Link layer interface */
	pseudo_AF_XTP	= 19		/* eXpress Transfer Protocol (no AF) */
	AF_COIP		= 20		/* connection-oriented IP, aka ST II */
	AF_CNT		= 21		/* Computer Network Technology */
	pseudo_AF_RTIP	= 22		/* Help Identify RTIP packets */
	AF_IPX		= 23		/* Novell Internet Protocol */
	AF_SIP		= 24		/* Simple Internet Protocol */
	pseudo_AF_PIP	= 25		/* Help Identify PIP packets */
	AF_ISDN		= 26		/* Integrated Services Digital Network*/
	AF_E164		= AF_ISDN		/* CCITT E.164 recommendation */
	pseudo_AF_KEY	= 27		/* Internal key-management function */
	AF_INET6	= 28		/* IPv6 */
	AF_NATM		= 29		/* native ATM access */
	AF_ATM		= 30		/* ATM */
	pseudo_AF_HDRCMPLT = 31		/* Used by BPF to not rewrite headers
					 * in interface output routine
					 */
	AF_NETGRAPH	= 32		/* Netgraph sockets */
	AF_BLUETOOTH	= 33		/* Bluetooth */
	AF_MPLS		= 34		/* Multi-Protocol Label Switching */
	AF_IEEE80211	= 35		/* IEEE 802.11 protocol */
	AF_MAX		= 36
	// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/sysctl.h

//#ifndef _SYS_SYSCTL_H_
//#define	_SYS_SYSCTL_H_
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#ifndef _SYS__POSIX_H_
//#include <sys/_posix.h>
//#endif
//#ifndef _SYS_QUEUE_H_
//#include <sys/queue.h>
//#endif
//
///*
// * Definitions for sysctl call.  The sysctl call uses a hierarchical name
// * for objects that can be examined or modified.  The name is expressed as
// * a sequence of integers.  Like a file path name, the meaning of each
// * component depends on its place in the hierarchy.  The top-level and kern
// * identifiers are defined here, and other identifiers are defined in the
// * respective subsystem header files.
// */
//
	CTL_MAXNAME	= 12		/* largest number of components supported */
//
///*
// * Each subsystem defined by sysctl defines a list of variables
// * for that subsystem. Each name is either a node with further
// * levels defined below it, or it is a leaf of some particular
// * type given below. Each sysctl level defines a set of name/type
// * pairs to be used by sysctl(1) in manipulating the subsystem.
// */
//struct ctlname {
//	char	*ctl_name;	/* subsystem name */
//	int	ctl_type;	/* type of name */
//};
//

	CTLTYPE		= 0xf	/* Mask for the type */
	CTLTYPE_NODE	= 1	/* name is a node */
	CTLTYPE_INT	= 2	/* name describes an integer */
	CTLTYPE_STRING	= 3	/* name describes a string */
	CTLTYPE_QUAD	= 4	/* name describes a 64-bit number */
	CTLTYPE_OPAQUE	= 5	/* name describes a structure */
	CTLTYPE_STRUCT	= CTLTYPE_OPAQUE	/* name describes a structure */
	CTLTYPE_UINT	= 6	/* name describes an unsigned integer */
	CTLTYPE_LONG	= 7	/* name describes a long */
	CTLTYPE_ULONG	= 8	/* name describes an unsigned long */
	CTLTYPE_UQUAD	= 9	/* name describes an unsigned 64-bit number */
	CTLFLAG_RD	= 0x80000000	/* Allow reads of variable */
	CTLFLAG_WR	= 0x40000000	/* Allow writes to the variable */
	CTLFLAG_RW	= CTLFLAG_RD | CTLFLAG_WR
	CTLFLAG_ANYBODY	= 0x10000000	/* All users can set this var */
	CTLFLAG_SECURE	= 0x08000000	/* Permit set only if securelevel<=0 */
	CTLFLAG_PRISON	= 0x04000000	/* Prisoned roots can fiddle */
	CTLFLAG_DYN	= 0x02000000	/* Dynamic oid - can be freed */

//
//
///*
// * USE THIS instead of a hardwired number from the categories below
// * to get dynamically assigned sysctl entries using the linker-set
// * technology. This is the way nearly all new sysctl variables should
// * be implemented.
// * e.g. SYSCTL_INT(_parent, OID_AUTO, name, CTLFLAG_RW, &variable, 0, "");
// */ 
//#define OID_AUTO	(-1)
//
//#ifdef _KERNEL
//
//#include <sys/kernel.h>			/* for DATA_SET */
//
//#define SYSCTL_HANDLER_ARGS struct sysctl_oid *oidp, void *arg1, int arg2, \
//	struct sysctl_req *req
//
///*
// * This describes the access space for a sysctl request.  This is needed
// * so that we can use the interface from the kernel or from user-space.
// */
//struct sysctl_req {
//	struct thread	*td;
//	int		unused01;	/* was lock */
//	void		*oldptr;
//	size_t		oldlen;
//	size_t		oldidx;
//	int		(*oldfunc)(struct sysctl_req *, const void *, size_t);
//	void		*newptr;
//	size_t		newlen;
//	size_t		newidx;
//	int		(*newfunc)(struct sysctl_req *, void *, size_t);
//};
//
//SLIST_HEAD(sysctl_oid_list, sysctl_oid);
//
///*
// * This describes one "oid" in the MIB tree.  Potentially more nodes can
// * be hidden behind it, expanded by the handler.
// */
//struct sysctl_oid {
//	struct sysctl_oid_list *oid_parent;
//	SLIST_ENTRY(sysctl_oid) oid_link;
//	int		oid_number;
//	int		oid_kind;
//	void		*oid_arg1;
//	int		oid_arg2;
//	const char	*oid_name;
//	int 		(*oid_handler)(SYSCTL_HANDLER_ARGS);
//	const char	*oid_fmt;
//	int		oid_refcnt;
//	const char	*oid_descr;
//};
//
//#define SYSCTL_IN(r, p, l) (r->newfunc)(r, p, l)
//#define SYSCTL_OUT(r, p, l) (r->oldfunc)(r, p, l)
//
//int sysctl_handle_int(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_long(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_quad(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_intptr(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_string(SYSCTL_HANDLER_ARGS);
//int sysctl_handle_opaque(SYSCTL_HANDLER_ARGS);
//
///*
// * These functions are used to add/remove an oid from the mib.
// */
//void sysctl_register_oid(struct sysctl_oid *oidp);
//void sysctl_unregister_oid(struct sysctl_oid *oidp);
//
///* Declare a static oid to allow child oids to be added to it. */
//#define SYSCTL_DECL(name)					\
//	extern struct sysctl_oid_list sysctl_##name##_children
//
///* Hide these in macros */
//#define	SYSCTL_SET_CHILDREN(oid_ptr, children) do {			\
//	(oid_ptr)->oid_arg1 = (children);				\
//} while(0)
//#define	SYSCTL_CHILDREN(oid_ptr) (struct sysctl_oid_list *) \
//	(oid_ptr)->oid_arg1
//#define	SYSCTL_STATIC_CHILDREN(oid_name) \
//	(&sysctl_##oid_name##_children)
//
///* === Structs and macros related to context handling === */
//
///* All dynamically created sysctls can be tracked in a context list. */
//struct sysctl_ctx_entry {
//	struct sysctl_oid *entry;
//	TAILQ_ENTRY(sysctl_ctx_entry) link;
//};
//
//TAILQ_HEAD(sysctl_ctx_list, sysctl_ctx_entry);
//
//#define	SYSCTL_NODE_CHILDREN(parent, name) \
//	sysctl_##parent##_##name##_children
//
///* This constructs a "raw" MIB oid. */
//#define SYSCTL_OID(parent, nbr, name, kind, a1, a2, handler, fmt, descr) \
//	static struct sysctl_oid sysctl__##parent##_##name = {		 \
//		&sysctl_##parent##_children, { 0 },			 \
//		nbr, kind, a1, a2, #name, handler, fmt, 0, descr };		 \
//	DATA_SET(sysctl_set, sysctl__##parent##_##name);
//
//#define SYSCTL_ADD_OID(ctx, parent, nbr, name, kind, a1, a2, handler, fmt, descr) \
//	sysctl_add_oid(ctx, parent, nbr, name, kind, a1, a2, handler, fmt, descr);
//
///* This constructs a node from which other oids can hang. */
//#define SYSCTL_NODE(parent, nbr, name, access, handler, descr)		    \
//	struct sysctl_oid_list sysctl_##parent##_##name##_children;	    \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_NODE|access,		    \
//		   (void*)&sysctl_##parent##_##name##_children, 0, handler, \
//		   "N", descr);
//
//#define SYSCTL_ADD_NODE(ctx, parent, nbr, name, access, handler, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_NODE|access,	    \
//	0, 0, handler, "N", descr)
//
///* Oid for a string.  len can be 0 to indicate '\0' termination. */
//#define SYSCTL_STRING(parent, nbr, name, access, arg, len, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_STRING|access, \
//		arg, len, sysctl_handle_string, "A", descr)
//
//#define SYSCTL_ADD_STRING(ctx, parent, nbr, name, access, arg, len, descr)  \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_STRING|access,	    \
//	arg, len, sysctl_handle_string, "A", descr)
//
///* Oid for an int.  If ptr is NULL, val is returned. */
//#define SYSCTL_INT(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_INT|access, \
//		ptr, val, sysctl_handle_int, "I", descr)
//
//#define SYSCTL_ADD_INT(ctx, parent, nbr, name, access, ptr, val, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_INT|access,	    \
//	ptr, val, sysctl_handle_int, "I", descr)
//
///* Oid for a quad.  If ptr is NULL, val is returned. */
//#define SYSCTL_QUAD(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_QUAD|access, \
//		ptr, val, sysctl_handle_quad, "Q", descr)
//
//#define SYSCTL_ADD_QUAD(ctx, parent, nbr, name, access, ptr, val, descr)    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_QUAD|access,	    \
//	ptr, val, sysctl_handle_quad, "Q", descr)
//
///* Oid for an unsigned quad.  If ptr is NULL, val is returned. */
//#define SYSCTL_UQUAD(parent, nbr, name, access, ptr, val, descr)	    \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_UQUAD|access,		    \
//		ptr, val, sysctl_handle_quad, "QU", descr)
//
//#define SYSCTL_ADD_UQUAD(ctx, parent, nbr, name, access, ptr, val, descr)   \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_UQUAD|access,	    \
//	ptr, val, sysctl_handle_quad, "QU", descr)
//
///* Oid for an unsigned int.  If ptr is NULL, val is returned. */
//#define SYSCTL_UINT(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_UINT|access, \
//		ptr, val, sysctl_handle_int, "IU", descr)
//
//#define SYSCTL_ADD_UINT(ctx, parent, nbr, name, access, ptr, val, descr)    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_UINT|access,	    \
//	ptr, val, sysctl_handle_int, "IU", descr)
//
///* Oid for a long.  The pointer must be non NULL. */
//#define SYSCTL_LONG(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_LONG|access, \
//		ptr, val, sysctl_handle_long, "L", descr)
//
//#define SYSCTL_ADD_LONG(ctx, parent, nbr, name, access, ptr, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_LONG|access,	    \
//	ptr, 0, sysctl_handle_long, "L", descr)
//
///* Oid for a long.  The pointer must be non NULL. */
//#define SYSCTL_ULONG(parent, nbr, name, access, ptr, val, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_ULONG|access, \
//		ptr, val, sysctl_handle_long, "LU", descr)
//
//#define SYSCTL_ADD_ULONG(ctx, parent, nbr, name, access, ptr, descr)	    \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_ULONG|access,	    \
//	ptr, 0, sysctl_handle_long, "LU", descr)
//
///* Oid for an opaque object.  Specified by a pointer and a length. */
//#define SYSCTL_OPAQUE(parent, nbr, name, access, ptr, len, fmt, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_OPAQUE|access, \
//		ptr, len, sysctl_handle_opaque, fmt, descr)
//
//#define SYSCTL_ADD_OPAQUE(ctx, parent, nbr, name, access, ptr, len, fmt, descr)\
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_OPAQUE|access,	    \
//	ptr, len, sysctl_handle_opaque, fmt, descr)
//
///* Oid for a struct.  Specified by a pointer and a type. */
//#define SYSCTL_STRUCT(parent, nbr, name, access, ptr, type, descr) \
//	SYSCTL_OID(parent, nbr, name, CTLTYPE_OPAQUE|access, \
//		ptr, sizeof(struct type), sysctl_handle_opaque, \
//		"S," #type, descr)
//
//#define SYSCTL_ADD_STRUCT(ctx, parent, nbr, name, access, ptr, type, descr) \
//	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_OPAQUE|access,	    \
//	ptr, sizeof(struct type), sysctl_handle_opaque, "S," #type, descr)
//
///* Oid for a procedure.  Specified by a pointer and an arg. */
//#define SYSCTL_PROC(parent, nbr, name, access, ptr, arg, handler, fmt, descr) \
//	SYSCTL_OID(parent, nbr, name, access, \
//		ptr, arg, handler, fmt, descr)
//
//#define SYSCTL_ADD_PROC(ctx, parent, nbr, name, access, ptr, arg, handler, fmt, descr) \
//	sysctl_add_oid(ctx, parent, nbr, name, access,			    \
//	ptr, arg, handler, fmt, descr)
//
//#endif /* _KERNEL */
//
///*
// * Top-level identifiers
// */
	CTL_UNSPEC	= 0		/* unused */
	CTL_KERN	= 1		/* "high kernel": proc, limits */
	CTL_VM		= 2		/* virtual memory */
	CTL_VFS		= 3		/* file system, mount type is next */
	CTL_NET		= 4		/* network, see socket.h */
	CTL_DEBUG	= 5		/* debugging parameters */
	CTL_HW		= 6		/* generic cpu/io */
	CTL_MACHDEP	= 7		/* machine dependent */
	CTL_USER	= 8		/* user-level */
	CTL_P1003_1B	= 9		/* POSIX 1003.1B */
 CTL_LWKT	= 10		/* light weight kernel threads */
	CTL_MAXID	= 11		/* number of valid top-level ids */
//
//#define CTL_NAMES { \
//	{ 0, 0 }, \
//	{ "kern", CTLTYPE_NODE }, \
//	{ "vm", CTLTYPE_NODE }, \
//	{ "vfs", CTLTYPE_NODE }, \
//	{ "net", CTLTYPE_NODE }, \
//	{ "debug", CTLTYPE_NODE }, \
//	{ "hw", CTLTYPE_NODE }, \
//	{ "machdep", CTLTYPE_NODE }, \
//	{ "user", CTLTYPE_NODE }, \
//	{ "p1003_1b", CTLTYPE_NODE }, \
//	{ "lwkt", CTLTYPE_NODE }, \
//}
//
///*
// * CTL_KERN identifiers
// */
//#define	KERN_OSTYPE	 	 1	/* string: system version */
//#define	KERN_OSRELEASE	 	 2	/* string: system release */
//#define	KERN_OSREV	 	 3	/* int: system revision */
//#define	KERN_VERSION	 	 4	/* string: compile time info */
//#define	KERN_MAXVNODES	 	 5	/* int: max vnodes */
//#define	KERN_MAXPROC	 	 6	/* int: max processes */
//#define	KERN_MAXFILES	 	 7	/* int: max open files */
//#define	KERN_ARGMAX	 	 8	/* int: max arguments to exec */
//#define	KERN_SECURELVL	 	 9	/* int: system security level */
//#define	KERN_HOSTNAME		10	/* string: hostname */
//#define	KERN_HOSTID		11	/* int: host identifier */
//#define	KERN_CLOCKRATE		12	/* struct: struct clockrate */
//#define	KERN_VNODE		13	/* struct: vnode structures */
//#define	KERN_PROC		14	/* struct: process entries */
//#define	KERN_FILE		15	/* struct: file entries */
//#define	KERN_PROF		16	/* node: kernel profiling info */
//#define	KERN_POSIX1		17	/* int: POSIX.1 version */
//#define	KERN_NGROUPS		18	/* int: # of supplemental group ids */
//#define	KERN_JOB_CONTROL	19	/* int: is job control available */
//#define	KERN_SAVED_IDS		20	/* int: saved set-user/group-ID */
//#define	KERN_BOOTTIME		21	/* struct: time kernel was booted */
//#define KERN_NISDOMAINNAME	22	/* string: YP domain name */
//#define KERN_UPDATEINTERVAL	23	/* int: update process sleep time */
//#define KERN_OSRELDATE		24	/* int: OS release date */
//#define KERN_NTP_PLL		25	/* node: NTP PLL control */
//#define	KERN_BOOTFILE		26	/* string: name of booted kernel */
//#define	KERN_MAXFILESPERPROC	27	/* int: max open files per proc */
//#define	KERN_MAXPROCPERUID 	28	/* int: max processes per uid */
//#define KERN_DUMPDEV		29	/* udev_t: device to dump on */
//#define	KERN_IPC		30	/* node: anything related to IPC */
//#define	KERN_DUMMY		31	/* unused */
//#define	KERN_PS_STRINGS		32	/* int: address of PS_STRINGS */
//#define	KERN_USRSTACK		33	/* int: address of USRSTACK */
//#define	KERN_LOGSIGEXIT		34	/* int: do we log sigexit procs? */
//#define	KERN_IOV_MAX		35	/* int: value of UIO_MAXIOV */
//#define KERN_MAXPOSIXLOCKSPERUID 36	/* int: max POSIX locks per uid */
//#define KERN_MAXID		37      /* number of valid kern ids */
//
//#define CTL_KERN_NAMES { \
//	{ 0, 0 }, \
//	{ "ostype", CTLTYPE_STRING }, \
//	{ "osrelease", CTLTYPE_STRING }, \
//	{ "osrevision", CTLTYPE_INT }, \
//	{ "version", CTLTYPE_STRING }, \
//	{ "maxvnodes", CTLTYPE_INT }, \
//	{ "maxproc", CTLTYPE_INT }, \
//	{ "maxfiles", CTLTYPE_INT }, \
//	{ "argmax", CTLTYPE_INT }, \
//	{ "securelevel", CTLTYPE_INT }, \
//	{ "hostname", CTLTYPE_STRING }, \
//	{ "hostid", CTLTYPE_UINT }, \
//	{ "clockrate", CTLTYPE_STRUCT }, \
//	{ "vnode", CTLTYPE_STRUCT }, \
//	{ "proc", CTLTYPE_STRUCT }, \
//	{ "file", CTLTYPE_STRUCT }, \
//	{ "profiling", CTLTYPE_NODE }, \
//	{ "posix1version", CTLTYPE_INT }, \
//	{ "ngroups", CTLTYPE_INT }, \
//	{ "job_control", CTLTYPE_INT }, \
//	{ "saved_ids", CTLTYPE_INT }, \
//	{ "boottime", CTLTYPE_STRUCT }, \
//	{ "nisdomainname", CTLTYPE_STRING }, \
//	{ "update", CTLTYPE_INT }, \
//	{ "osreldate", CTLTYPE_INT }, \
//	{ "ntp_pll", CTLTYPE_NODE }, \
//	{ "bootfile", CTLTYPE_STRING }, \
//	{ "maxfilesperproc", CTLTYPE_INT }, \
//	{ "maxprocperuid", CTLTYPE_INT }, \
//	{ "dumpdev", CTLTYPE_STRUCT }, /* we lie; don't print as int */ \
//	{ "ipc", CTLTYPE_NODE }, \
//	{ "dummy", CTLTYPE_INT }, \
//	{ "ps_strings", CTLTYPE_INT }, \
//	{ "usrstack", CTLTYPE_INT }, \
//	{ "logsigexit", CTLTYPE_INT }, \
//	{ "iov_max", CTLTYPE_INT }, \
//	{ "maxposixlocksperuid", CTLTYPE_INT }, \
//}
//
///*
// * CTL_VFS identifiers
// */
//#define CTL_VFS_NAMES { \
//	{ "vfsconf", CTLTYPE_STRUCT }, \
//}
//
///*
// * KERN_PROC subtypes
// */
//#define KERN_PROC_ALL		0	/* everything */
//#define	KERN_PROC_PID		1	/* by process id */
//#define	KERN_PROC_PGRP		2	/* by process group id */
//#define	KERN_PROC_SESSION	3	/* by session of pid */
//#define	KERN_PROC_TTY		4	/* by controlling tty */
//#define	KERN_PROC_UID		5	/* by effective uid */
//#define	KERN_PROC_RUID		6	/* by real uid */
//#define	KERN_PROC_ARGS		7	/* get/set arguments/proctitle */
//#define	KERN_PROC_CWD		8	/* get cwd */
//
//#define KERN_PROC_FLAGMASK	0x10
//#define KERN_PROC_FLAG_LWP	0x10
//
///*
// * KERN_IPC identifiers
// */
//#define KIPC_MAXSOCKBUF		1	/* int: max size of a socket buffer */
//#define	KIPC_SOCKBUF_WASTE	2	/* int: wastage factor in sockbuf */
//#define	KIPC_SOMAXCONN		3	/* int: max length of connection q */
//#define	KIPC_MAX_LINKHDR	4	/* int: max length of link header */
//#define	KIPC_MAX_PROTOHDR	5	/* int: max length of network header */
//#define	KIPC_MAX_HDR		6	/* int: max total length of headers */
//#define	KIPC_MAX_DATALEN	7	/* int: max length of data? */
//#define	KIPC_MBSTAT		8	/* struct: mbuf usage statistics */
//#define	KIPC_NMBCLUSTERS	9	/* int: maximum mbuf clusters */
//
///*
// * CTL_HW identifiers
// */
//#define	HW_MACHINE	 1		/* string: machine class */
//#define	HW_MODEL	 2		/* string: specific machine model */
//#define	HW_NCPU		 3		/* int: number of cpus */
//#define	HW_BYTEORDER	 4		/* int: machine byte order */
//#define	HW_PHYSMEM	 5		/* int: total memory */
//#define	HW_USERMEM	 6		/* int: non-kernel memory */
//#define	HW_PAGESIZE	 7		/* int: software page size */
//#define	HW_DISKNAMES	 8		/* strings: disk drive names */
//#define	HW_DISKSTATS	 9		/* struct: diskstats[] */
//#define HW_FLOATINGPT	10		/* int: has HW floating point? */
//#define HW_MACHINE_ARCH	11		/* string: machine architecture */
//#define HW_MACHINE_PLATFORM 12		/* string: platform architecture */
//#define HW_SENSORS	13		/* node: hardware sensors */
//#define HW_MAXID	14		/* number of valid hw ids */
//
//#define CTL_HW_NAMES { \
//	{ 0, 0 }, \
//	{ "machine", CTLTYPE_STRING }, \
//	{ "model", CTLTYPE_STRING }, \
//	{ "ncpu", CTLTYPE_INT }, \
//	{ "byteorder", CTLTYPE_INT }, \
//	{ "physmem", CTLTYPE_ULONG }, \
//	{ "usermem", CTLTYPE_UINT }, \
//	{ "pagesize", CTLTYPE_INT }, \
//	{ "disknames", CTLTYPE_STRUCT }, \
//	{ "diskstats", CTLTYPE_STRUCT }, \
//	{ "floatingpoint", CTLTYPE_INT }, \
//	{ "arch", CTLTYPE_STRING }, \
//	{ "platform", CTLTYPE_STRING }, \
//	{ "sensors", CTLTYPE_NODE }, \
//}
//
///*
// * CTL_USER definitions
// */
//#define	USER_CS_PATH		 1	/* string: _CS_PATH */
//#define	USER_BC_BASE_MAX	 2	/* int: BC_BASE_MAX */
//#define	USER_BC_DIM_MAX		 3	/* int: BC_DIM_MAX */
//#define	USER_BC_SCALE_MAX	 4	/* int: BC_SCALE_MAX */
//#define	USER_BC_STRING_MAX	 5	/* int: BC_STRING_MAX */
//#define	USER_COLL_WEIGHTS_MAX	 6	/* int: COLL_WEIGHTS_MAX */
//#define	USER_EXPR_NEST_MAX	 7	/* int: EXPR_NEST_MAX */
//#define	USER_LINE_MAX		 8	/* int: LINE_MAX */
//#define	USER_RE_DUP_MAX		 9	/* int: RE_DUP_MAX */
//#define	USER_POSIX2_VERSION	10	/* int: POSIX2_VERSION */
//#define	USER_POSIX2_C_BIND	11	/* int: POSIX2_C_BIND */
//#define	USER_POSIX2_C_DEV	12	/* int: POSIX2_C_DEV */
//#define	USER_POSIX2_CHAR_TERM	13	/* int: POSIX2_CHAR_TERM */
//#define	USER_POSIX2_FORT_DEV	14	/* int: POSIX2_FORT_DEV */
//#define	USER_POSIX2_FORT_RUN	15	/* int: POSIX2_FORT_RUN */
//#define	USER_POSIX2_LOCALEDEF	16	/* int: POSIX2_LOCALEDEF */
//#define	USER_POSIX2_SW_DEV	17	/* int: POSIX2_SW_DEV */
//#define	USER_POSIX2_UPE		18	/* int: POSIX2_UPE */
//#define	USER_STREAM_MAX		19	/* int: POSIX2_STREAM_MAX */
//#define	USER_TZNAME_MAX		20	/* int: POSIX2_TZNAME_MAX */
//#define	USER_MAXID		21	/* number of valid user ids */
//
//#define	CTL_USER_NAMES { \
//	{ 0, 0 }, \
//	{ "cs_path", CTLTYPE_STRING }, \
//	{ "bc_base_max", CTLTYPE_INT }, \
//	{ "bc_dim_max", CTLTYPE_INT }, \
//	{ "bc_scale_max", CTLTYPE_INT }, \
//	{ "bc_string_max", CTLTYPE_INT }, \
//	{ "coll_weights_max", CTLTYPE_INT }, \
//	{ "expr_nest_max", CTLTYPE_INT }, \
//	{ "line_max", CTLTYPE_INT }, \
//	{ "re_dup_max", CTLTYPE_INT }, \
//	{ "posix2_version", CTLTYPE_INT }, \
//	{ "posix2_c_bind", CTLTYPE_INT }, \
//	{ "posix2_c_dev", CTLTYPE_INT }, \
//	{ "posix2_char_term", CTLTYPE_INT }, \
//	{ "posix2_fort_dev", CTLTYPE_INT }, \
//	{ "posix2_fort_run", CTLTYPE_INT }, \
//	{ "posix2_localedef", CTLTYPE_INT }, \
//	{ "posix2_sw_dev", CTLTYPE_INT }, \
//	{ "posix2_upe", CTLTYPE_INT }, \
//	{ "stream_max", CTLTYPE_INT }, \
//	{ "tzname_max", CTLTYPE_INT }, \
//}
//
//#define CTL_P1003_1B_ASYNCHRONOUS_IO		1	/* boolean */
//#define CTL_P1003_1B_MAPPED_FILES		2	/* boolean */
//#define CTL_P1003_1B_MEMLOCK			3	/* boolean */
//#define CTL_P1003_1B_MEMLOCK_RANGE		4	/* boolean */
//#define CTL_P1003_1B_MEMORY_PROTECTION		5	/* boolean */
//#define CTL_P1003_1B_MESSAGE_PASSING		6	/* boolean */
//#define CTL_P1003_1B_PRIORITIZED_IO		7	/* boolean */
//#define CTL_P1003_1B_PRIORITY_SCHEDULING	8	/* boolean */
//#define CTL_P1003_1B_REALTIME_SIGNALS		9	/* boolean */
//#define CTL_P1003_1B_SEMAPHORES			10	/* boolean */
//#define CTL_P1003_1B_FSYNC			11	/* boolean */
//#define CTL_P1003_1B_SHARED_MEMORY_OBJECTS	12	/* boolean */
//#define CTL_P1003_1B_SYNCHRONIZED_IO		13	/* boolean */
//#define CTL_P1003_1B_TIMERS			14	/* boolean */
//#define CTL_P1003_1B_AIO_LISTIO_MAX		15	/* int */
//#define CTL_P1003_1B_AIO_MAX			16	/* int */
//#define CTL_P1003_1B_AIO_PRIO_DELTA_MAX		17	/* int */
//#define CTL_P1003_1B_DELAYTIMER_MAX		18	/* int */
//#define CTL_P1003_1B_UNUSED1			19	/* int */
//#define CTL_P1003_1B_PAGESIZE			20	/* int */
//#define CTL_P1003_1B_RTSIG_MAX			21	/* int */
//#define CTL_P1003_1B_SEM_NSEMS_MAX		22	/* int */
//#define CTL_P1003_1B_SEM_VALUE_MAX		23	/* int */
//#define CTL_P1003_1B_SIGQUEUE_MAX		24	/* int */
//#define CTL_P1003_1B_TIMER_MAX			25	/* int */
//
//#define CTL_P1003_1B_MAXID		26
//
//#define	CTL_P1003_1B_NAMES { \
//	{ 0, 0 }, \
//	{ "asynchronous_io", CTLTYPE_INT }, \
//	{ "mapped_files", CTLTYPE_INT }, \
//	{ "memlock", CTLTYPE_INT }, \
//	{ "memlock_range", CTLTYPE_INT }, \
//	{ "memory_protection", CTLTYPE_INT }, \
//	{ "message_passing", CTLTYPE_INT }, \
//	{ "prioritized_io", CTLTYPE_INT }, \
//	{ "priority_scheduling", CTLTYPE_INT }, \
//	{ "realtime_signals", CTLTYPE_INT }, \
//	{ "semaphores", CTLTYPE_INT }, \
//	{ "fsync", CTLTYPE_INT }, \
//	{ "shared_memory_objects", CTLTYPE_INT }, \
//	{ "synchronized_io", CTLTYPE_INT }, \
//	{ "timers", CTLTYPE_INT }, \
//	{ "aio_listio_max", CTLTYPE_INT }, \
//	{ "aio_max", CTLTYPE_INT }, \
//	{ "aio_prio_delta_max", CTLTYPE_INT }, \
//	{ "delaytimer_max", CTLTYPE_INT }, \
//	{ "unused1", CTLTYPE_INT }, \
//	{ "pagesize", CTLTYPE_INT }, \
//	{ "rtsig_max", CTLTYPE_INT }, \
//	{ "nsems_max", CTLTYPE_INT }, \
//	{ "sem_value_max", CTLTYPE_INT }, \
//	{ "sigqueue_max", CTLTYPE_INT }, \
//	{ "timer_max", CTLTYPE_INT }, \
//}
//
//#ifdef _KERNEL
//
///*
// * Declare some common oids.
// */
//extern struct sysctl_oid_list sysctl__children;
//SYSCTL_DECL(_kern);
//SYSCTL_DECL(_sysctl);
//SYSCTL_DECL(_vm);
//SYSCTL_DECL(_vfs);
//SYSCTL_DECL(_net);
//SYSCTL_DECL(_debug);
//SYSCTL_DECL(_debug_sizeof);
//SYSCTL_DECL(_hw);
//SYSCTL_DECL(_hw_bus);
//SYSCTL_DECL(_machdep);
//SYSCTL_DECL(_user);
//SYSCTL_DECL(_compat);
//SYSCTL_DECL(_lwkt);
//SYSCTL_DECL(_security);
//SYSCTL_DECL(_dsched);
//
///*
// * Common second-level oids.
// */
//SYSCTL_DECL(_kern_ipc);
//
//extern char	machine[];
//extern char	osrelease[];
//extern char	ostype[];
//extern char	kern_ident[];
//
///* Dynamic oid handling */
//struct sysctl_oid *sysctl_add_oid(struct sysctl_ctx_list *clist,
//		struct sysctl_oid_list *parent, int nbr, const char *name,
//		int kind, void *arg1, int arg2,
//		int (*handler) (SYSCTL_HANDLER_ARGS),
//		const char *fmt, const char *descr);
//int	sysctl_remove_oid(struct sysctl_oid *oidp, int del, int recurse);
//int	sysctl_ctx_init(struct sysctl_ctx_list *clist);
//int	sysctl_ctx_free(struct sysctl_ctx_list *clist);
//struct	sysctl_ctx_entry *sysctl_ctx_entry_add(struct sysctl_ctx_list *clist,
//		struct sysctl_oid *oidp);
//struct	sysctl_ctx_entry *sysctl_ctx_entry_find(struct sysctl_ctx_list *clist,
//		struct sysctl_oid *oidp);
//int	sysctl_ctx_entry_del(struct sysctl_ctx_list *clist,
//		struct sysctl_oid *oidp);
//
//int	kernel_sysctl(int *name, u_int namelen, void *old,
//		      size_t *oldlenp, void *new, size_t newlen,
//		      size_t *retval);
//int	kernel_sysctlbyname(char *name,
//		void *old, size_t *oldlenp, void *new, size_t newlen,
//		size_t *retval);
//int	userland_sysctl(int *name, u_int namelen, void *old,
//			size_t *oldlenp, int inkernel, void *new, size_t newlen,
//			size_t *retval);
//int	sysctl_find_oid(int *name, u_int namelen, struct sysctl_oid **noid,
//			int *nindx, struct sysctl_req *req);
//
//int	sysctl_int_range(SYSCTL_HANDLER_ARGS, int low, int high);
//
//#endif	/* _KERNEL */
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//
//#include <sys/cdefs.h>
//
//__BEGIN_DECLS
//int	sysctl (int *, u_int, void *, size_t *, void *, size_t);
//int	sysctlbyname (const char *, void *, size_t *, void *, size_t);
//int	sysctlnametomib (const char *, int *, size_t *);
//__END_DECLS
//
//#endif	/* _KERNEL && _KERNEL_VIRTUAL */
//
//#endif	/* !_SYS_SYSCTL_H_ */




	// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/fcntl.h
/*
 * File status flags: these are used by open(2), fcntl(2).
 * They are also used (indirectly) in the kernel file structure f_flags,
 * which is a superset of the open/fcntl flags.  Open flags and f_flags
 * are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
 * Open/fcntl flags begin with O_; kernel-internal flags begin with F.
 */
/* open-only flags */
O_RDONLY	= 0x0000		/* open for reading only */
O_WRONLY	= 0x0001		/* open for writing only */
O_RDWR		= 0x0002		/* open for reading and writing */
O_ACCMODE	= 0x0003		/* mask for above modes */

///*
// * Kernel encoding of open mode; separate read and write bits that are
// * independently testable: 1 greater than the above.
// *
// * XXX
// * FREAD and FWRITE are excluded from the #ifdef _KERNEL so that TIOCFLUSH,
// * which was documented to use FREAD/FWRITE, continues to work.
// */
//#ifndef _POSIX_SOURCE
	FREAD		= 0x0001
	FWRITE		= 0x0002
//#endif
	O_NONBLOCK	= 0x0004		/* no delay */
	O_APPEND	= 0x0008		/* set append mode */
//#ifndef _POSIX_SOURCE
	O_SHLOCK	= 0x0010		/* open with shared file lock */
	O_EXLOCK	= 0x0020		/* open with exclusive file lock */
	O_ASYNC		= 0x0040		/* signal pgrp when data ready */
	O_FSYNC		= 0x0080		/* synchronous writes */
	O_NOFOLLOW	= 0x0100		/* don't follow symlinks */
//#endif
	O_SYNC		= 0x0080		/* Same as O_FSYNC, but POSIX */
	O_CREAT		= 0x0200		/* create if nonexistent */
	O_TRUNC		= 0x0400		/* truncate to zero length */
	O_EXCL		= 0x0800		/* error if already exists */
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
	FMARK		= 0x1000		/* mark during gc() */
	FDEFER		= 0x2000		/* defer for next gc pass */
	FHASLOCK	= 0x4000		/* descriptor holds advisory lock */
//#endif
//
///* Defined by POSIX 1003.1; BSD default, but must be distinct from O_RDONLY. */
	O_NOCTTY	= 0x8000		/* don't assign controlling terminal */
//
///* Attempt to bypass the buffer cache */
	O_DIRECT	= 0x00010000
//
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
	O_CLOEXEC	= 0x00020000	/* atomically set FD_CLOEXEC */
//#endif
	O_FBLOCKING	= 0x00040000	/* force blocking I/O */
	O_FNONBLOCKING	= 0x00080000	/* force non-blocking I/O */
	O_FAPPEND	= 0x00100000	/* force append mode for write */
	O_FOFFSET	= 0x00200000	/* force specific offset */
	O_FSYNCWRITE	= 0x00400000	/* force synchronous write */
	O_FASYNCWRITE	= 0x00800000	/* force asynchronous write */
	O_FUNBUFFERED	= 0x01000000	/* force unbuffered (direct) I/O */
	O_FBUFFERED	= 0x02000000	/* force buffered I/O */
	O_MAPONREAD	= 0x04000000	/* memory map read buffer */
//
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
//#define O_DIRECTORY	= 0x08000000	/* error if not a directory */
//#endif
//
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
	FREVOKED	= 0x10000000	/* revoked by fdrevoke() */
	FAPPENDONLY	= 0x20000000	/* O_APPEND cannot be changed */
	FOFFSETLOCK	= 0x40000000	/* f_offset locked */
	FOFFSETWAKE	= 0x80000000	/* f_offset wakeup */
//#endif
//
//#define O_FMASK		(O_FBLOCKING|O_FNONBLOCKING|O_FAPPEND|O_FOFFSET|\
//			 O_FSYNCWRITE|O_FASYNCWRITE|O_FUNBUFFERED|O_FBUFFERED|\
//			 O_MAPONREAD)
//
//#ifdef _KERNEL
///* convert from open() flags to/from fflags; convert O_RD/WR to FREAD/FWRITE */
//#define	= FFLAGS(oflags)	((oflags) + 1)
//#define	= OFLAGS(fflags)	((fflags) - 1)
//
///* bits to save after open */
//#define	FMASK		= (FREAD|FWRITE|FAPPEND|FASYNC|FFSYNC|FNONBLOCK|\
//			 FAPPENDONLY|FREVOKED|O_DIRECT|O_MAPONREAD)
///* bits settable by fcntl(F_SETFL, ...) */
//#define	FCNTLFLAGS	= (FAPPEND|FASYNC|FFSYNC|FNONBLOCK|FPOSIXSHM|\
//			 O_DIRECT|O_MAPONREAD)
//#endif
//
///*
// * The O_* flags used to have only F* names, which were used in the kernel
// * and by fcntl.  We retain the F* names for the kernel f_flag field
// * and for backward compatibility for fcntl.
// */
//#ifndef _POSIX_SOURCE
	FAPPEND		= O_APPEND	/* kernel/compat */
	FASYNC		= O_ASYNC		/* kernel/compat */
	FFSYNC		= O_FSYNC		/* kernel */
	FNONBLOCK	= O_NONBLOCK	/* kernel */
	FNDELAY		= O_NONBLOCK	/* compat */
	O_NDELAY	= O_NONBLOCK	/* compat */
//#endif
//
///*
// * We are out of bits in f_flag (which is a short).  However,
// * the flag bits not set in FMASK are only meaningful in the
// * initial open syscall.  Those bits can thus be given a
// * different meaning for fcntl(2).
// */
//#ifndef _POSIX_SOURCE
//
///*
// * Set by shm_open(3) to get automatic MAP_ASYNC behavior
// * for POSIX shared memory objects (which are otherwise
// * implemented as plain files).
// */
	FPOSIXSHM	= O_NOFOLLOW
//#endif
//
///*
// * Constants used by "at" family of system calls.
// */
	AT_FDCWD		= 0xFFFAFDCD	/* invalid file descriptor */
	AT_SYMLINK_NOFOLLOW	= 1
	AT_REMOVEDIR		= 2
	AT_EACCESS		= 4
	AT_SYMLINK_FOLLOW	= 8
//
///*
// * Constants used for fcntl(2)
// */
//
///* command values */
	F_DUPFD		= 0		/* duplicate file descriptor */
	F_GETFD		= 1		/* get file descriptor flags */
	F_SETFD		= 2		/* set file descriptor flags */
	F_GETFL		= 3		/* get file status flags */
	F_SETFL		= 4		/* set file status flags */
//#ifndef _POSIX_SOURCE
	F_GETOWN	= 5		/* get SIGIO/SIGURG proc/pgrp */
	F_SETOWN	= 6		/* set SIGIO/SIGURG proc/pgrp */
//#endif
	F_GETLK		= 7		/* get record locking information */
	F_SETLK		= 8		/* set record locking information */
	F_SETLKW	= 9		/* F_SETLK; wait if blocked */
	F_DUP2FD	= 10		/* duplicate file descriptor to arg */
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
	F_DUPFD_CLOEXEC	= 17		/* Like F_DUPFD with FD_CLOEXEC set */
//#endif
//#if __BSD_VISIBLE
	F_DUP2FD_CLOEXEC = 18		/* Like F_DUP2FD with FD_CLOEXEC set */
//#endif
//
///* file descriptor flags (F_GETFD, F_SETFD) */
	FD_CLOEXEC	= 1		/* close-on-exec flag */
//
///* record locking flags (F_GETLK, F_SETLK, F_SETLKW) */
	F_RDLCK		= 1		/* shared or read lock */
	F_UNLCK		= 2		/* unlock */
	F_WRLCK		= 3		/* exclusive or write lock */
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
	F_WAIT		= 0x010		/* Wait until lock is granted */
	F_UNUSED020	= 0x020
	F_POSIX		= 0x040	 	/* Use POSIX semantics for lock */
	F_NOEND		= 0x080		/* l_len = 0, internally used */
//#endif
//
//
///*
// * Advisory file segment locking data type -
// * information passed to system by user
// */
//struct flock {
//	off_t	l_start;	/* starting offset */
//	off_t	l_len;		/* len = 0 means until end of file */
//	pid_t	l_pid;		/* lock owner */
//	short	l_type;		/* lock type: read/write, etc. */
//	short	l_whence;	/* type of l_start */
//};
//
//#ifdef _KERNEL
//union fcntl_dat {
//	int		fc_fd;		/* F_DUPFD */
//	int		fc_cloexec;	/* F_GETFD/F_SETFD */
//	int		fc_flags;	/* F_GETFL/F_SETFL */
//	int		fc_owner;	/* F_GETOWN/F_SETOWN */
//	struct flock	fc_flock;	/* F_GETLK/F_SETLK */
//};
//#endif /* _KERNEL */
//
//
//#ifndef _POSIX_SOURCE
///* lock operations for flock(2) */
	LOCK_SH		= 0x01		/* shared file lock */
	LOCK_EX		= 0x02		/* exclusive file lock */
	LOCK_NB		= 0x04		/* don't block when locking */
	LOCK_UN		= 0x08		/* unlock file */
//#endif
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//#include <sys/cdefs.h>
//
//__BEGIN_DECLS
//int	open (const char *, int, ...);
//#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809
//int	openat (int, const char *, int, ...);
//#endif
//int	creat (const char *, mode_t);
//int	fcntl (int, int, ...);
//#ifndef _POSIX_SOURCE
//int	flock (int, int);
//#endif /* !_POSIX_SOURCE */
//__END_DECLS
//#endif
//
//#endif /* !_SYS_FCNTL_H_ */



// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/ttycom.h
///*-
// * Copyright (c) 1982, 1986, 1990, 1993, 1994
// *	The Regents of the University of California.  All rights reserved.
// * (c) UNIX System Laboratories, Inc.
// * All or some portions of this file are derived from material licensed
// * to the University of California by American Telephone and Telegraph
// * Co. or Unix System Laboratories, Inc. and are reproduced herein with
// * the permission of UNIX System Laboratories, Inc.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)ttycom.h	8.1 (Berkeley) 3/28/94
// * $FreeBSD: src/sys/sys/ttycom.h,v 1.16 2000/01/29 16:47:35 peter Exp $
// * $DragonFly: src/sys/sys/ttycom.h,v 1.3 2007/12/30 20:02:57 hasso Exp $
// */
//
//#ifndef	_SYS_TTYCOM_H_
//#define	_SYS_TTYCOM_H_
//
//#include <sys/ioccom.h>
//
///*
// * Tty ioctl's except for those supported only for backwards compatibility
// * with the old tty driver.
// */
//
///*
// * Window/terminal size structure.  This information is stored by the kernel
// * in order to provide a consistent interface, but is not used by the kernel.
// */
//struct winsize {
//	unsigned short	ws_row;		/* rows, in characters */
//	unsigned short	ws_col;		/* columns, in characters */
//	unsigned short	ws_xpixel;	/* horizontal size, pixels */
//	unsigned short	ws_ypixel;	/* vertical size, pixels */
//};
//

// Macros defined in http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/ioccom.h
//#define _IO(g,n)        _IOC(IOC_VOID,  (g), (n), 0)

//#define	TIOCMODG	_IOR('t', 3, int)	/* get modem control state */
//#define	TIOCMODS	_IOW('t', 4, int)	/* set modem control state */
//#define		TIOCM_LE	0001		/* line enable */
//#define		TIOCM_DTR	0002		/* data terminal ready */
//#define		TIOCM_RTS	0004		/* request to send */
//#define		TIOCM_ST	0010		/* secondary transmit */
//#define		TIOCM_SR	0020		/* secondary receive */
//#define		TIOCM_CTS	0040		/* clear to send */
//#define		TIOCM_CAR	0100		/* carrier detect */
//#define		TIOCM_CD	TIOCM_CAR
//#define		TIOCM_RNG	0200		/* ring */
//#define		TIOCM_RI	TIOCM_RNG
//#define		TIOCM_DSR	0400		/* data set ready */
//						/* 8-10 compat */
//#define	TIOCEXCL	 _IO('t', 13)		/* set exclusive use of tty */
TIOCEXCL = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((13))))
//#define	TIOCNXCL	 _IO('t', 14)		/* reset exclusive use of tty */
TIOCNXCL = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((14))))
//						/* 15 unused */
//#define	TIOCFLUSH	_IOW('t', 16, int)	/* flush buffers */
//						/* 17-18 compat */
//#define	TIOCGETA	_IOR('t', 19, struct termios) /* get termios struct */
//#define	TIOCSETA	_IOW('t', 20, struct termios) /* set termios struct */
//#define	TIOCSETAW	_IOW('t', 21, struct termios) /* drain output, set */
//#define	TIOCSETAF	_IOW('t', 22, struct termios) /* drn out, fls in, set */
//#define	TIOCGETD	_IOR('t', 26, int)	/* get line discipline */
//#define	TIOCSETD	_IOW('t', 27, int)	/* set line discipline */
//						/* 127-124 compat */
//#define	TIOCSBRK	 _IO('t', 123)		/* set break bit */
TIOCSBRK = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((123))))
//#define	TIOCCBRK	 _IO('t', 122)		/* clear break bit */
TIOCCBRK = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((122))))
//#define	TIOCSDTR	 _IO('t', 121)		/* set data terminal ready */
TIOCSDTR = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((121))))
//#define	TIOCCDTR	 _IO('t', 120)		/* clear data terminal ready */
TIOCCDTR = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((120))))
//#define	TIOCGPGRP	_IOR('t', 119, int)	/* get pgrp of tty */
//#define	TIOCSPGRP	_IOW('t', 118, int)	/* set pgrp of tty */
//						/* 117-116 compat */
//#define	TIOCOUTQ	_IOR('t', 115, int)	/* output queue size */
//#define	TIOCSTI		_IOW('t', 114, char)	/* simulate terminal input */
//#define	TIOCNOTTY	 _IO('t', 113)		/* void tty association */
TIOCNOTTY = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((113))))

//#define	TIOCPKT		_IOW('t', 112, int)	/* pty: set/clear packet mode */
		TIOCPKT_DATA		= 0x00	/* data packet */
		TIOCPKT_FLUSHREAD	= 0x01	/* flush packet */
		TIOCPKT_FLUSHWRITE	= 0x02	/* flush packet */
		TIOCPKT_STOP		= 0x04	/* stop output */
		TIOCPKT_START		= 0x08	/* start output */
		TIOCPKT_NOSTOP		= 0x10	/* no more ^S, ^Q */
		TIOCPKT_DOSTOP		= 0x20	/* now do ^S ^Q */
		TIOCPKT_IOCTL		= 0x40	/* state change of pty driver */
//#define	TIOCSTOP	 _IO('t', 111)		/* stop output, like ^S */
TIOCSTOP = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((111))))
//#define	TIOCSTART	 _IO('t', 110)		/* start output, like ^Q */
TIOCSTART = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((110))))
//#define	TIOCMSET	_IOW('t', 109, int)	/* set all modem bits */
//#define	TIOCMBIS	_IOW('t', 108, int)	/* bis modem bits */
//#define	TIOCMBIC	_IOW('t', 107, int)	/* bic modem bits */
//#define	TIOCMGET	_IOR('t', 106, int)	/* get all modem bits */
//#define	TIOCREMOTE	_IOW('t', 105, int)	/* remote input editing */
//#define	TIOCGWINSZ	_IOR('t', 104, struct winsize)	/* get window size */
//#define	TIOCSWINSZ	_IOW('t', 103, struct winsize)	/* set window size */
//#define	TIOCUCNTL	_IOW('t', 102, int)	/* pty: set/clr usr cntl mode */
//#define	TIOCSTAT	 _IO('t', 101)		/* simulate ^T status message */
TIOCSTAT = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((101))))
//#define		UIOCCMD(n)	_IO('u', n)	/* usr cntl op "n" */
//#define	TIOCGSID	_IOR('t', 99, int)	/* get session id */
//#define	TIOCCONS	_IOW('t', 98, int)	/* become virtual console */
//#define	TIOCSCTTY	 _IO('t', 97)		/* become controlling tty */

TIOCSCTTY = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((97))))

//#define	TIOCEXT		_IOW('t', 96, int)	/* pty: external processing */
//#define	TIOCSIG		 _IO('t', 95)		/* pty: generate signal */
TIOCSIG = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((95))))
//#define	TIOCDRAIN	 _IO('t', 94)		/* wait till output drained */
TIOCDRAIN = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((94))))
//#define	TIOCMSDTRWAIT	_IOW('t', 91, int)	/* modem: set wait on close */
//#define	TIOCMGDTRWAIT	_IOR('t', 90, int)	/* modem: get wait on close */
//#define	TIOCTIMESTAMP	_IOR('t', 89, struct timeval)	/* enable/get timestamp
//						 * of last input event */
//#define	TIOCDCDTIMESTAMP _IOR('t', 88, struct timeval)	/* enable/get timestamp
//						 * of last DCd rise */
//#define	TIOCSDRAINWAIT	_IOW('t', 87, int)	/* set ttywait timeout */
//#define	TIOCGDRAINWAIT	_IOR('t', 86, int)	/* get ttywait timeout */
//#define	TIOCISPTMASTER	_IO('t', 85)	/* is pty master */
TIOCISPTMASTER = (uint32(IOC_VOID | ((0 & IOCPARM_MASK) << 16) | ((('t')) << 8) | ((85))))
//
//#define	TTYDISC		0		/* termios tty line discipline */
//#define	SLIPDISC	4		/* serial IP discipline */
//#define	PPPDISC		5		/* PPP discipline */
//#define	NETGRAPHDISC	6		/* Netgraph tty node discipline */
//#define	BTUARTDISC	7		/* Bluetooth btuart discipline */
//
//#endif /* !_SYS_TTYCOM_H_ */


// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/ioccom.h

///*-
// * Copyright (c) 1982, 1986, 1990, 1993, 1994
// *	The Regents of the University of California.  All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)ioccom.h	8.2 (Berkeley) 3/28/94
// * $FreeBSD: src/sys/sys/ioccom.h,v 1.9 1999/12/29 04:24:42 peter Exp $
// * $DragonFly: src/sys/sys/ioccom.h,v 1.4 2007/01/10 13:33:22 swildner Exp $
// */
//
//#ifndef	_SYS_IOCCOM_H_
//#define	_SYS_IOCCOM_H_
//
///*
// * Ioctl's have the command encoded in the lower word, and the size of
// * any in or out parameters in the upper word.  The high 3 bits of the
// * upper word are used to encode the in/out status of the parameter.
// */
	IOCPARM_MASK	= 0x1fff		/* parameter length, at most 13 bits */
//#define	IOCPARM_LEN(x)	= (((x) >> 16) & IOCPARM_MASK)
//#define	IOCBASECMD(x)	= ((x) & ~(IOCPARM_MASK << 16))
	//IOCGROUP(x)	= (((x) >> 8) & 0xff)
//
//#define	IOCPARM_MAX	PAGE_SIZE		/* max size of ioctl, mult. of PAGE_SIZE */
	IOC_VOID	= 0x20000000	/* no parameters */
	IOC_OUT		= 0x40000000	/* copy out parameters */
	IOC_IN		= 0x80000000	/* copy in parameters */
	IOC_INOUT	= (IOC_IN|IOC_OUT)
	IOC_DIRMASK	= 0xe0000000	/* mask for IN/OUT/VOID */
//
//#define	_IOC(inout,group,num,len) \
//	((unsigned long)(inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num)))
//#define	_IO(g,n)	_IOC(IOC_VOID,	(g), (n), 0)
//#define	_IOR(g,n,t)	_IOC(IOC_OUT,	(g), (n), sizeof(t))
//#define	_IOW(g,n,t)	_IOC(IOC_IN,	(g), (n), sizeof(t))
///* this should be _IORW, but stdio got there first */
//#define	_IOWR(g,n,t)	_IOC(IOC_INOUT,	(g), (n), sizeof(t))
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//
//#include <sys/cdefs.h>
//
//__BEGIN_DECLS
//int	ioctl (int, unsigned long, ...);
//__END_DECLS
//
//#endif
//
//#endif /* !_SYS_IOCCOM_H_ */




// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/event.h

///*-
// * Copyright (c) 1999,2000,2001 Jonathan Lemon <jlemon@FreeBSD.org>
// * All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// *
// * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	$FreeBSD: src/sys/sys/event.h,v 1.5.2.6 2003/02/09 15:28:13 nectar Exp $
// *	$DragonFly: src/sys/sys/event.h,v 1.7 2007/01/15 01:26:56 dillon Exp $
// */
//
//#ifndef _SYS_EVENT_H_
//#define _SYS_EVENT_H_
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#ifndef _NET_NETISR_H_
//#include <net/netisr.h>			/* struct notifymsglist */
//#endif
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
//#include <sys/queue.h>
//#endif
//
	EVFILT_READ		= (-1)
	EVFILT_WRITE		= (-2)
	EVFILT_AIO		= (-3)	/* attached to aio requests */
	EVFILT_VNODE		= (-4)	/* attached to vnodes */
	EVFILT_PROC		= (-5)	/* attached to struct proc */
	EVFILT_SIGNAL		= (-6)	/* attached to struct proc */
	EVFILT_TIMER		= (-7)	/* timers */
	EVFILT_EXCEPT		= (-8)	/* exceptional conditions */
//
//#define EVFILT_MARKER		0xF	/* placemarker for tailq */
//
//#define EVFILT_SYSCOUNT		8
//
//#define EV_SET(kevp_, a, b, c, d, e, f) do {	\
//	struct kevent *kevp = (kevp_);		\
//	(kevp)->ident = (a);			\
//	(kevp)->filter = (b);			\
//	(kevp)->flags = (c);			\
//	(kevp)->fflags = (d);			\
//	(kevp)->data = (e);			\
//	(kevp)->udata = (f);			\
//} while(0)
//
//struct kevent {
//	uintptr_t	ident;		/* identifier for this event */
//	short		filter;		/* filter for event */
//	u_short		flags;
//	u_int		fflags;
//	intptr_t	data;
//	void		*udata;		/* opaque user data identifier */
//};
//
///* actions */
	EV_ADD		= 0x0001		/* add event to kq (implies enable) */
	EV_DELETE	= 0x0002		/* delete event from kq */
	EV_ENABLE	= 0x0004		/* enable event */
	EV_DISABLE	= 0x0008		/* disable event (not reported) */
//
///* flags */
	EV_ONESHOT	= 0x0010		/* only report one occurrence */
	EV_CLEAR	= 0x0020		/* clear event state after reporting */
//
	EV_SYSFLAGS	= 0xF000		/* reserved by system */
	EV_FLAG1	= 0x2000		/* filter-specific flag */
//
///* returned values */
	EV_EOF		= 0x8000		/* EOF detected */
	EV_ERROR	= 0x4000		/* error, data contains errno */
	EV_NODATA	= 0x1000		/* EOF and no more data */
//
///*
// * data/hint flags for EVFILT_{READ|WRITE}, shared with userspace
// */
//#define NOTE_LOWAT	0x0001			/* low water mark */
//
///*
// * data/hint flags for EVFILT_EXCEPT, shared with userspace and with
// * EVFILT_{READ|WRITE}
// */
//#define NOTE_OOB	0x0002			/* OOB data on a socket */
//
///*
// * data/hint flags for EVFILT_VNODE, shared with userspace
// */
//#define	NOTE_DELETE	0x0001			/* vnode was removed */
//#define	NOTE_WRITE	0x0002			/* data contents changed */
//#define	NOTE_EXTEND	0x0004			/* size increased */
//#define	NOTE_ATTRIB	0x0008			/* attributes changed */
//#define	NOTE_LINK	0x0010			/* link count changed */
//#define	NOTE_RENAME	0x0020			/* vnode was renamed */
//#define	NOTE_REVOKE	0x0040			/* vnode access was revoked */
//
///*
// * data/hint flags for EVFILT_PROC, shared with userspace
// */
//#define	NOTE_EXIT	0x80000000		/* process exited */
//#define	NOTE_FORK	0x40000000		/* process forked */
//#define	NOTE_EXEC	0x20000000		/* process exec'd */
//#define	NOTE_PCTRLMASK	0xf0000000		/* mask for hint bits */
//#define	NOTE_PDATAMASK	0x000fffff		/* mask for pid */
//
///* additional flags for EVFILT_PROC */
//#define	NOTE_TRACK	0x00000001		/* follow across forks */
//#define	NOTE_TRACKERR	0x00000002		/* could not track child */
//#define	NOTE_CHILD	0x00000004		/* am a child process */
//
//#if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
//
//struct knote;
//SLIST_HEAD(klist, knote);
//
///*
// * Used to maintain information about processes that wish to be
// * notified when I/O becomes possible.
// */
//struct kqinfo {
//	struct	klist ki_note;		/* kernel note list */
//	struct	notifymsglist ki_mlist;	/* list of pending predicate messages */
//};
//
//#endif
//
//#ifdef _KERNEL
//
///*
// * Global token for kqueue subsystem
// */
//extern struct lwkt_token kq_token;
//
//#ifdef MALLOC_DECLARE
//MALLOC_DECLARE(M_KQUEUE);
//#endif
//
//#define KNOTE(list, hint)	if ((list) != NULL) knote(list, hint)
//
///*
// * Flag indicating hint is a signal.  Used by EVFILT_SIGNAL, and also
// * shared by EVFILT_PROC  (all knotes attached to p->p_klist)
// *
// * NOTE_OLDAPI is used to signal that standard filters are being called
// * from the select/poll wrapper.
// */
//#define NOTE_SIGNAL	0x08000000
//#define NOTE_OLDAPI	0x04000000	/* select/poll note */
//
//#define FILTEROP_ISFD	0x0001		/* if ident == filedescriptor */
//#define FILTEROP_MPSAFE	0x0002
//
//struct filterops {
//	u_short	f_flags;
//
//	/* f_attach returns 0 on success or valid error code on failure */
//	int	(*f_attach)	(struct knote *kn);
//	void	(*f_detach)	(struct knote *kn);
//
//        /* f_event returns boolean truth */
//	int	(*f_event)	(struct knote *kn, long hint);
//};
//
//struct knote {
//	SLIST_ENTRY(knote)	kn_link;	/* for fd */
//	TAILQ_ENTRY(knote)	kn_kqlink;	/* for kq_knlist */
//	SLIST_ENTRY(knote)	kn_next;	/* for struct kqinfo */
//	TAILQ_ENTRY(knote)	kn_tqe;		/* for kq_head */
//	struct			kqueue *kn_kq;	/* which queue we are on */
//	struct 			kevent kn_kevent;
//	int			kn_status;
//	int			kn_sfflags;	/* saved filter flags */
//	intptr_t		kn_sdata;	/* saved data field */
//	union {
//		struct		file *p_fp;	/* file data pointer */
//		struct		proc *p_proc;	/* proc pointer */
//	} kn_ptr;
//	struct			filterops *kn_fop;
//	caddr_t			kn_hook;
//};
//
//#define KN_ACTIVE	0x0001			/* event has been triggered */
//#define KN_QUEUED	0x0002			/* event is on queue */
//#define KN_DISABLED	0x0004			/* event is disabled */
//#define KN_DETACHED	0x0008			/* knote is detached */
//#define KN_REPROCESS	0x0010			/* force reprocessing race */
//#define KN_DELETING	0x0020			/* deletion in progress */
//#define KN_PROCESSING	0x0040			/* event processing in prog */
//#define KN_WAITING	0x0080			/* waiting on processing */
//
//#define kn_id		kn_kevent.ident
//#define kn_filter	kn_kevent.filter
//#define kn_flags	kn_kevent.flags
//#define kn_fflags	kn_kevent.fflags
//#define kn_data		kn_kevent.data
//#define kn_fp		kn_ptr.p_fp
//
//struct proc;
//struct thread;
//struct filedesc;
//struct kevent_args;
//
//typedef int	(*k_copyout_fn)(void *arg, struct kevent *kevp, int count,
//    int *res);
//typedef int	(*k_copyin_fn)(void *arg, struct kevent *kevp, int max,
//    int *events);
//int kern_kevent(struct kqueue *kq, int nevents, int *res, void *uap,
//    k_copyin_fn kevent_copyin, k_copyout_fn kevent_copyout,
//    struct timespec *tsp);
//
//extern void	knote(struct klist *list, long hint);
//extern void	knote_insert(struct klist *klist, struct knote *kn);
//extern void	knote_remove(struct klist *klist, struct knote *kn);
///*extern void	knote_empty(struct klist *list);*/
//extern void	knote_assume_knotes(struct kqinfo *, struct kqinfo *,
//		    struct filterops *, void *);
//extern void	knote_fdclose(struct file *fp, struct filedesc *fdp, int fd);
//extern void	kqueue_init(struct kqueue *kq, struct filedesc *fdp);
//extern void	kqueue_terminate(struct kqueue *kq);
//extern int 	kqueue_register(struct kqueue *kq, struct kevent *kev);
//
//#endif 	/* _KERNEL */
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//
//#include <sys/cdefs.h>
//struct timespec;
//
//__BEGIN_DECLS
//int     kqueue (void);
//int     kevent (int, const struct kevent *, int, struct kevent *,
//		int, const struct timespec *);
//__END_DECLS
//#endif /* !_KERNEL */
//
//#endif /* !_SYS_EVENT_H_ */




)


// Errors
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/errno.h
const (
	EPERM		= Errno(1)		/* Operation not permitted */
	ENOENT		= Errno(2)		/* No such file or directory */
	ESRCH		= Errno(3)		/* No such process */
	EINTR		= Errno(4)		/* Interrupted system call */
	EIO		= Errno(5)		/* Input/output error */
	ENXIO		= Errno(6)		/* Device not configured */
	E2BIG		= Errno(7)		/* Argument list too long */
	ENOEXEC		= Errno(8)		/* Exec format error */
	EBADF		= Errno(9)		/* Bad file descriptor */
	ECHILD		= Errno(10)		/* No child processes */
	EDEADLK		= Errno(11)		/* Resource deadlock avoided */
						/* 11 was EAGAIN */
	ENOMEM		= Errno(12)		/* Cannot allocate memory */
	EACCES		= Errno(13)		/* Permission denied */
	EFAULT		= Errno(14)		/* Bad address */
	EBUSY		= Errno(16)		/* Device busy */
	EEXIST		= Errno(17)		/* File exists */
	EXDEV		= Errno(18)		/* Cross-device link */
	ENODEV		= Errno(19)		/* Operation not supported by device */
	ENOTDIR		= Errno(20)		/* Not a directory */
	EISDIR		= Errno(21)		/* Is a directory */
	EINVAL		= Errno(22)		/* Invalid argument */
	ENFILE		= Errno(23)		/* Too many open files in system */
	EMFILE		= Errno(24)		/* Too many open files */
	ENOTTY		= Errno(25)		/* Inappropriate ioctl for device */
	EFBIG		= Errno(27)		/* File too large */
	ENOSPC		= Errno(28)		/* No space left on device */
	ESPIPE		= Errno(29)		/* Illegal seek */
	EROFS		= Errno(30)		/* Read-only filesystem */
	EMLINK		= Errno(31)		/* Too many links */
	EPIPE		= Errno(32)		/* Broken pipe */

	/* math software */
	EDOM		= Errno(33)		/* Numerical argument out of domain */
	ERANGE		= Errno(34)		/* Result too large */

	/* non-blocking and interrupt i/o */
	EAGAIN		= Errno(35)		/* Resource temporarily unavailable */
	EWOULDBLOCK	= Errno(EAGAIN)		/* Operation would block */
	EINPROGRESS	= Errno(36)		/* Operation now in progress */
	EALREADY	= Errno(37)		/* Operation already in progress */

	/* ipc/network software -- argument errors */
	ENOTSOCK	= Errno(38)		/* Socket operation on non-socket */
	EDESTADDRREQ	= Errno(39)		/* Destination address required */
	EMSGSIZE	= Errno(40)		/* Message too long */
	EPROTOTYPE	= Errno(41)		/* Protocol wrong type for socket */
	ENOPROTOOPT	= Errno(42)		/* Protocol not available */
	EPROTONOSUPPORT	= Errno(43)		/* Protocol not supported */
	ESOCKTNOSUPPORT	= Errno(44)		/* Socket type not supported */
	EOPNOTSUPP	= Errno(45)		/* Operation not supported */
	ENOTSUP		= Errno(EOPNOTSUPP)	/* Operation not supported */
	EPFNOSUPPORT	= Errno(46)		/* Protocol family not supported */
	EAFNOSUPPORT	= Errno(47)		/* Address family not supported by protocol family */
	EADDRINUSE	= Errno(48)		/* Address already in use */
	EADDRNOTAVAIL	= Errno(49)		/* Can't assign requested address */

	/* ipc/network software -- operational errors */
	ENETDOWN	= Errno(50)		/* Network is down */
	ENETUNREACH	= Errno(51)		/* Network is unreachable */
	ENETRESET	= Errno(52)		/* Network dropped connection on reset */
	ECONNABORTED	= Errno(53)		/* Software caused connection abort */
	ECONNRESET	= Errno(54)		/* Connection reset by peer */
	ENOBUFS		= Errno(55)		/* No buffer space available */
	EISCONN		= Errno(56)		/* Socket is already connected */
	ENOTCONN	= Errno(57)		/* Socket is not connected */
	ESHUTDOWN	= Errno(58)		/* Can't send after socket shutdown */
	ETOOMANYREFS	= Errno(59)		/* Too many references: can't splice */
	ETIMEDOUT	= Errno(60)		/* Operation timed out */
	ECONNREFUSED	= Errno(61)		/* Connection refused */

	ELOOP		= Errno(62)		/* Too many levels of symbolic links */
	ENAMETOOLONG	= Errno(63)		/* File name too long */

	/* should be rearranged */
	ENOTEMPTY	= Errno(66)		/* Directory not empty */

	/* quotas & mush */

	ENOLCK		= Errno(77)		/* No locks available */
	ENOSYS		= Errno(78)		/* Function not implemented */

	EBADMSG		= Errno(89)		/* Bad message */
	EMULTIHOP	= Errno(90)		/* Multihop attempted */
	ENOLINK		= Errno(91)		/* Link has been severed */
	EPROTO		= Errno(92)		/* Protocol error */






// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/socket.h

///*
// * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
// *	The Regents of the University of California.  All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)socket.h	8.4 (Berkeley) 2/21/94
// * $FreeBSD: src/sys/sys/socket.h,v 1.39.2.7 2001/07/03 11:02:01 ume Exp $
// */
//
//#ifndef _SYS_SOCKET_H_
//#define	_SYS_SOCKET_H_
//
//#include <sys/_iovec.h>
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#include <machine/stdint.h>
//
//#define _NO_NAMESPACE_POLLUTION
//#include <machine/param.h>
//#undef _NO_NAMESPACE_POLLUTION
//
///*
// * Definitions related to sockets: types, address families, options.
// */
//
///*
// * Data types.
// */
//typedef __uint8_t	sa_family_t;
//
//#ifndef _SOCKLEN_T_DECLARED
//#define _SOCKLEN_T_DECLARED
//typedef __socklen_t	socklen_t;
//#endif
//
// 
///*
// * Types
// */
//#define	SOCK_STREAM	1		/* stream socket */
	SOCK_STREAM	= 1		/* stream socket */
//#define	SOCK_DGRAM	2		/* datagram socket */
	SOCK_DGRAM	= 2		/* datagram socket */
//#define	SOCK_RAW	3		/* raw-protocol interface */
	SOCK_RAW	= 3		/* raw-protocol interface */
//#define	SOCK_RDM	4		/* reliably-delivered message */
	SOCK_RDM	= 4		/* reliably-delivered message */
//#define	SOCK_SEQPACKET	5		/* sequenced packet stream */
	SOCK_SEQPACKET	= 5		/* sequenced packet stream */
//
///*
// * Option flags per-socket.
// */
//#define	SO_DEBUG	0x0001		/* turn on debugging info recording */
//#define	SO_ACCEPTCONN	0x0002		/* socket has had listen() */
//#define	SO_REUSEADDR	0x0004		/* allow local address reuse */
//#define	SO_KEEPALIVE	0x0008		/* keep connections alive */
//#define	SO_DONTROUTE	0x0010		/* just use interface addresses */
//#define	SO_BROADCAST	0x0020		/* permit sending of broadcast msgs */
//#define	SO_USELOOPBACK	0x0040		/* bypass hardware when possible */
//#define	SO_LINGER	0x0080		/* linger on close if data present */
//#define	SO_OOBINLINE	0x0100		/* leave received OOB data in line */
//#define	SO_REUSEPORT	0x0200		/* allow local address & port reuse */
//#define	SO_TIMESTAMP	0x0400		/* timestamp received dgram traffic */
//#define	SO_NOSIGPIPE	0x0800		/* no SIGPIPE from EPIPE */
//#define	SO_ACCEPTFILTER	0x1000		/* there is an accept filter */
//
///*
// * Additional options, not kept in so_options.
// */
//#define SO_SNDBUF	0x1001		/* send buffer size */
//#define SO_RCVBUF	0x1002		/* receive buffer size */
//#define SO_SNDLOWAT	0x1003		/* send low-water mark */
//#define SO_RCVLOWAT	0x1004		/* receive low-water mark */
//#define SO_SNDTIMEO	0x1005		/* send timeout */
//#define SO_RCVTIMEO	0x1006		/* receive timeout */
//#define	SO_ERROR	0x1007		/* get error status and clear */
//#define	SO_TYPE		0x1008		/* get socket type */
///*efine	SO_PRIVSTATE	0x1009		   get/deny privileged state */
//#define	SO_SNDSPACE	0x100a		/* get appr. send buffer free space */
//
///*
// * Structure used for manipulating linger option.
// */
//struct	linger {
//	int	l_onoff;		/* option on/off */
//	int	l_linger;		/* linger time */
//};
//
//struct	accept_filter_arg {
//	char	af_name[16];
//	char	af_arg[256-16];
//};
//
///*
// * Level number for (get/set)sockopt() to apply to socket itself.
// */
//#define	SOL_SOCKET	0xffff		/* options for socket level */
//
///*
// * Address families.
// */
//#define	AF_UNSPEC	0		/* unspecified */
//#define	AF_LOCAL	1		/* local to host (pipes, portals) */
//#define	AF_UNIX		AF_LOCAL	/* backward compatibility */
//#define	AF_INET		2		/* internetwork: UDP, TCP, etc. */
//#define	AF_IMPLINK	3		/* arpanet imp addresses */
//#define	AF_PUP		4		/* pup protocols: e.g. BSP */
//#define	AF_CHAOS	5		/* mit CHAOS protocols */
//#define	AF_NS		6		/* XEROX NS protocols */
//#define	AF_ISO		7		/* ISO protocols */
//#define	AF_OSI		AF_ISO
//#define	AF_ECMA		8		/* European computer manufacturers */
//#define	AF_DATAKIT	9		/* datakit protocols */
//#define	AF_CCITT	10		/* CCITT protocols, X.25 etc */
//#define	AF_SNA		11		/* IBM SNA */
//#define AF_DECnet	12		/* DECnet */
//#define AF_DLI		13		/* DEC Direct data link interface */
//#define AF_LAT		14		/* LAT */
//#define	AF_HYLINK	15		/* NSC Hyperchannel */
//#define	AF_APPLETALK	16		/* Apple Talk */
//#define	AF_ROUTE	17		/* Internal Routing Protocol */
//#define	AF_LINK		18		/* Link layer interface */
//#define	pseudo_AF_XTP	19		/* eXpress Transfer Protocol (no AF) */
//#define	AF_COIP		20		/* connection-oriented IP, aka ST II */
//#define	AF_CNT		21		/* Computer Network Technology */
//#define pseudo_AF_RTIP	22		/* Help Identify RTIP packets */
//#define	AF_IPX		23		/* Novell Internet Protocol */
//#define	AF_SIP		24		/* Simple Internet Protocol */
//#define	pseudo_AF_PIP	25		/* Help Identify PIP packets */
//#define	AF_ISDN		26		/* Integrated Services Digital Network*/
//#define	AF_E164		AF_ISDN		/* CCITT E.164 recommendation */
//#define	pseudo_AF_KEY	27		/* Internal key-management function */
//#define	AF_INET6	28		/* IPv6 */
//#define	AF_NATM		29		/* native ATM access */
//#define	AF_ATM		30		/* ATM */
//#define pseudo_AF_HDRCMPLT 31		/* Used by BPF to not rewrite headers
//					 * in interface output routine
//					 */
//#define	AF_NETGRAPH	32		/* Netgraph sockets */
//#define	AF_BLUETOOTH	33		/* Bluetooth */
//#define	AF_MPLS		34		/* Multi-Protocol Label Switching */
//#define	AF_IEEE80211	35		/* IEEE 802.11 protocol */
//
//#define	AF_MAX		36
//
///*
// * Structure used by kernel to store most
// * addresses.
// */
//struct sockaddr {
//	__uint8_t	sa_len;		/* total length */
//	sa_family_t	sa_family;	/* address family */
//	char		sa_data[14];	/* actually longer; address value */
//};
//#define	SOCK_MAXADDRLEN	255		/* longest possible addresses */
//
//#ifdef _KERNEL
//
//#ifndef _SYS_LIBKERN_H_
//#include <sys/libkern.h>		/* for bcmp() */
//#endif
//
//static __inline boolean_t
//sa_equal(const struct sockaddr *a1, const struct sockaddr *a2)
//{
//	return (bcmp(a1, a2, a1->sa_len) == 0);
//}
//#endif
//
///*
// * Structure used by kernel to pass protocol
// * information in raw sockets.
// */
//struct sockproto {
//	__uint16_t	sp_family;		/* address family */
//	__uint16_t	sp_protocol;		/* protocol */
//};
//
///*
// * RFC 2553: protocol-independent placeholder for socket addresses
// */
//#define	_SS_MAXSIZE	128
//#define	_SS_ALIGNSIZE	(sizeof(int64_t))
//#define	_SS_PAD1SIZE	(_SS_ALIGNSIZE - sizeof(unsigned char) - sizeof(sa_family_t))
//#define	_SS_PAD2SIZE	(_SS_MAXSIZE - sizeof(unsigned char) - sizeof(sa_family_t) - \
//				_SS_PAD1SIZE - _SS_ALIGNSIZE)
//
//struct sockaddr_storage {
//	__uint8_t	ss_len;		/* address length */
//	sa_family_t	ss_family;	/* address family */
//	char		__ss_pad1[_SS_PAD1SIZE];
//	__int64_t	__ss_align;	/* force desired structure storage alignment */
//	char		__ss_pad2[_SS_PAD2SIZE];
//};
//
///*
// * Protocol families, same as address families for now.
// */
//#define	PF_UNSPEC	AF_UNSPEC
//#define	PF_LOCAL	AF_LOCAL
//#define	PF_UNIX		PF_LOCAL	/* backward compatibility */
//#define	PF_INET		AF_INET
//#define	PF_IMPLINK	AF_IMPLINK
//#define	PF_PUP		AF_PUP
//#define	PF_CHAOS	AF_CHAOS
//#define	PF_NS		AF_NS
//#define	PF_ISO		AF_ISO
//#define	PF_OSI		AF_ISO
//#define	PF_ECMA		AF_ECMA
//#define	PF_DATAKIT	AF_DATAKIT
//#define	PF_CCITT	AF_CCITT
//#define	PF_SNA		AF_SNA
//#define PF_DECnet	AF_DECnet
//#define PF_DLI		AF_DLI
//#define PF_LAT		AF_LAT
//#define	PF_HYLINK	AF_HYLINK
//#define	PF_APPLETALK	AF_APPLETALK
//#define	PF_ROUTE	AF_ROUTE
//#define	PF_LINK		AF_LINK
//#define	PF_XTP		pseudo_AF_XTP	/* really just proto family, no AF */
//#define	PF_COIP		AF_COIP
//#define	PF_CNT		AF_CNT
//#define	PF_SIP		AF_SIP
//#define	PF_IPX		AF_IPX		/* same format as AF_NS */
//#define PF_RTIP		pseudo_AF_RTIP	/* same format as AF_INET */
//#define PF_PIP		pseudo_AF_PIP
//#define	PF_ISDN		AF_ISDN
//#define	PF_KEY		pseudo_AF_KEY
//#define	PF_INET6	AF_INET6
//#define	PF_NATM		AF_NATM
//#define	PF_ATM		AF_ATM
//#define	PF_NETGRAPH	AF_NETGRAPH
//#define	PF_BLUETOOTH	AF_BLUETOOTH
//
//#define	PF_MAX		AF_MAX
//
///*
// * Definitions for network related sysctl, CTL_NET.
// *
// * Second level is protocol family.
// * Third level is protocol number.
// *
// * Further levels are defined by the individual families below.
// */
//#define NET_MAXID	AF_MAX
//
//#define CTL_NET_NAMES { \
//	{ 0, 0 }, \
//	{ "unix", CTLTYPE_NODE }, \
//	{ "inet", CTLTYPE_NODE }, \
//	{ "implink", CTLTYPE_NODE }, \
//	{ "pup", CTLTYPE_NODE }, \
//	{ "chaos", CTLTYPE_NODE }, \
//	{ "xerox_ns", CTLTYPE_NODE }, \
//	{ "iso", CTLTYPE_NODE }, \
//	{ "emca", CTLTYPE_NODE }, \
//	{ "datakit", CTLTYPE_NODE }, \
//	{ "ccitt", CTLTYPE_NODE }, \
//	{ "ibm_sna", CTLTYPE_NODE }, \
//	{ "decnet", CTLTYPE_NODE }, \
//	{ "dec_dli", CTLTYPE_NODE }, \
//	{ "lat", CTLTYPE_NODE }, \
//	{ "hylink", CTLTYPE_NODE }, \
//	{ "appletalk", CTLTYPE_NODE }, \
//	{ "route", CTLTYPE_NODE }, \
//	{ "link_layer", CTLTYPE_NODE }, \
//	{ "xtp", CTLTYPE_NODE }, \
//	{ "coip", CTLTYPE_NODE }, \
//	{ "cnt", CTLTYPE_NODE }, \
//	{ "rtip", CTLTYPE_NODE }, \
//	{ "ipx", CTLTYPE_NODE }, \
//	{ "sip", CTLTYPE_NODE }, \
//	{ "pip", CTLTYPE_NODE }, \
//	{ "isdn", CTLTYPE_NODE }, \
//	{ "key", CTLTYPE_NODE }, \
//	{ "inet6", CTLTYPE_NODE }, \
//	{ "natm", CTLTYPE_NODE }, \
//	{ "atm", CTLTYPE_NODE }, \
//	{ "hdrcomplete", CTLTYPE_NODE }, \
//	{ "netgraph", CTLTYPE_NODE }, \
//	{ "bluetooth", CTLTYPE_NODE}, \
//}
//
///*
// * PF_ROUTE - Routing table
// *
// * Three additional levels are defined:
// *	Fourth: address family, 0 is wildcard
// *	Fifth: type of info, defined below
// *	Sixth: flag(s) to mask with for NET_RT_FLAGS
// */
//#define NET_RT_DUMP	1		/* dump; may limit to a.f. */
 NET_RT_DUMP	= 1		/* dump; may limit to a.f. */
//#define NET_RT_FLAGS	2		/* by flags, e.g. RESOLVING */
 NET_RT_FLAGS	= 2		/* by flags, e.g. RESOLVING */
//#define NET_RT_IFLIST	3		/* survey interface list */
 NET_RT_IFLIST	= 3		/* survey interface list */
//#define	NET_RT_MAXID	4
	NET_RT_MAXID	= 4
//
//#define CTL_NET_RT_NAMES { \
//	{ 0, 0 }, \
//	{ "dump", CTLTYPE_STRUCT }, \
//	{ "flags", CTLTYPE_STRUCT }, \
//	{ "iflist", CTLTYPE_STRUCT }, \
//}
//
///*
// * Maximum queue length specifiable by listen.
// */
//#define	SOMAXCONN	128
//
///*
// * Maximum setsockopt buffer size
// */
//#define SOMAXOPT_SIZE	65536
//
///*
// * Message header for recvmsg and sendmsg calls.
// * Used value-result for recvmsg, value only for sendmsg.
// */
//struct msghdr {
//	void		*msg_name;		/* optional address */
//	socklen_t	 msg_namelen;		/* size of address */
//	struct iovec	*msg_iov;		/* scatter/gather array */
//	int		 msg_iovlen;		/* # elements in msg_iov */
//	void		*msg_control;		/* ancillary data, see below */
//	socklen_t	 msg_controllen;	/* ancillary data buffer len */
//	int		 msg_flags;		/* flags on received message */
//};
//
//#define	MSG_OOB		0x00000001	/* process out-of-band data */
//#define	MSG_PEEK	0x00000002	/* peek at incoming message */
//#define	MSG_DONTROUTE	0x00000004	/* send without using routing tables */
//#define	MSG_EOR		0x00000008	/* data completes record */
//#define	MSG_TRUNC	0x00000010	/* data discarded before delivery */
//#define	MSG_CTRUNC	0x00000020	/* control data lost before delivery */
//#define	MSG_WAITALL	0x00000040	/* wait for full request or error */
//#define	MSG_DONTWAIT	0x00000080	/* this message should be nonblocking */
//#define	MSG_EOF		0x00000100	/* data completes connection */
//#define	MSG_NOTIFICATION 0x00000200	/* notification message */
//#define	MSG_NOSIGNAL	0x00000400	/* No SIGPIPE to unconnected socket stream */
//#define	MSG_SYNC	0x00000800	/* No asynchronized pru_send */
//
///*
// * These override FIONBIO.  MSG_FNONBLOCKING is functionally equivalent to
// * MSG_DONTWAIT.
// */
//#define MSG_FBLOCKING	0x00010000	/* force blocking operation */
//#define MSG_FNONBLOCKING 0x00020000	/* force non-blocking operation */
//
//#define MSG_FMASK	0xFFFF0000	/* force mask */
//
///*
// * Header for ancillary data objects in msg_control buffer.
// * Used for additional information with/about a datagram
// * not expressible by flags.  The format is a sequence
// * of message elements headed by cmsghdr structures.
// */
//struct cmsghdr {
//	socklen_t	cmsg_len;		/* data byte count, including hdr */
//	int		cmsg_level;		/* originating protocol */
//	int		cmsg_type;		/* protocol-specific type */
///* followed by	u_char  cmsg_data[]; */
//};
//
///*
// * While we may have more groups than this, the cmsgcred struct must
// * be able to fit in an mbuf, and NGROUPS_MAX is too large to allow
// * this.
//*/
//#define CMGROUP_MAX 16
//
///*
// * Credentials structure, used to verify the identity of a peer
// * process that has sent us a message. This is allocated by the
// * peer process but filled in by the kernel. This prevents the
// * peer from lying about its identity. (Note that cmcred_groups[0]
// * is the effective GID.)
// */
//struct cmsgcred {
//	pid_t	cmcred_pid;		/* PID of sending process */
//	uid_t	cmcred_uid;		/* real UID of sending process */
//	uid_t	cmcred_euid;		/* effective UID of sending process */
//	gid_t	cmcred_gid;		/* real GID of sending process */
//	short	cmcred_ngroups;		/* number or groups */
//	gid_t	cmcred_groups[CMGROUP_MAX];	/* groups */
//};
//
///* Alignment requirement for CMSG struct manipulation */
//#define _CMSG_ALIGN(n)		(((n) + 3) & ~3)
//
//#ifdef _KERNEL
//#define CMSG_ALIGN(n)		_CMSG_ALIGN(n)
//#endif
//
///* given pointer to struct cmsghdr, return pointer to data */
//#define	CMSG_DATA(cmsg)		((unsigned char *)(cmsg) + \
//				 _CMSG_ALIGN(sizeof(struct cmsghdr)))
//
///* given pointer to struct cmsghdr, return pointer to next cmsghdr */
//#define	CMSG_NXTHDR(mhdr, cmsg)	\
//	(((caddr_t)(cmsg) + _CMSG_ALIGN((cmsg)->cmsg_len) + \
//	  _CMSG_ALIGN(sizeof(struct cmsghdr)) > \
//	    (caddr_t)(mhdr)->msg_control + (mhdr)->msg_controllen) ? \
//	    NULL : \
//	    (struct cmsghdr *)((caddr_t)(cmsg) + _CMSG_ALIGN((cmsg)->cmsg_len)))
//
///*
// * RFC 2292 requires to check msg_controllen, in case that the kernel returns
// * an empty list for some reasons.
// */
//#define	CMSG_FIRSTHDR(mhdr) \
//	((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \
//	 (struct cmsghdr *)(mhdr)->msg_control : \
//	 NULL)
//
///* RFC 2292 additions */
//	
//#define	CMSG_SPACE(l)		(_CMSG_ALIGN(sizeof(struct cmsghdr)) + _CMSG_ALIGN(l))
//#define	CMSG_LEN(l)		(_CMSG_ALIGN(sizeof(struct cmsghdr)) + (l))
//
///* "Socket"-level control message types: */
//#define	SCM_RIGHTS	0x01		/* access rights (array of int) */
//#define	SCM_TIMESTAMP	0x02		/* timestamp (struct timeval) */
//#define	SCM_CREDS	0x03		/* process creds (struct cmsgcred) */
//
///*
// * howto arguments for shutdown(2), specified by Posix.1g.
// */
//#define	SHUT_RD		0		/* shut down the reading side */
	SHUT_RD		= 0		/* shut down the reading side */
//#define	SHUT_WR		1		/* shut down the writing side */
	SHUT_WR		= 1		/* shut down the writing side */
//#define	SHUT_RDWR	2		/* shut down both sides */
	SHUT_RDWR	= 2		/* shut down both sides */
//
///*
// * sendfile(2) header/trailer struct
// */
//struct sf_hdtr {
//	struct iovec *headers;	/* pointer to an array of header struct iovec's */
//	int hdr_cnt;		/* number of header iovec's */
//	struct iovec *trailers;	/* pointer to an array of trailer struct iovec's */
//	int trl_cnt;		/* number of trailer iovec's */
//};
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//
//#ifndef _SYS_CDEFS_H_
//#include <sys/cdefs.h>
//#endif
//
//__BEGIN_DECLS
//int	accept (int, struct sockaddr *, socklen_t *);
//int	extaccept (int, int, struct sockaddr *, socklen_t *);
//int	bind (int, const struct sockaddr *, socklen_t);
//int	connect (int, const struct sockaddr *, socklen_t);
//int	extconnect (int, int, struct sockaddr *, socklen_t);
//int	getpeername (int, struct sockaddr *, socklen_t *);
//int	getsockname (int, struct sockaddr *, socklen_t *);
//int	getsockopt (int, int, int, void *, socklen_t *);
//int	listen (int, int);
//ssize_t	recv (int, void *, size_t, int);
//ssize_t	recvfrom (int, void *, size_t, int, struct sockaddr *, socklen_t *);
//ssize_t	recvmsg (int, struct msghdr *, int);
//ssize_t	send (int, const void *, size_t, int);
//ssize_t	sendto (int, const void *,
//	    size_t, int, const struct sockaddr *, socklen_t);
//ssize_t	sendmsg (int, const struct msghdr *, int);
//int	sendfile (int, int, off_t, size_t, struct sf_hdtr *, off_t *, int);
//int	setsockopt (int, int, int, const void *, socklen_t);
//int	shutdown (int, int);
//int	sockatmark(int);
//int	socketpair (int, int, int, int *);
//
//void	pfctlinput (int, struct sockaddr *);
//__END_DECLS
//
//#endif /* !_KERNEL */
//
//#if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
//#ifndef _SYS_CDEFS_H_
//#include <sys/cdefs.h>
//#endif
//
//__BEGIN_DECLS
//int	socket (int, int, int);
//__END_DECLS
//#endif	/* !_KERNEL || _KERNEL_VIRTUAL */
//
//#endif /* !_SYS_SOCKET_H_ */

// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/net/route.h

///*
// * Copyright (c) 2004, 2005 The DragonFly Project.  All rights reserved.
// *
// * This code is derived from software contributed to The DragonFly Project
// * by Jeffrey M. Hsu.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. Neither the name of The DragonFly Project nor the names of its
// *    contributors may be used to endorse or promote products derived
// *    from this software without specific, prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
// * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
// * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
// * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
// * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// */
//
///*
// * Copyright (c) 1980, 1986, 1993
// *	The Regents of the University of California.  All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the
// *    documentation and/or other materials provided with the distribution.
// * 3. All advertising materials mentioning features or use of this software
// *    must display the following acknowledgement:
// *	This product includes software developed by the University of
// *	California, Berkeley and its contributors.
// * 4. Neither the name of the University nor the names of its contributors
// *    may be used to endorse or promote products derived from this software
// *    without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// * SUCH DAMAGE.
// *
// *	@(#)route.h	8.4 (Berkeley) 1/9/95
// * $FreeBSD: src/sys/net/route.h,v 1.36.2.5 2002/02/01 11:48:01 ru Exp $
// * $DragonFly: src/sys/net/route.h,v 1.24 2008/09/11 11:23:29 sephe Exp $
// */
//
//#ifndef _NET_ROUTE_H_
//#define _NET_ROUTE_H_
//
//#ifndef _SYS_TYPES_H_
//#include <sys/types.h>
//#endif
//#ifndef _SYS_PARAM_H_
//#include <sys/param.h>
//#endif
//#ifndef _SYS_SOCKET_H_
//#include <sys/socket.h>
//#endif
//
///*
// * Kernel resident routing tables.
// *
// * The routing tables are initialized when interface addresses
// * are set by making entries for all directly connected interfaces.
// */
//
///*
// * A route consists of a destination address and a reference
// * to a routing entry.  These are often held by protocols
// * in their control blocks, e.g. inpcb.
// */
//struct route {
//	struct	rtentry *ro_rt;
//	struct	sockaddr ro_dst;
//};
//
///*
// * These numbers are used by reliable protocols for determining
// * retransmission behavior and are included in the routing structure.
// */
//struct rt_metrics {	/* grouped for locality of reference */
//	u_long	rmx_locks;	/* Kernel must leave these values alone */
//	u_long	rmx_mtu;	/* MTU for this path */
//	u_long	rmx_pksent;	/* packets sent using this route */
//	u_long	rmx_expire;	/* lifetime for route */
//
//	u_long	rmx_sendpipe;	/* outbound delay-bandwidth product */
//	u_long	rmx_ssthresh;	/* outbound gateway buffer limit */
//	u_long	rmx_rtt;	/* estimated round trip time */
//	u_long	rmx_rttvar;	/* estimated rtt variance */
//
//	u_long	rmx_recvpipe;	/* inbound delay-bandwidth product */
//	u_long	rmx_hopcount;	/* max hops expected */
//	u_short rmx_mssopt;	/* peer's cached MSS */
//	u_short	rmx_pad;	/* explicit pad */
//	u_long	rmx_msl;	/* maximum segment lifetime, unit: ms */
//	u_long	rmx_iwmaxsegs;	/* IW segments max */
//	u_long	rmx_iwcapsegs;	/* IW segments */
//};
//
///*
// * rmx_rtt and rmx_rttvar are stored as microseconds;
// * RTTTOPRHZ(rtt) converts to a value suitable for use
// * by a protocol slowtimo counter.
// */
//#define	RTM_RTTUNIT	1000000	/* units for rtt, rttvar, as units per sec */
//#define	RTTTOPRHZ(r)	((r) / (RTM_RTTUNIT / PR_SLOWHZ))
//
///*
// * XXX kernel function pointer `rt_output' is visible to applications.
// */
//struct mbuf;
//
///*
// * We distinguish between routes to hosts and routes to networks,
// * preferring the former if available.  For each route we infer
// * the interface to use from the gateway address supplied when
// * the route was entered.  Routes that forward packets through
// * gateways are marked so that the output routines know to address the
// * gateway rather than the ultimate destination.
// */
//#ifndef RNF_NORMAL
//#include <net/radix.h>
//#endif
//
//struct rtentry {
//	struct	radix_node rt_nodes[2];	/* tree glue, and other values */
//#define	rt_key(r)	((struct sockaddr *)((r)->rt_nodes->rn_key))
//#define	rt_mask(r)	((struct sockaddr *)((r)->rt_nodes->rn_mask))
//	struct	sockaddr *rt_gateway;	/* value */
//	long	rt_refcnt;		/* # held references */
//	u_long	rt_flags;		/* up/down?, host/net */
//	struct	ifnet *rt_ifp;		/* the answer: interface to use */
//	struct	ifaddr *rt_ifa;		/* the answer: interface to use */
//	struct	sockaddr *rt_genmask;	/* for generation of cloned routes */
//	void	*rt_llinfo;		/* pointer to link level info cache */
//	struct	rt_metrics rt_rmx;	/* metrics used by rx'ing protocols */
//	struct	rtentry *rt_gwroute;	/* implied entry for gatewayed routes */
//	int	(*rt_output) (struct ifnet *, struct mbuf *, struct sockaddr *,
//			      struct rtentry *);
//					/* output routine for this (rt,if) */
//	struct	rtentry *rt_parent;	/* cloning parent of this route */
//	int	rt_cpuid;		/* owner cpu */
//	struct	sockaddr *rt_shim[3];	/* mpls label / operation array */
//};
//
///*
// * Following structure necessary for 4.3 compatibility;
// * We should eventually move it to a compat file.
// */
//struct ortentry {
//	u_long	rt_hash;		/* to speed lookups */
//	struct	sockaddr rt_dst;	/* key */
//	struct	sockaddr rt_gateway;	/* value */
//	short	rt_flags;		/* up/down?, host/net */
//	short	rt_refcnt;		/* # held references */
//	u_long	rt_use;			/* raw # packets forwarded */
//	struct	ifnet *rt_ifp;		/* the answer: interface to use */
//};
//
//#define rt_use rt_rmx.rmx_pksent
//
//#define	RTF_UP		0x1		/* route usable */
//#define	RTF_GATEWAY	0x2		/* destination is a gateway */
//#define	RTF_HOST	0x4		/* host entry (net otherwise) */
//#define	RTF_REJECT	0x8		/* host or net unreachable */
//#define	RTF_DYNAMIC	0x10		/* created dynamically (by redirect) */
//#define	RTF_MODIFIED	0x20		/* modified dynamically (by redirect) */
//#define RTF_DONE	0x40		/* message confirmed */
///*			0x80		   unused, was RTF_DELCLONE */
//#define RTF_CLONING	0x100		/* generate new routes on use */
//#define RTF_XRESOLVE	0x200		/* external daemon resolves name */
//#define RTF_LLINFO	0x400		/* generated by link layer (e.g. ARP) */
//#define RTF_STATIC	0x800		/* manually added */
//#define RTF_BLACKHOLE	0x1000		/* just discard pkts (during updates) */
//#define RTF_PROTO2	0x4000		/* protocol specific routing flag */
//#define RTF_PROTO1	0x8000		/* protocol specific routing flag */
//
//#define RTF_PRCLONING	0x10000		/* protocol requires cloning */
//#define RTF_WASCLONED	0x20000		/* route generated through cloning */
//#define RTF_PROTO3	0x40000		/* protocol specific routing flag */
///*			0x80000		   unused */
//#define RTF_PINNED	0x100000	/* future use */
//#define	RTF_LOCAL	0x200000	/* route represents a local address */
//#define	RTF_BROADCAST	0x400000	/* route represents a bcast address */
//#define	RTF_MULTICAST	0x800000	/* route represents a mcast address */
//#define	RTF_MPLSOPS	0x1000000	/* route uses mpls label operations */
//					/* 0x2000000 and up unassigned */
//
///*
// * Routing statistics.
// */
//struct	rtstatistics {
//	u_long	rts_badredirect;	/* bogus redirect calls */
//	u_long	rts_dynamic;		/* routes created by redirects */
//	u_long	rts_newgateway;		/* routes modified by redirects */
//	u_long	rts_unreach;		/* lookups which failed */
//	u_long	rts_wildcard;		/* lookups satisfied by a wildcard */
//};
///*
// * Structures for routing messages.
// */
//struct rt_msghdr {
//	u_short	rtm_msglen;	/* to skip over non-understood messages */
//	u_char	rtm_version;	/* future binary compatibility */
//	u_char	rtm_type;	/* message type */
//	u_short	rtm_index;	/* index for associated ifp */
//	int	rtm_flags;	/* flags, incl. kern & message, e.g. DONE */
//	int	rtm_addrs;	/* bitmask identifying sockaddrs in msg */
//	pid_t	rtm_pid;	/* identify sender */
//	int	rtm_seq;	/* for sender to identify action */
//	int	rtm_errno;	/* why failed */
//	int	rtm_use;	/* from rtentry */
//	u_long	rtm_inits;	/* which metrics we are initializing */
//	struct	rt_metrics rtm_rmx; /* metrics themselves */
//};
//
//#define RTM_VERSION	6	/* Up the ante and ignore older versions */
//
///*
// * Message types.
// */
//#define RTM_ADD		0x1	/* Add Route */
//#define RTM_DELETE	0x2	/* Delete Route */
//#define RTM_CHANGE	0x3	/* Change Metrics or flags */
//#define RTM_GET		0x4	/* Report Metrics */
//#define RTM_LOSING	0x5	/* Kernel Suspects Partitioning */
//#define RTM_REDIRECT	0x6	/* Told to use different route */
//#define RTM_MISS	0x7	/* Lookup failed on this address */
//#define RTM_LOCK	0x8	/* fix specified metrics */
//#define RTM_OLDADD	0x9	/* caused by SIOCADDRT */
//#define RTM_OLDDEL	0xa	/* caused by SIOCDELRT */
//#define RTM_RESOLVE	0xb	/* req to resolve dst to LL addr */
//#define RTM_NEWADDR	0xc	/* address being added to iface */
//#define RTM_DELADDR	0xd	/* address being removed from iface */
//#define RTM_IFINFO	0xe	/* iface going up/down etc. */
//#define	RTM_NEWMADDR	0xf	/* mcast group membership being added to if */
//#define	RTM_DELMADDR	0x10	/* mcast group membership being deleted */
//#define	RTM_IFANNOUNCE	0x11	/* iface arrival/departure */
//#define	RTM_IEEE80211	0x12	/* IEEE80211 wireless event */
//
///*
// * Bitmask values for rtm_inits and rmx_locks.
// */
//#define RTV_MTU		0x1	/* init or lock _mtu */
//#define RTV_HOPCOUNT	0x2	/* init or lock _hopcount */
//#define RTV_EXPIRE	0x4	/* init or lock _expire */
//#define RTV_RPIPE	0x8	/* init or lock _recvpipe */
//#define RTV_SPIPE	0x10	/* init or lock _sendpipe */
//#define RTV_SSTHRESH	0x20	/* init or lock _ssthresh */
//#define RTV_RTT		0x40	/* init or lock _rtt */
//#define RTV_RTTVAR	0x80	/* init or lock _rttvar */
//#define RTV_MSL		0x100	/* init or lock _msl */
//#define RTV_IWMAXSEGS	0x200	/* init or lock _iwmaxsegs */
//#define RTV_IWCAPSEGS	0x400	/* init or lock _iwcapsegs */
//
///*
// * Bitmask values for rtm_addrs.
// */
 RTA_DST		= 0x1	/* destination sockaddr present */
 RTA_GATEWAY	= 0x2	/* gateway sockaddr present */
 RTA_NETMASK	= 0x4	/* netmask sockaddr present */
 RTA_GENMASK	= 0x8	/* cloning mask sockaddr present */
 RTA_IFP		= 0x10	/* interface name sockaddr present */
 RTA_IFA		= 0x20	/* interface addr sockaddr present */
 RTA_AUTHOR	= 0x40	/* sockaddr for author of redirect */
 RTA_BRD		= 0x80	/* for NEWADDR, broadcast or p-p dest addr */
 RTA_MPLS1	= 0x100	/* mpls label and/or operation present */
 RTA_MPLS2	= 0x200	/* mpls label and/or operation present */
 RTA_MPLS3	= 0x400	/* mpls label and/or operation present */
//
///*
// * Index offsets for sockaddr array for alternate internal encoding.
// */
 RTAX_DST	= 0	/* destination sockaddr present */
 RTAX_GATEWAY	= 1	/* gateway sockaddr present */
 RTAX_NETMASK	= 2	/* netmask sockaddr present */
 RTAX_GENMASK	= 3	/* cloning mask sockaddr present */
 RTAX_IFP	= 4	/* interface name sockaddr present */
 RTAX_IFA	= 5	/* interface addr sockaddr present */
 RTAX_AUTHOR	= 6	/* sockaddr for author of redirect */
 RTAX_BRD	= 7	/* for NEWADDR, broadcast or p-p dest addr */
 RTAX_MPLS1	= 8	/* mpls label and/or operation present */
 RTAX_MPLS2	= 9	/* mpls label and/or operation present */
 RTAX_MPLS3	= 10	/* mpls label and/or operation present */
 RTAX_MAX	= 11	/* size of array to allocate */
//
//struct rt_addrinfo {
//	int		 rti_addrs;
//	struct sockaddr	*rti_info[RTAX_MAX];
//	int		 rti_flags;
//	struct ifaddr	*rti_ifa;
//	struct ifnet	*rti_ifp;
//};
//
//#ifdef _KERNEL
//
//#define	rti_dst		rti_info[RTAX_DST]
//#define	rti_gateway	rti_info[RTAX_GATEWAY]
//#define	rti_netmask	rti_info[RTAX_NETMASK]
//#define	rti_genmask	rti_info[RTAX_GENMASK]
//#define	rti_ifpaddr	rti_info[RTAX_IFP]
//#define	rti_ifaaddr	rti_info[RTAX_IFA]
//#define	rti_author	rti_info[RTAX_AUTHOR]
//#define	rti_bcastaddr	rti_info[RTAX_BRD]
//#define	rti_mpls1	rti_info[RTAX_MPLS1]
//#define	rti_mpls2	rti_info[RTAX_MPLS2]
//#define	rti_mpls3	rti_info[RTAX_MPLS3]
//
//extern struct radix_node_head *rt_tables[MAXCPU][AF_MAX+1];
//
//struct ifmultiaddr;
//struct proc;
//struct ucred;
//
//void	 route_init (void);
//void	 rt_dstmsg(int type, struct sockaddr *dst, int error);
//int	 rt_getifa (struct rt_addrinfo *);
//void	 rt_ieee80211msg(struct ifnet *, int, void *, size_t);
//void	 rt_ifannouncemsg (struct ifnet *, int);
//void	 rt_ifmsg (struct ifnet *);
//int	 rt_llroute (struct sockaddr *dst, struct rtentry *rt0,
//	    struct rtentry **drt);
//void	 rt_missmsg (int, struct rt_addrinfo *, int, int);
//void	 rt_newaddrmsg (int, struct ifaddr *, int, struct rtentry *);
//void	 rt_newmaddrmsg (int, struct ifmultiaddr *);
//void	 rt_rtmsg(int cmd, struct rtentry *rt, struct ifnet *ifp, int error);
//int	 rt_setgate (struct rtentry *,
//	    struct sockaddr *, struct sockaddr *, boolean_t);
//void	 rtalloc (struct route *);
//void	 rtalloc_ign (struct route *, u_long);
//
//struct rtentry *
//	 _rtlookup (struct sockaddr *, __boolean_t, u_long);
//#define		RTL_REPORTMSG	TRUE
//#define		RTL_DONTREPORT	FALSE
//
///* flags to ignore */
//#define		RTL_DOCLONE	0UL
//#define		RTL_DONTCLONE	(RTF_CLONING | RTF_PRCLONING)
//
///*
// * Look up a route with no cloning side-effects or miss reports generated.
// */
//static __inline struct rtentry *
//rtpurelookup(struct sockaddr *dst)
//{
//	return _rtlookup(dst, RTL_DONTREPORT, RTL_DONTCLONE);
//}
//
///*
// * Do full route lookup with cloning and reporting on misses.
// */
//static __inline struct rtentry *
//rtlookup(struct sockaddr *dst)
//{
//	return _rtlookup(dst, RTL_REPORTMSG, RTL_DOCLONE);
//}
//
//typedef void (*rtrequest1_callback_func_t)(int, int, struct rt_addrinfo *,
//				      struct rtentry *, void *);
//typedef int (*rtsearch_callback_func_t)(int, struct rt_addrinfo *,
//					struct rtentry *, void *, int);
//
//void	 rtfree (struct rtentry *);
//int	 rtinit (struct ifaddr *, int, int);
//int	 rtchange (struct ifaddr *, struct ifaddr *);
//int	 rtioctl (u_long, caddr_t, struct ucred *);
//void	 rtredirect (struct sockaddr *, struct sockaddr *,
//	    struct sockaddr *, int, struct sockaddr *);
//int	 rtrequest (int, struct sockaddr *,
//	    struct sockaddr *, struct sockaddr *, int, struct rtentry **);
//int	 rtrequest_global (int, struct sockaddr *,
//	    struct sockaddr *, struct sockaddr *, int);
//int	 rtrequest1 (int, struct rt_addrinfo *, struct rtentry **);
//int	 rtrequest1_global (int, struct rt_addrinfo *,
//	    rtrequest1_callback_func_t, void *, boolean_t);
//
//#define RTS_EXACTMATCH		TRUE
//#define RTS_NOEXACTMATCH	FALSE
//
//#define RTREQ_PRIO_HIGH		TRUE
//#define RTREQ_PRIO_NORM		FALSE
//
//int	 rtsearch_global(int, struct rt_addrinfo *,
//	    rtsearch_callback_func_t, void *, boolean_t, boolean_t);
//
//int	 rtmask_add_global(struct sockaddr *, boolean_t);
//
//struct sockaddr *_rtmask_lookup(struct sockaddr *, boolean_t);
//
//static __inline struct sockaddr *
//rtmask_lookup(struct sockaddr *_mask)
//{
//	return _rtmask_lookup(_mask, FALSE);
//}
//
//static __inline struct sockaddr *
//rtmask_purelookup(struct sockaddr *_mask)
//{
//	return _rtmask_lookup(_mask, TRUE);
//}
//
//void	rtfree_oncpu(struct rtentry *);
//void	rtfree_remote(struct rtentry *);
//void	rt_print(struct rt_addrinfo *, struct rtentry *);
//void	rt_addrinfo_print(int cmd, struct rt_addrinfo *);
//void	sockaddr_print(struct sockaddr *);
//
//struct netmsg_base;
//int	rt_domsg_global(struct netmsg_base *);
//
//#ifndef _SYS_GLOBALDATA_H_
//#include <sys/globaldata.h>
//#endif
//
//static __inline void
//RTFREE(struct rtentry *rt)
//{
//	if (rt->rt_cpuid == mycpuid) {
//		if (rt->rt_refcnt <= 1)
//			rtfree_oncpu(rt);
//		else
//			--rt->rt_refcnt;
//	} else {
//		rtfree_remote(rt);
//	}
//}
//
//int	in_inithead(void **, int);
//#endif
//
//#endif




)

// Signals
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/signal.h
const (
	SIGHUP		= Signal(1)	/* hangup */
	SIGINT		= Signal(2)	/* interrupt */
	SIGQUIT		= Signal(3)	/* quit */
	SIGILL		= Signal(4)	/* illegal instr. (not reset when caught) */
	SIGTRAP		= Signal(5)	/* trace trap (not reset when caught) */
	SIGABRT		= Signal(6)	/* abort() */
	SIGIOT		= Signal(SIGABRT)	/* compatibility */
	SIGEMT		= Signal(7)	/* EMT instruction */
	SIGFPE		= Signal(8)	/* floating point exception */
	SIGKILL		= Signal(9)	/* kill (cannot be caught or ignored) */
	SIGBUS		= Signal(10)	/* bus error */
	SIGSEGV		= Signal(11)	/* segmentation violation */
	SIGSYS		= Signal(12)	/* non-existent system call invoked */
	SIGPIPE		= Signal(13)	/* write on a pipe with no one to read it */
	SIGALRM		= Signal(14)	/* alarm clock */
	SIGTERM		= Signal(15)	/* software termination signal from kill */
	SIGURG		= Signal(16)	/* urgent condition on IO channel */
	SIGSTOP		= Signal(17)	/* sendable stop signal not from tty */
	SIGTSTP		= Signal(18)	/* stop signal from tty */
	SIGCONT		= Signal(19)	/* continue a stopped process */
	SIGCHLD		= Signal(20)	/* to parent on child stop or exit */
	SIGTTIN		= Signal(21)	/* to readers pgrp upon background tty read */
	SIGTTOU		= Signal(22)	/* like TTIN if (tp->t_local&LTOSTOP) */
	SIGIO		= Signal(23)	/* input/output possible signal */
	SIGXCPU		= Signal(24)	/* exceeded CPU time limit */
	SIGXFSZ		= Signal(25)	/* exceeded file size limit */
	SIGVTALRM	= Signal(26)	/* virtual time alarm */
	SIGPROF		= Signal(27)	/* profiling time alarm */
	SIGWINCH	= Signal(28)	/* window size changes */
	SIGINFO		= Signal(29)	/* information request */
	SIGUSR1		= Signal(30)	/* user defined signal 1 */
	SIGUSR2		= Signal(31)	/* user defined signal 2 */
	SIGTHR          = Signal(32)      /* Thread interrupt (FreeBSD-5 reserved) */
	SIGCKPT         = Signal(33)      /* checkpoint and continue */
	SIGCKPTEXIT     = Signal(34)      /* checkpoint and exit */
)

// Error table
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/sys/errno.h
var errors = [...]string{
	1: "Operation not permitted",
	2: "No such file or directory",
	3: "No such process",
	4: "Interrupted system call",
	5: "Input/output error",
	6: "Device not configured",
	7: "Argument list too long",
	8: "Exec format error",
	9: "Bad file descriptor",
	10: "No child processes",
	11: "Resource deadlock avoided",
	12: "Cannot allocate memory",
	13: "Permission denied",
	14: "Bad address",
	16: "Device busy",
	17: "File exists",
	18: "Cross-device link",
	19: "Operation not supported by device",
	20: "Not a directory",
	21: "Is a directory",
	22: "Invalid argument",
	23: "Too many open files in system",
	24: "Too many open files",
	25: "Inappropriate ioctl for device",
	27: "File too large",
	28: "No space left on device",
	29: "Illegal seek",
	30: "Read-only filesystem",
	31: "Too many links",
	32: "Broken pipe",

	/* math software */
	33: "Numerical argument out of domain",
	34: "Result too large",

	/* non-blocking and interrupt i/o */
	35: "Resource temporarily unavailable",
	63: "File name too long",

	/* should be rearranged */
	66: "Directory not empty",

	/* quotas & mush */

	77: "No locks available",
	78: "Function not implemented",

	89: "Bad message",
	90: "Multihop attempted",
	91: "Link has been severed",
	92: "Protocol error",
}

// Signal table
// http://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/lib/libc/gen/siglist.c
var signals = [...]string{
	SIGHUP:		"Hangup",
	SIGINT:		"Interrupt",
	SIGQUIT:	"Quit",
	SIGILL:		"Illegal instruction",
	SIGTRAP:	"Trace/BPT trap",
	SIGABRT:	"Abort trap",
	SIGEMT:		"EMT trap",
	SIGFPE:		"Floating point exception",
	SIGKILL:	"Killed",
	SIGBUS:		"Bus error",
	SIGSEGV:	"Segmentation fault",
	SIGSYS:		"Bad system call",
	SIGPIPE:	"Broken pipe",
	SIGALRM:	"Alarm clock",
	SIGTERM:	"Terminated",
	SIGURG:		"Urgent I/O condition",
	SIGSTOP:	"Suspended (signal)",
	SIGTSTP:	"Suspended",
	SIGCONT:	"Continued",
	SIGCHLD:	"Child exited",
	SIGTTIN:	"Stopped (tty input)",
	SIGTTOU:	"Stopped (tty output)",
	SIGIO:		"I/O possible",
	SIGXCPU:	"Cputime limit exceeded",
	SIGXFSZ:	"Filesize limit exceeded",
	SIGVTALRM:	"Virtual timer expired",
	SIGPROF:	"Profiling timer expired",
	SIGWINCH:	"Window size changes",
	SIGINFO:	"Information request",
	SIGUSR1:	"User defined signal 1",
	SIGUSR2:	"User defined signal 2",
}
